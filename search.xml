<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>30801202-AGC001</title>
    <url>/2021/08/03/AGC001/</url>
    <content><![CDATA[<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><blockquote>
<p>给出光源位置，求反射总距离</p>
</blockquote>
<p>考虑到 $N\leq 10^{12}$ ，找规律</p>
<p>每次看成从一个平行四边形的右下角 $(a,b)$ 向外发射</p>
<p>所以下一个平行四边形状态为：</p>
<script type="math/tex; mode=display">(a,\ b)\rightarrow

\begin{cases}

(a-b,b) &a>b \\

(a,b-a) &b>a \\

\end{cases}</script><p>显然任意 $a,b$ 为 $0$ 时终止</p>
<p>设 $f(a,b)$ 为从点 $(a,b)$ 开始的路径长度，则</p>
<script type="math/tex; mode=display">f(a,b)=\begin{cases}

2b+f(a-b,b) &a>b \\

2a+f(a,b-a) &b>a \\

a &a=b \\

\end{cases}</script><p>然而显然能找到规律，路径总长度为 $n-\gcd(n,x)$</p>
<p><del>这十分玄学，在VP的时候猜的，还不会证qwq</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll n,x;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="number">3</span>*(n-__gcd(n,x)));</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><blockquote>
<p>删除树的一些叶节点使直径 $\leq k$ 求最少删除的点数</p>
</blockquote>
<p>考虑到 $n\leq 2000$ ,所以 <del>是dp</del> 可以考虑枚举中心</p>
<p>再按 $n$ 的奇偶考虑一下中心是边还是点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e3</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],Next[N&lt;&lt;<span class="number">1</span>],ver[N&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line"><span class="keyword">int</span> n,k,ans=INT_MAX,d[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123; ver[++tot]=v,Next[tot]=head[u],head[u]=tot; ver[++tot]=u,Next[tot]=head[v],head[v]=tot;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> fa,<span class="keyword">int</span> *d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(rei i=head[now];i;i=Next[i])&#123;</span><br><span class="line">        rei y=ver[i]; <span class="keyword">if</span>(y==fa) <span class="keyword">continue</span>;</span><br><span class="line">        d[y]=d[now]+<span class="number">1</span>; <span class="built_in">dfs</span>(y,now,d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,u,v;i&lt;n;++i)&#123; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v); <span class="built_in">add</span>(u,v);&#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">dfs</span>(i,<span class="number">0</span>,d[i]);</span><br><span class="line">    <span class="keyword">if</span>(k&amp;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=tot;i+=<span class="number">2</span>)&#123;</span><br><span class="line">            rei u=ver[i],v=ver[i+<span class="number">1</span>],res=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) res+=d[u][i]&gt;k/<span class="number">2</span> &amp;&amp; d[v][i]&gt;k/<span class="number">2</span>;</span><br><span class="line">            ans=<span class="built_in">min</span>(res,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            rei res=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=n;++j) res+=d[i][j]&gt;k/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">// printf(&quot;%d\n&quot;,res);</span></span><br><span class="line">            ans=<span class="built_in">min</span>(ans,res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>给定了数列 $A$ 的重排列，构造出数列 $A,B$ ，满足 $\sum_A=\sum_B$ ，且能由两数列划分出的回文串的字符串只由同种字符构成</p>
</blockquote>
<p><del>神仙构造题</del></p>
<p>按回文的对应相等关系连边，例，对于 $a_1$ ，$1\rightarrow a_1 , 2\rightarrow a_1-1 , …$ ，依次连边，$b$ 同理</p>
<p>满足条件当且仅当将其连成一个连通块，每次连的边数为 $\sum_{i=1}\left\lfloor \frac{a_i}{2} \right\rfloor$</p>
<p>显然若有 $2$ 个以上的 $a_i$ 为奇数则无法构成连通块</p>
<p>先考虑特殊情况：当 $M=1$ 只需令 $a_1=N,b_1=1,b_2=N-1$ 即可</p>
<p>推广可得：所有奇数放在开头结尾构成 $A$,再使开头 $+1$ ,结尾 $-1$ 构造 $B$</p>
<p>可以发现这样使中间的连边错开且前后两边错开，边数恰为 $n-1$ ，构成树</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%*d%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> *a==<span class="number">1</span> ? <span class="built_in">puts</span>(<span class="string">&quot;1\n1\n1\n&quot;</span>) : <span class="built_in">printf</span>(<span class="string">&quot;%d\n2\n1 %d\n&quot;</span>,*a,*a<span class="number">-1</span>) ,<span class="number">0</span>;</span><br><span class="line">    rei mid=<span class="built_in">partition</span>(a,a+n,[](<span class="keyword">const</span> <span class="keyword">int</span> x)-&gt;<span class="keyword">bool</span>&#123; <span class="keyword">return</span> x%<span class="number">2</span>; &#125;)-a;</span><br><span class="line">    <span class="keyword">if</span>(mid&gt;<span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Impossible&quot;</span>),<span class="number">0</span>;</span><br><span class="line">    a[n]=*a;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>,a[i],i==n ? <span class="number">10</span> : <span class="number">32</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(b+<span class="number">1</span>,a+<span class="number">1</span>,n&lt;&lt;<span class="number">2</span>);</span><br><span class="line">    ++b[<span class="number">1</span>],--b[n],n-=!b[n];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>,b[i],i==n ? <span class="number">10</span> : <span class="number">32</span>);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>求 $\displaystyle{\sum_{i=1}^n\sum_{j=i+1}^n\binom{a_i+b_i+a_j+b_j}{a_i+a_j}}$</p>
</blockquote>
<p><del>在焦作一中听过</del></p>
<p>考虑组合数的几何意义，$\binom{x+y}{x}$ 即为从 $(0,0)\rightarrow (x,y)$ 的方案数</p>
<p>$\binom{a_i+b_i+a_j+b_j}{a_i+a_j}$ 即为从点 $(0,0) \ \Rightarrow \ (a_i+a_j,b_i+b_j)$ 的方案数，平移得 $(-a_i,-b_i) \ \Rightarrow \ (a_j,b_j)$ 的方案数，dp即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>,M=<span class="number">2100</span>,S=<span class="number">2050</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>,INV2=<span class="number">5e8</span>+<span class="number">4</span>;</span><br><span class="line">ll a[N],b[N],f[M&lt;&lt;<span class="number">1</span>][M&lt;&lt;<span class="number">1</span>],mul[M&lt;&lt;<span class="number">2</span>],inv[M&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> n; ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fix</span><span class="params">(ll &amp;x)</span></span>&#123; <span class="keyword">while</span>(x&gt;=mod) x-=mod; <span class="keyword">while</span>(x&lt;<span class="number">0</span>) x+=mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(ll x,ll y)</span></span>&#123; rei res=<span class="number">1</span>; <span class="keyword">while</span>(y)&#123; <span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=(ll) res*x%mod; x=(ll) x*x%mod; y&gt;&gt;=<span class="number">1</span>;&#125; <span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">get_inv</span><span class="params">(ll x)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">qpow</span>(x,mod<span class="number">-2</span>)%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">get_C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123; <span class="keyword">return</span> mul[n]*inv[n-m]%mod *inv[m]%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mul[<span class="number">0</span>]=<span class="number">1</span>,inv[<span class="number">0</span>]=<span class="built_in">get_inv</span>(mul[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=<span class="number">8000</span>;++i) mul[i]=mul[i<span class="number">-1</span>]*i%mod,inv[i]=<span class="built_in">get_inv</span>(mul[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a[i],&amp;b[i]),++f[ S-a[i] ][ S-b[i] ];</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=(S&lt;&lt;<span class="number">1</span>);++i) <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=(S&lt;&lt;<span class="number">1</span>);++j) <span class="built_in">fix</span>(f[i][j]+=(f[i<span class="number">-1</span>][j]+f[i][j<span class="number">-1</span>])%mod);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">fix</span>(ans+=(((f[ S+a[i] ][ S+b[i] ]-<span class="built_in">get_C</span>( (a[i]&lt;&lt;<span class="number">1</span>)+(b[i]&lt;&lt;<span class="number">1</span>),(a[i]&lt;&lt;<span class="number">1</span>))+mod)%mod)+mod)%mod);</span><br><span class="line">    <span class="built_in">fix</span>(ans*=INV2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>给定排列 $P$，当且仅当 $i,j$ 满足 $|p_i-p_j|=1$ 且 $|i-j|\geq k$ 是可以交换 $p_i$ 和 $p_j$ ，求最终字典序最小的排列</p>
</blockquote>
<p><del>又是我不会的神仙题</del></p>
<p><strong>将下标与权值交换位置，即构造序列 $q_{p_i}=i$ </strong></p>
<p>由此有很好的性质：</p>
<ul>
<li><p>变换的条件变为：当 $|q_i-q_{i+1}|\geq k$ 时交换 $q_i,q_{i+1}$ , 那么对于 $q_i$ ,$q_j\in [q_i-k+1,q_i+k-1]$ 始终在它后面</p>
</li>
<li><p>字典序最小可以转变为下标尽量小，权值尽量小，所以拓扑+贪心即可</p>
</li>
</ul>
<p>另：建图可以优化边数，用线段树维护偏序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[N&lt;&lt;<span class="number">1</span>],Next[N&lt;&lt;<span class="number">1</span>],in[N],tot;</span><br><span class="line"><span class="keyword">int</span> val[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,k,ans[N],p[N];</span><br><span class="line">priority_queue&lt;PII&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123; ver[++tot]=v,Next[tot]=head[u],head[u]=tot,++in[v];&#125;</span><br><span class="line"><span class="keyword">namespace</span> ST&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> pos,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		val[now]=<span class="built_in">min</span>(val[now],v); <span class="keyword">if</span>(l==r) <span class="keyword">return</span> ;</span><br><span class="line">		rei mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(pos&lt;=mid) <span class="keyword">return</span> <span class="built_in">change</span>(now&lt;&lt;<span class="number">1</span>,l,mid,pos,v);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">change</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,pos,v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(L&gt;R) <span class="keyword">return</span> INF;</span><br><span class="line">		<span class="keyword">if</span>(L&lt;=l &amp;&amp; r&lt;=R) <span class="keyword">return</span> val[now];</span><br><span class="line">		rei res=INF,mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(L&lt;=mid) res=<span class="built_in">min</span>(res,<span class="built_in">query</span>(now&lt;&lt;<span class="number">1</span>,l,mid,L,R));</span><br><span class="line">		<span class="keyword">if</span>(R&gt;mid) res=<span class="built_in">min</span>(res,<span class="built_in">query</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,L,R));</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(val,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> val);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>,x;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x),p[x]=i;</span><br><span class="line">	<span class="keyword">for</span>(rei x=n,y;x;--x)&#123;</span><br><span class="line">		y=ST::<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,<span class="built_in">max</span>(p[x]-k+<span class="number">1</span>,<span class="number">1</span>),p[x]<span class="number">-1</span>); <span class="keyword">if</span>(y!=INF) <span class="built_in">add</span>(x,y);</span><br><span class="line">		y=ST::<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,p[x]+<span class="number">1</span>,<span class="built_in">min</span>(p[x]+k<span class="number">-1</span>,n)); <span class="keyword">if</span>(y!=INF) <span class="built_in">add</span>(x,y);</span><br><span class="line">		ST::<span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,p[x],x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>(!in[i]) q.<span class="built_in">push</span>(<span class="built_in">mk</span>(-p[i],i));</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">		rei x=q.<span class="built_in">top</span>().second; q.<span class="built_in">pop</span>();</span><br><span class="line">		++m; ans[ p[x] ]=m;</span><br><span class="line">		<span class="keyword">for</span>(rei i=head[x];i;i=Next[i])&#123;</span><br><span class="line">			rei y=ver[i]; <span class="keyword">if</span>(--in[y]==<span class="number">0</span>) q.<span class="built_in">push</span>(<span class="built_in">mk</span>(-p[y],y));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>思维</tag>
        <tag>贪心</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>40801202-AGC002</title>
    <url>/2021/08/04/AGC002/</url>
    <content><![CDATA[<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>给一张图，多次询问，每次 $u\leftarrow v$ 中经过的不重复点数量 $=z$ ，求经过边最大编号最小值</p>
</blockquote>
<p>边权问题想到 $Kruskal$ 重构树</p>
<p>重构树上倍增二分即可</p>
<p><del>这道题还有一种整体二分+并查集做法，但我不会</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,w;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node &amp;a,<span class="keyword">const</span> node &amp;b)&#123; <span class="keyword">return</span> a.w&lt;b.w;&#125;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> anc[<span class="number">20</span>][N&lt;&lt;<span class="number">1</span>],fa[N&lt;&lt;<span class="number">1</span>],Size[N&lt;&lt;<span class="number">1</span>],edge_val[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_fa</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x==fa[x] ? x : fa[x]=<span class="built_in">find_fa</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find_anc</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">19</span>;~i;--i) <span class="keyword">if</span>(edge_val[ anc[i][x] ]&lt;=d) x=anc[i][x];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    x=<span class="built_in">find_anc</span>(x,d),y=<span class="built_in">find_anc</span>(y,d);</span><br><span class="line">    <span class="keyword">return</span> x==y ? Size[x]&gt;=z : Size[x]+Size[y]&gt;=z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    edge_val[<span class="number">0</span>]=m+<span class="number">1</span>; root=n;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) fa[i]=i,Size[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        rei u,v; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">        u=<span class="built_in">find_fa</span>(u),v=<span class="built_in">find_fa</span>(v);</span><br><span class="line">        <span class="keyword">if</span>(u==v) <span class="keyword">continue</span>;</span><br><span class="line">        fa[u]=fa[v]=++root;Size[root]=Size[u]+Size[v];</span><br><span class="line">        fa[root]=root; anc[<span class="number">0</span>][u]=anc[<span class="number">0</span>][v]=root; edge_val[root]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=root;i;--i) <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;<span class="number">20</span>;++j) anc[j][i]=anc[j<span class="number">-1</span>][ anc[j<span class="number">-1</span>][i] ];</span><br><span class="line">    rei Q;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;Q);</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        rei x,y,z; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        rei l=<span class="number">1</span>,r=m,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            rei mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">check</span>(x,y,z,mid) ? ans=mid,r=mid<span class="number">-1</span> : l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>博弈论 每次操作将当前最大堆的糖果全部吃完或将每堆糖果吃掉一个，吃完的人输</p>
</blockquote>
<p>GreenDay学长之前讲过</p>
<p>将每堆小石子的数量看成柱状图并排序，问题转化为从 $(1,1)$ 出发，每次只能向上或向右走一格，到边界者输</p>
<p>显然棱角处均为必败点，且<del>打表得</del> $y=-k\times x$ 直线上的格子性质相同</p>
<p>找最大的 $(i,i)$ 再简单判断即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">		<span class="keyword">if</span>(i+<span class="number">1</span>&gt;a[i+<span class="number">1</span>])&#123;<span class="comment">//最大正方形</span></span><br><span class="line">			<span class="keyword">if</span>((a[i]-i)&amp;<span class="number">1</span>)&#123; <span class="built_in">puts</span>(<span class="string">&quot;First&quot;</span>); <span class="keyword">break</span>;&#125;</span><br><span class="line">			rei right=i;</span><br><span class="line">			<span class="keyword">while</span>(a[right+<span class="number">1</span>]==i) ++right;</span><br><span class="line">			<span class="keyword">if</span>((right-i)&amp;<span class="number">1</span>)&#123; <span class="built_in">puts</span>(<span class="string">&quot;First&quot;</span>); <span class="keyword">break</span>;&#125;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;Second&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>给你 $n$ 种不含白色颜色的球，每个球有 $m$ 个，把这 $n\times m$ 个球排成一排，把每一种颜色的最左边出现的球涂成白色，求有多少种不同的颜色序列</p>
</blockquote>
<p>有 $m$ 个白球，$n$ 种其他颜色的球各 $m-1$ 个 只有任意前缀中白球的个数均大于其他颜色种类数时合法</p>
<p>考虑序列计数 $dp$: 枚举位置或元素，这里枚举元素</p>
<p>设状态 $f_{i,j}$ 表示在 $n\times m$ 个位置上填了 $i$ 个白球和 $j$ 个其他球</p>
<p>考虑合法序列的从左到右的第一个格子如何转移</p>
<script type="math/tex; mode=display">\therefore f_{i,j}=\underbrace{f_{i-1,j}}_{放白球} \ + \ \underbrace{f_{i,j-1}}_{放其他颜色} \times \underbrace{\left(n-j+1\right)}_{没有使用过的颜色}\times \underbrace{\binom{n\times m-i-(m-1)\times (j-1)-1}{m-2}}_{还有 m-2 个该颜色的球没有放}</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e3</span>+<span class="number">5</span>,M=<span class="number">4e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,f[N][N],fac[M],ifac[M],inv[M],ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123; <span class="keyword">return</span> (ll) fac[n]*ifac[n-m]%mod*ifac[m]%mod;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m); inv[<span class="number">1</span>]=ifac[<span class="number">0</span>]=fac[<span class="number">0</span>]=<span class="number">1</span>; f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;=n*m;++i) inv[i]=(ll) (mod-mod/i)*inv[mod%i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n*m;++i) fac[i]=(ll) i*fac[i<span class="number">-1</span>]%mod,ifac[i]=(ll) inv[i]*ifac[i<span class="number">-1</span>]%mod;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;=i;++j)&#123;</span><br><span class="line">            f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j) f[i][j]=(f[i][j]+(ll) f[i][j<span class="number">-1</span>]*(n-j+<span class="number">1</span>)%mod *<span class="built_in">C</span>(n*m-i-(j<span class="number">-1</span>)*(m<span class="number">-1</span>)<span class="number">-1</span>,m<span class="number">-2</span>)%mod)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,m==<span class="number">1</span> ? <span class="number">1</span> : f[n][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>思维</tag>
        <tag>dp</tag>
        <tag>博弈论</tag>
        <tag>Kruskal重构树</tag>
      </tags>
  </entry>
  <entry>
    <title>50801202-AGC003</title>
    <url>/2021/08/05/AGC003/</url>
    <content><![CDATA[<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>给定 $n$ 个数 ，要求从中选出最多的数，满足任意两个数之积都不是完全立方数</p>
</blockquote>
<p>考虑对数 $x$ 进行唯一分解，即将其每个质因子的指数对 $3$ 取模得到数 $a$ , 在对 $a$ 的每个质因子的指数的相反数对 $3$ 取模得到 $a$ 的补数 $b$ ,满足 $a\times b$ 是完全立方数</p>
<p>对于数列中的分解数集与其补数集，贪心选取较大的内个，注意特判最简数与其补数相等时（即 $x$ 是完全平方数）只能选一个</p>
<p>重点求如何分解数与分解数的补数</p>
<p>筛出 $10^{\frac{10}{3}}$ 内的质数，求出该范围内的分解数与补数，对于剩余的数分解质因数最多 $2$ 项，特判是否为完全平方数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p[]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">37</span>&#125;,S=<span class="number">127</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line">vector&lt;ll&gt; pd;</span><br><span class="line"><span class="keyword">int</span> n,c[N],ans;</span><br><span class="line">ll a[N],b[N];</span><br><span class="line">map&lt;ll,<span class="keyword">int</span>&gt; h,vis;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">qpow</span><span class="params">(ll a,ll b,ll n)</span></span>&#123; ll ret=<span class="number">1</span>; <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>,a=a*a%n) <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ret=a*ret%n; <span class="keyword">return</span> ret;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123; <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b,a%b) : a;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">miller_rabin</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;<span class="number">12</span>;++i) <span class="keyword">if</span>(n%p[i]==<span class="number">0</span>) <span class="keyword">return</span> n==p[i];</span><br><span class="line">    ll r; rei t;</span><br><span class="line">    <span class="keyword">for</span>(r=n<span class="number">-1</span>,t=<span class="number">0</span>;~r&amp;<span class="number">1</span>;r&gt;&gt;=<span class="number">1</span>,++t);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;<span class="number">12</span>;++i)&#123;</span><br><span class="line">        ll x=<span class="built_in">qpow</span>(p[i],r,n),xs;</span><br><span class="line">        <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=t;++j)&#123;</span><br><span class="line">            xs=x*x%n;</span><br><span class="line">            <span class="keyword">if</span>(xs==<span class="number">1</span> &amp;&amp; x!=<span class="number">1</span> &amp;&amp; x!=n<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            x=xs;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x!=<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=<span class="number">2200</span>;++i) <span class="keyword">if</span>(<span class="built_in">miller_rabin</span>(i)) pd.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        ll x,t; <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;x); a[i]=b[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(rei k=<span class="number">0</span>;k&lt;pd.<span class="built_in">size</span>();++k)&#123;</span><br><span class="line">            c[k]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(x%pd[k]==<span class="number">0</span>) ++c[k],x/=pd[k];</span><br><span class="line">            c[k]%=<span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span>(c[k]==<span class="number">2</span>) a[i]*=pd[k]*pd[k],b[i]*=pd[k];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c[k]==<span class="number">1</span>) a[i]*=pd[k],b[i]*=pd[k]*pd[k];</span><br><span class="line">        &#125;</span><br><span class="line">        t=<span class="built_in">sqrt</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(t*t==x) a[i]*=t*t,b[i]*=t;</span><br><span class="line">        <span class="keyword">else</span> a[i]*=x,b[i]*=x*x;</span><br><span class="line">        ++h[ a[i] ];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[ a[i] ]||vis[ b[i] ]||a[i]==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        vis[ a[i] ]=<span class="number">1</span>; ans+=<span class="built_in">max</span>(h[ a[i] ],h[ b[i] ]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans+(h[<span class="number">1</span>]!=<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>初始为 $1$ 到 $n$ 的数列，每次操作把数组长度变为 $q_i$ ，新增的数为上一个操作后的数组的重复，求最终每个数出现的次数</p>
</blockquote>
<p><del>这个题作为 $E$ 题好像有点水（逃</del></p>
<p>首先容易发现，对于每次操作，只有长度单调递增的操作对答案有贡献</p>
<p>考虑每次操作 $q$ 对数组 $A={a_1,a_2…a_n}$ 的影响：</p>
<script type="math/tex; mode=display">A\Rightarrow \underbrace{AAA...A}_{k=\left\lfloor \frac{q}{len_A} \right\rfloor} \ + \ a_1 \ + \ a_2 \ + \ ... \ + a_{q\%len_A}</script><p>题目要求维护 $ans[N]$，那么倒序维护系数 $k$ ，对于剩下的一部分递归继续分解</p>
<p>最后的答案用差分维护</p>
<p><del>经典不会表述，经典看不懂赛时代码</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line">ll k[N],delta[N],sta[N],top;</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decompose</span><span class="params">(ll lenth,ll k_add)</span></span>&#123;</span><br><span class="line">    rei it=<span class="built_in">upper_bound</span>(sta+<span class="number">1</span>,sta+<span class="number">1</span>+top,lenth)-sta<span class="number">-1</span>;<span class="comment">//注意这里要找剩下的</span></span><br><span class="line">    <span class="keyword">if</span>(!it) <span class="keyword">return</span> delta[<span class="number">1</span>]+=k_add,delta[lenth+<span class="number">1</span>]-=k_add,<span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">    k[it]+=(ll) (lenth/sta[it])*k_add;</span><br><span class="line">    <span class="built_in">decompose</span>(lenth%sta[it],k_add);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;q),sta[++top]=(ll) n;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=q;++i)&#123;</span><br><span class="line">        ll x; <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;x);</span><br><span class="line">        <span class="keyword">while</span>(top &amp;&amp; x&lt;=sta[top]) --top;</span><br><span class="line">        sta[++top]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    k[top]=<span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=top;i&gt;=<span class="number">2</span>;--i)&#123;</span><br><span class="line">        k[i<span class="number">-1</span>]+=(sta[i]/sta[i<span class="number">-1</span>])*k[i];</span><br><span class="line">        <span class="built_in">decompose</span>(sta[i]%sta[i<span class="number">-1</span>],k[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    delta[<span class="number">1</span>]+=k[<span class="number">1</span>],delta[ sta[<span class="number">1</span>]+<span class="number">1</span> ]-=k[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,delta[i]+=delta[i<span class="number">-1</span>]);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>给定一个 $n\times m$ 的黑白网格，保证黑格四连通且至少有一个黑格，定义分形如下：$0$ 级分形是一个 $1\times 1$ 的黑色单元格。$k+1$ 级分形由 $n$ 行 $m$ 列较小一级的分形按网格的样式拼成：与黑色单元格对应的位置是一个 $k$ 级分形；与白色单元格对应的位置是一个全部为白色，尺寸与 $k$ 级分形相同的网格。求 $k$ 级分形的四联通数量</p>
</blockquote>
<p>看个图直观一点</p>
<p><img src="https://pic.imgdb.cn/item/616d1ebe2ab3f51d91a7c34c.png" alt="https://pic.imgdb.cn/item/616d1ebe2ab3f51d91a7c34c.png"></p>
<p>考虑无向图 $G$ ，其中的点与 $1$ 级分形一一对应，将对应至少一个位置的黑发四联通的点连边</p>
<p>求$k$ 级分形对应的 $G$ 的连通分量数</p>
<p>显然 $G$ 的连边情况与网格的上下，左右的黑格位置是否重复有关，设 $lr,ud$ 分别表示上下，左右的黑格位置重复的个数，$v$ 表示原网格中黑格的个数，$ev,eh$ ：垂直/水平方向的相邻黑格的个数</p>
<ul>
<li><p>若 $lr&gt;0 \wedge ud&gt;0$，归纳可得 $G$ 任意两点均连通，故答案为 $1$。</p>
</li>
<li><p>若 $lr=0 \wedge ud=0$，归纳可得 $G$ 任意两点均不连通，故答案为 $v^{k-1}$。</p>
</li>
<li><p>若 $lr&gt;0 \wedge ud=0$，将网格逆时针旋转 $\frac{1}{4}$ 周变为情况 $4$。</p>
</li>
<li><p>若 $lr=0 \wedge ud&gt;0$，我们可以发现所有边都是垂直方向的，故 $G$ 一定是若干条垂直方向的链组成的。</p>
</li>
</ul>
<p>链是树，我们可以用 $C=V-E$ 来计算连通分量数。</p>
<p>有性质: $k$ 级分形等于把 $k-1$ 级分形的每个黑格替换成一个 $1$ 级分形。可以归纳证明。</p>
<p>那么考虑计算 $k$ 级分形对应的图 $G_k$ 中的点数 $V_k$ 和边数 $E_k$ ，有递推式：</p>
<p>$V_k=V_{k-1}\times v ,V_1=1$</p>
<p>$E_k=E_{k-1}\times ud + V_{k-1}\times ev ,E_1=0$</p>
<p>所以矩阵乘法计算 $V,E$ 线性递推</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e3</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll k;</span><br><span class="line"><span class="keyword">char</span> s[N][N];</span><br><span class="line"><span class="keyword">int</span> n,m,p,q,a,b,c;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Mat[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">Matrix</span>()&#123; <span class="built_in">memset</span>(Mat,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(Mat));&#125;</span><br><span class="line">    <span class="keyword">int</span>* <span class="keyword">operator</span> [](<span class="keyword">const</span> <span class="keyword">int</span> i)&#123; <span class="keyword">return</span> Mat[i];&#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span>*(Matrix &amp;mat)<span class="keyword">const</span>&#123;</span><br><span class="line">        Matrix ret;</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;<span class="number">2</span>;++j) <span class="keyword">for</span>(rei k=<span class="number">0</span>;k&lt;<span class="number">2</span>;++k)</span><br><span class="line">            ret[i][j]=(ret[i][j]+(ll) Mat[i][k]*mat[k][j]%mod)%mod;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">()</span></span>&#123; <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i) Mat[i][i]=<span class="number">1</span>;&#125;</span><br><span class="line">&#125;f;</span><br><span class="line"><span class="function">Matrix <span class="title">qpow</span><span class="params">(Matrix a,ll b)</span></span>&#123; Matrix ret;ret.<span class="built_in">set</span>(); <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>,a=a*a) <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ret=ret*a; <span class="keyword">return</span> ret;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s[i]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) p+=s[i][<span class="number">1</span>]==<span class="string">&#x27;#&#x27;</span>&amp;&amp;s[i][m]==<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=m;++i) q+=s[<span class="number">1</span>][i]==<span class="string">&#x27;#&#x27;</span>&amp;&amp;s[n][i]==<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>((p&amp;&amp;q) || k&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>),<span class="number">0</span>;</span><br><span class="line">	b=p|q;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">            c+=s[i][j]==<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">            a+=s[i][j]==<span class="string">&#x27;#&#x27;</span> &amp;&amp; s[i][j+<span class="number">1</span>]==<span class="string">&#x27;#&#x27;</span> &amp;&amp; p;</span><br><span class="line">            a+=s[i][j]==<span class="string">&#x27;#&#x27;</span> &amp;&amp; s[i+<span class="number">1</span>][j]==<span class="string">&#x27;#&#x27;</span> &amp;&amp; q;</span><br><span class="line">        &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=c,f[<span class="number">1</span>][<span class="number">0</span>]=a,f[<span class="number">1</span>][<span class="number">1</span>]=b;</span><br><span class="line">	f=<span class="built_in">qpow</span>(f,k<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(f[<span class="number">0</span>][<span class="number">0</span>]-f[<span class="number">1</span>][<span class="number">0</span>]+mod)%mod);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>贪心</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>60801202-AGC004</title>
    <url>/2021/08/06/AGC004/</url>
    <content><![CDATA[<p><del>这场好难qwq</del> 我好菜</p>
<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><blockquote>
<p>有 $2$ 种操作: 花费 $a_i$ 秒，直接获得颜色 $i$ 和 花费 $x$ 秒，使得之前获得的颜色 $i$ 全部变为颜色 $(i+1) \ \text{mod} \ n$ ，求收集到 $0$ 到 $n-1$ 所有颜色的最短时间</p>
</blockquote>
<p>每种方案的 $2操作$ 取决于被 $2操作$ 作用次数最多的颜色，考虑枚举 $2操作$ ，滑动窗口查询最小值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">4e3</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,x,a[N],q[N];</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;x);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]),a[i+n]=a[i];</span><br><span class="line">	<span class="keyword">for</span>(rei k=<span class="number">0</span>;k&lt;n;++k)&#123;</span><br><span class="line">		ll s=(ll) k*x; rei l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=k;++i)&#123;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;=r &amp;&amp; a[ q[r] ]&gt;=a[i]) --r;</span><br><span class="line">			q[++r]=i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(rei i=k+<span class="number">1</span>;i&lt;=n+k;++i)&#123;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;=r &amp;&amp; i-k&gt;q[l]) ++l;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;=r &amp;&amp; a[ q[r] ]&gt;=a[i]) --r;</span><br><span class="line">			q[++r]=i; s+=a[ q[l] ];</span><br><span class="line">		&#125;</span><br><span class="line">		ans=k ? <span class="built_in">min</span>(ans,s) : s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><blockquote>
<p>给出一个由 # 和 $.$ 组成的矩阵，让你给出两个大小相同且 # 是相连的矩阵，且这两个矩阵的 $.$ 重叠部分刚好是给出的这个矩阵。</p>
</blockquote>
<p>考虑题目中保证边界不被染色，即边界中不含有 $.$</p>
<p>所以只需要让行按照奇偶染色，最后一边染起始列，一边染结束列来保证连通</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> s[N][N],a[N][N],b[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s[i]+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=m;++j) a[i][j]=b[i][j]=s[i][j];</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) a[i][<span class="number">1</span>]=b[i][m]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">for</span>(rei j=<span class="number">2</span>;j&lt;m;++j) i&amp;<span class="number">1</span> ? a[i][j]=<span class="string">&#x27;#&#x27;</span> : b[i][j]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,a[i]+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,b[i]+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>$n$ 个城市，每个城市有一个传送点，传送到唯一另外一个城市，保证经过多次传送始终能到达 $1$ 号城市。现在修改一些点的目的地，使得从任何一点出发在传送 $k$ 次之后恰好都能到达 $1$ 号城市，求最少改变的数量。</p>
</blockquote>
<p>简化问题模型：城市构成一个基环内向树，要求修改尽可能少的出边是每个点到 $1$ 号点需要经过至多 $k$ 条边（考虑到没说禁止自环</p>
<p>那么选一些点传送至 $1$ 号点，再把原树分为几颗，其中最大深度不能超过 $k-1$，贪心即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> tot,head[N],Next[N&lt;&lt;<span class="number">1</span>],ver[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> ac[<span class="number">20</span>][N],d[N],cov[N],ans,fa[N];</span><br><span class="line">priority_queue&lt;PII&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123; ver[++tot]=v,Next[tot]=head[u],head[u]=tot;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    d[x]=d[ fa[x] ]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;<span class="number">20</span>;++i) ac[i][x]=ac[i<span class="number">-1</span>][ ac[i<span class="number">-1</span>][x] ];</span><br><span class="line">    <span class="keyword">for</span>(rei i=head[x];i;i=Next[i]) <span class="built_in">dfs</span>(ver[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cover</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cov[x]) <span class="keyword">return</span>; cov[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=head[x];i;i=Next[i]) <span class="built_in">cover</span>(ver[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;fa[i]);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;=n;++i) <span class="built_in">add</span>(ac[<span class="number">0</span>][i]=fa[i],i);</span><br><span class="line">    ans+=fa[<span class="number">1</span>]!=<span class="number">1</span>;<span class="comment">//添加1节点的自环</span></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) q.<span class="built_in">push</span>(<span class="built_in">mk</span>(d[i],i));</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        rei x=q.<span class="built_in">top</span>().second,anc=x; q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(cov[x] || d[x]-d[<span class="number">1</span>]&lt;=m) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">19</span>;~i;--i) <span class="keyword">if</span>(d[x]-d[ ac[i][anc] ]&lt;m &amp;&amp; ac[i][anc]) anc=ac[i][anc];</span><br><span class="line">        <span class="built_in">cover</span>(anc); ++ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>一个棋盘，每个格子有机器人或空格或出口 ，每次命令所有机器人向任意一个方向移动一格，如果超出了棋盘的边界或到了出口就会消失，求机器人到出口的最多数量</p>
</blockquote>
<p>让机器人移动相当于移动出口，出口自带框，出框的机器人消失，出口抵达的机器人出去</p>
<p>定义 $l,r,u,d$ 四个参数表示出口 $E$ 向 $4$ 个方向能抵达的最远位置，在最优情况下出口会跑成一个矩形</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/4vyc5rkx.png" alt="官方图1"></p>
<p>黄色区域就是机器人的移动范围，在该范围内的机器人取舍已经被计算好</p>
<p>再考虑曾经有这个移动范围时，不能走的格子</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/txvynkqu.png" alt="官方图2"></p>
<p>纯红色区域中的机器人全部死亡，不管</p>
<p>对于红黄详见的部分之前已经取舍，考虑白色部分的转移：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/0cln7tdd.png" alt="官方图3"></p>
<p>移动范围扩大，加上相应颜色区域的机器人数量即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e2</span>+<span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">return</span> a&gt;b?a:b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">return</span> a&lt;b?a:b;&#125;</span><br><span class="line"><span class="keyword">short</span> f[N][N][N][N],g[N][N],h[N][N];</span><br><span class="line"><span class="keyword">char</span> s[N][N];</span><br><span class="line"><span class="keyword">int</span> n,m,ans,px,py;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s[i]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i][j]==<span class="string">&#x27;E&#x27;</span>) px=i,py=j;</span><br><span class="line">            g[i][j]=g[i][j<span class="number">-1</span>]+(s[i][j]==<span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">            h[i][j]=h[i<span class="number">-1</span>][j]+(s[i][j]==<span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    rei pl=py<span class="number">-1</span>,pr=m-py,pd=px<span class="number">-1</span>,pu=n-px,p;</span><br><span class="line">    <span class="keyword">for</span>(rei l=<span class="number">0</span>;l&lt;=pl;++l) <span class="keyword">for</span>(rei r=<span class="number">0</span>;r&lt;=pr;++r) <span class="keyword">for</span>(rei d=<span class="number">0</span>;d&lt;=pd;++d) <span class="keyword">for</span>(rei u=<span class="number">0</span>;u&lt;=pu;++u)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!(~f[l][r][d][u])) <span class="keyword">continue</span>;</span><br><span class="line">		rei cl=<span class="built_in">max</span>(r+<span class="number">1</span>,py-l),cr=<span class="built_in">min</span>(m-l,py+r),cd=<span class="built_in">max</span>(u+<span class="number">1</span>,px-d),cu=<span class="built_in">min</span>(n-d,px+u);</span><br><span class="line">		<span class="keyword">if</span>((p=py+r+<span class="number">1</span>)&lt;=m-l) f[l][r+<span class="number">1</span>][d][u]=<span class="built_in">max</span>(f[l][r+<span class="number">1</span>][d][u] , f[l][r][d][u]+h[cu][p]-h[cd<span class="number">-1</span>][p]);</span><br><span class="line">		<span class="keyword">if</span>((p=py-l<span class="number">-1</span>)&gt;=r+<span class="number">1</span>) f[l+<span class="number">1</span>][r][d][u]=<span class="built_in">max</span>(f[l+<span class="number">1</span>][r][d][u] , f[l][r][d][u]+h[cu][p]-h[cd<span class="number">-1</span>][p]);</span><br><span class="line">		<span class="keyword">if</span>((p=px+u+<span class="number">1</span>)&lt;=n-d) f[l][r][d][u+<span class="number">1</span>]=<span class="built_in">max</span>(f[l][r][d][u+<span class="number">1</span>] , f[l][r][d][u]+g[p][cr]-g[p][cl<span class="number">-1</span>]);</span><br><span class="line">		<span class="keyword">if</span>((p=px-d<span class="number">-1</span>)&gt;=u+<span class="number">1</span>) f[l][r][d+<span class="number">1</span>][u]=<span class="built_in">max</span>(f[l][r][d+<span class="number">1</span>][u] , f[l][r][d][u]+g[p][cr]-g[p][cl<span class="number">-1</span>]);</span><br><span class="line">		ans=<span class="built_in">max</span>(ans,f[l][r][d][u]);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>给定一个 $N$ 个点，$M$ 条边的连通无向简单图，其中 $N_1\leq M\leq N$ ，每个点可以为黑或白，初始每个点都白。每次选择一对具有相同颜色且相邻的顶点，并反转它们的颜色 (即如果一条边的两端是白色的，可以将其变为黑色)。询问是否存在一种方案，将所有的点都变成黑色，输出最少的操作次数。</p>
</blockquote>
<p>由数据范围：</p>
<ul>
<li><p>先考虑树的情况</p>
<p>把树看成一个二分图并将所有点重新染色-左红右蓝。如此在初始时所有边上的点颜色都不相同</p>
<p>考虑每次操作：将颜色相同的点反色。转化为新染色方案中，找一对颜色不同的两端点，并交换颜色。显然有 <strong><em>\</em>原图中两点颜色相同的边经过反色操作形成的反色且颜色相同的边**</strong> 对应到 <strong><em>\</em>新的染色方案中两点颜色不同的边操作后两点颜色仍不同**</strong></p>
<p>所以问题转化为是否有方案将左红右蓝转化为左蓝右红</p>
<p>在新染色方案上考虑，找到不变量红点数量与蓝点数量。显然若初始时 $num_红!=num_蓝$ 无解</p>
<p>移动红点到原先蓝点的位置。 直接计算最少方案并不容易，考虑每条边的贡献</p>
<p>设这条边断掉后，左边红点比蓝点多 $L$ 个，则改变一定还需要被经过 $L$ 次</p>
<p>所以枚举每条边，统计出其一侧的红蓝点数量差并将绝对值相加</p>
</li>
<li><p>基环树</p>
<p>由于刚才用到二分图的性质，因此想到对基环树分奇环/偶环考虑</p>
<ul>
<li><p>奇环</p>
<p>为满足二分图，先断掉这个奇环，此时问题与树的情况相同</p>
<p>在考虑断掉的边，由于奇环，该边的两端点在二分图中处于同一侧</p>
<p>所以该边的两个端点可以同时改变颜色，即 $2蓝\Rightarrow 2红$ 或 $2红\Rightarrow 2蓝$</p>
<p>可以把红色看成棋子，蓝色看成空位。这条边相当于一个<strong><em>\</em>源/汇**</strong>，可以不断提供/吞没成对的棋子</p>
<p>$\therefore$ 这里判断的是红蓝色是否有相同的奇偶性，否 则无解，是 则算出源/汇需要提供多少次棋子，并与树情况算出的累加</p>
</li>
<li><p>偶环</p>
<p>对于偶环仍然满足二分图性质，所以需要判断的是红蓝点数是否相同</p>
<p>偶环的作用是提供枢纽，减少环中绕行的次数。显然环外的边经过次数不变，而环内边的经过次数相互约束：环内相邻两条边的经过次数（带符号）的差值恒定且与点有关</p>
<p>可以发现环上的交换是一个<a href="https://www.luogu.com.cn/problem/P2512">均分纸牌问题</a>，求中位数即可</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rei register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100054</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,L;</span><br><span class="line"><span class="keyword">int</span> ver[N&lt;&lt;<span class="number">1</span>],head[N],Next[N&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line"><span class="keyword">int</span> fa[N],depth[N],Size[N];</span><br><span class="line"><span class="keyword">int</span> cnt,buf[N];</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ad</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> (x<span class="number">-1</span>^<span class="number">1</span>)+<span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123; ver[++tot]=v,Next[tot]=head[u],head[u]=tot; ver[++tot]=u,Next[tot]=head[v],head[v]=tot;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	Size[x]=-(depth[x]&amp;<span class="number">1</span>) | <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=head[x],y;i;i=Next[i])</span><br><span class="line">		<span class="keyword">if</span>(!~fa[ y=ver[i] ]) fa[y]=x,depth[y]=depth[x]+<span class="number">1</span>,<span class="built_in">dfs</span>(y),Size[x]+=Size[y];</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(depth[x]&lt;depth[y]) L=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	rei incr; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>,u,v;i&lt;m;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v),<span class="built_in">add</span>(u,v);</span><br><span class="line">	<span class="built_in">memset</span>(fa,<span class="number">-1</span>,<span class="keyword">sizeof</span> fa),fa[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(m==n<span class="number">-1</span>)&#123;<span class="comment">//树</span></span><br><span class="line">		<span class="keyword">if</span>(Size[<span class="number">1</span>]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>),<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) ans+=<span class="built_in">abs</span>(Size[i]);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans),<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	rei	u=ver[ <span class="built_in">ad</span>(L) ],v=ver[L];</span><br><span class="line">	<span class="keyword">if</span>( (depth[u]^depth[v]) &amp;<span class="number">1</span>)&#123;<span class="comment">//偶环</span></span><br><span class="line">		<span class="keyword">if</span>(Size[<span class="number">1</span>]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>),<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(rei i=v;i!=u;i=fa[i]) buf[cnt++]=Size[i];</span><br><span class="line">		++cnt;</span><br><span class="line">		<span class="built_in">nth_element</span>(buf,buf+cnt/<span class="number">2</span>,buf+cnt);</span><br><span class="line">		<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;cnt;++i) ans+=<span class="built_in">abs</span>(buf[i]-buf[cnt/<span class="number">2</span>])-<span class="built_in">abs</span>(buf[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;<span class="comment">//奇环</span></span><br><span class="line">		<span class="keyword">if</span>(Size[<span class="number">1</span>]&amp;<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>),<span class="number">0</span>;</span><br><span class="line">		incr=-Size[<span class="number">1</span>]/<span class="number">2</span>,ans=<span class="built_in">abs</span>(incr);</span><br><span class="line">		rei i;</span><br><span class="line">		<span class="keyword">for</span>(i=v;i!=u;i=fa[i]) Size[i]+=incr;</span><br><span class="line">		<span class="keyword">for</span>(;i;i=fa[i]) Size[i]+=incr&lt;&lt;<span class="number">1</span>;<span class="comment">//加上源/汇点贡献</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) ans+=<span class="built_in">abs</span>(Size[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>思维</tag>
        <tag>贪心</tag>
        <tag>dp</tag>
        <tag>染色</tag>
      </tags>
  </entry>
  <entry>
    <title>70801202-AGC005</title>
    <url>/2021/08/07/AGC005/</url>
    <content><![CDATA[<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>求数列 $A$ 的合法排列数满足 $\forall i\in(1,n) |p_i-i|\not =k$</p>
</blockquote>
<p>考虑到 $\not =$ 并不容易计算，使用容斥转化为 $=$</p>
<p>设 $\Gamma_c$ 表示包含已知的 $c对=$ 的排列数量(其他位置任意)，而其他位置任意本质上就是全排列，即，对 $\Gamma_c$ 的贡献是 $(N-c)!$ 。 由此，根据广义容斥，最终答案为 $\displaystyle{\sum_{c=0}^N (-1)^c \times \Gamma_c}$</p>
<p>转化问题为<strong>能选出多少对 $(i,a_i)$ 使 $|a_i-i|=K$ 且所有的 $i,a_i$ 分别互不相同</strong> ，设选出 $\gamma_c$ ，则 $\Gamma_c=\gamma_c \times (N-c)!$</p>
<p>则最终答案是</p>
<script type="math/tex; mode=display">\sum_{c=0}^N (-1)^c\times (N-c)! \times \gamma_c</script><p>注意这里<strong>下标与键值的对应关系</strong>，像匹配的定义，且可以将其转化成二分图模型：$G=(V_1,V_2 ; E)$，其中 $V_1={L_1,L_2,…,L_N} \ ,\ V_2={R_1,R_2,…,R_N} \ ,\ E={(L_i,R_j)\mid \ |i-j|=k}$ ，求 $E$ 有多少个 $K$ 的匹配</p>
<p>再考虑图 $G$ 的性质：</p>
<ul>
<li>每个顶点度数不超过 $2$ ——因为 $L_i$ 至多与 $R_{i-k},R_{i+k}$ 相连，对 $R_i$ 同理</li>
<li>$G$ 为若干个链的并——证明没有圈：若有圈，则设最小者 $\min$ , 顶点式 $L_{\min}$ ，与之相连的节点 $L_{\min-k}$ 则不能在圈中，则度数不超过 $1$ ,与性质 $1$ 矛盾</li>
</ul>
<p>所以求一个全由链组成的图 $G$ ，其大小为 $k$ 的匹配个数</p>
<p>考虑将这些链首尾相连，而连边则为<strong>强制不能加入匹配</strong>的坏边</p>
<p>问题转化到了链，$f_{i,j}$ 表示前 $i$ 条边，当前匹配大小为 $j$ ，且最后一条边没有匹配的方案数； $g_{i,j}$ 表示最后一条边匹配的方案数，转移时注意坏边以及相邻的边不能同时出现在匹配中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">4e3</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">924844033</span>;</span><br><span class="line"><span class="keyword">int</span> n,k,len;</span><br><span class="line"><span class="keyword">int</span> sp[N],fac[N],f[N][N],g[N][N];</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">const</span> <span class="keyword">int</span> y)</span></span>&#123; x+=y-mod; x+=x&gt;&gt;<span class="number">31</span>&amp;mod;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k); fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) fac[i]=(ll) fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;k;++i)&#123;</span><br><span class="line">        sp[++len]=<span class="number">1</span>,len+=(n-i<span class="number">-1</span>)/k;</span><br><span class="line">        sp[++len]=<span class="number">1</span>,len+=(n-i<span class="number">-1</span>)/k;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=len;++i)&#123;</span><br><span class="line">        f[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=(i+<span class="number">1</span>)/<span class="number">2</span>;++j)&#123;</span><br><span class="line">            <span class="built_in">add</span>(f[i][j]=f[i<span class="number">-1</span>][j],g[i<span class="number">-1</span>][j]);</span><br><span class="line">            g[i][j]=sp[i] ? <span class="number">0</span> : f[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei c=<span class="number">0</span>;c&lt;=n;++c)&#123;</span><br><span class="line">        rei tmp=(ll) (f[len][c]+g[len][c])%mod*fac[n-c]%mod;</span><br><span class="line">        c&amp;<span class="number">1</span> ? ans-=tmp : ans+=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    ans%=mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans+(ans&gt;&gt;<span class="number">63</span>&amp;mod));</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>给定红蓝两棵树和起点，两人分别在两棵树上交替移动，相遇后（所在节点编号相同）游戏结束，现在 $A（红）$ 想最大化游戏轮数，$B（蓝）$ 想最小化游戏轮数，求游戏轮数</p>
</blockquote>
<p><del>对抗搜索！（雾</del></p>
<p>首先考虑无解情况，即后手永远抓不到先手</p>
<p>如果存在一条红边 $(u,v)$ 且满足 $u,v$ 两点在蓝树上的距离 $\geq 3$ ，且先手能跑到 $u,v$ 点中任意一个 且 该回合内没有被抓到，则无解</p>
<p>先假设有解情况，即，先手可以走的红边的两端点在蓝树上距离 $\leq 2$ ，那么对于点 $u$ ，其与根的距离分别为 $len_红,len_蓝$ ，若 $len_红\leq len_蓝$ 那么红方一定不会走到 $u$ ， 即红方每一次移动都要保证 $len_红&gt;len_蓝$</p>
<p>$\therefore$ $\text{dfs}$ 一次找无解与满足 $len_红&gt;len_蓝$ 的点，答案就是 $2\times \max len_红$ ，即最优决策是走到 $\max len_红$ 并原地等待</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="keyword">int</span> next=<span class="number">0</span>,<span class="keyword">int</span> to=<span class="number">0</span>):<span class="built_in">next</span>(next),<span class="built_in">to</span>(to)&#123;&#125;;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> ha[N],hb[N],tot;</span><br><span class="line"><span class="keyword">int</span> fa[N],hson[N],Size[N],top[N],depth[N];</span><br><span class="line"><span class="keyword">int</span> ans,cir,n,a,b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _add(<span class="keyword">int</span> *head,<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123; edge[++tot]=<span class="built_in">Edge</span>(head[x],y);head[x]=tot;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> *head,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123; _add(head,x,y); _add(head,y,x);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    Size[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=hb[x];i;i=edge[i].next)&#123;</span><br><span class="line">        rei y=edge[i].to; <span class="keyword">if</span>(y==fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">        depth[y]=depth[x]+<span class="number">1</span>,fa[y]=x; <span class="built_in">dfs1</span>(y),</span><br><span class="line">        Size[x]+=Size[y],hson[x]=Size[ hson[x] ]&gt;Size[y] ? hson[x] : y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(depth[ top[x] ]&lt;depth[ top[y] ]) x^=y,y^=x,x^=y;</span><br><span class="line">        x=fa[ top[x] ];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth[x]&lt;depth[y] ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">return</span> depth[x]+depth[y]<span class="number">-2</span>*depth[ <span class="built_in">lca</span>(x,y) ];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> anc)</span></span>&#123;</span><br><span class="line">    top[x]=anc;</span><br><span class="line">    <span class="keyword">if</span>(hson[x]) <span class="built_in">dfs2</span>(hson[x],anc);</span><br><span class="line">    <span class="keyword">for</span>(rei i=hb[x];i;i=edge[i].next)&#123;</span><br><span class="line">        rei y=edge[i].to; <span class="keyword">if</span>(y!=fa[x] &amp;&amp; y!=hson[x]) <span class="built_in">dfs2</span>(y,y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">escape</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa,<span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line">    ans=<span class="built_in">max</span>(ans,depth[x]&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(rei i=ha[x];i;i=edge[i].next)&#123;</span><br><span class="line">        rei y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dis</span>(x,y)&gt;<span class="number">2</span>) cir=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(y==fa || dep+<span class="number">1</span>&gt;=depth[y]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">escape</span>(y,x,dep+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;a,&amp;b);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,x,y;i&lt;n;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y),<span class="built_in">add</span>(ha,x,y);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,x,y;i&lt;n;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y),<span class="built_in">add</span>(hb,x,y);</span><br><span class="line">    <span class="built_in">dfs1</span>(b);<span class="built_in">dfs2</span>(b,b);</span><br><span class="line">    <span class="built_in">escape</span>(a,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cir ? <span class="number">-1</span> : ans);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>对于一颗树 $T=(V,E)$ ，对于非空子集 $S\subseteq V$ ， 定义 $f(S)$ 表示包含 $S$ 中所有点的连通块大小的最小值，即，$f(S)=min{|U| \ \mid s\subseteq U\subseteq V,T |U|是连通图}$ ，对 $K:1\rightarrow n$ 分别求出 $\sum_{S\subseteq V,|S|=K} f(S)$ 的值</p>
</blockquote>
<p>考虑每个点 $x$ 对答案的贡献，即总方案数减去不合法方案数</p>
<script type="math/tex; mode=display">\begin{aligned}
f_i&=\sum_{x=1}^n\left(\binom{n}{i}-\sum_{\exists e(x,y)}\binom{size_y}{i} \right) \\
&=n\times \binom{n}{i} - \sum_{x=1}^m\times \sum_{\exists e(x,y)} \binom{size_y}{i} \\
\end{aligned}</script><p>设 $cnt_i$ 为子树大小为 $i$ 的子树个数</p>
<script type="math/tex; mode=display">
\begin{aligned}
f_i&=n\times \binom{n}{i}-\sum_{j=i}^n cnt_j\times \binom{j}{i} \\
&=n\times \binom{n}{i}-\sum_{j=i}^n cnt_j\times \frac{j!}{i!\times (j-i)!} \\
&=n\times \binom{n}{i}-\frac{1}{i!}\sum_{j=i}^n\frac{cnt_j\times j!}{(j-i)!} \\
&=n\times \binom{n}{i}-\frac{1}{i!} \sum_{j=0}^{n-i}\frac{cnt_{i+j}\times (i+j)!}{j!} \\
\end{aligned}</script><p>发现第二项是减法卷积，考虑 $NTT$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">8e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">924844033</span>,G=<span class="number">5</span>;</span><br><span class="line">ll n;</span><br><span class="line">ll rev[N],f[N],g[N],fac[N],ifac[N],Size[N],cnt[N];</span><br><span class="line"><span class="keyword">int</span> head[N],tot,Next[N&lt;&lt;<span class="number">1</span>],ver[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123; ver[++tot]=v,Next[tot]=head[u],head[u]=tot;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">qpow</span><span class="params">(ll x,ll y)</span></span>&#123; ll v=<span class="number">1</span>; <span class="keyword">while</span>(y)&#123; <span class="keyword">if</span>(y&amp;<span class="number">1</span>) v=v*x%mod; x=x*x%mod,y&gt;&gt;=<span class="number">1</span>;&#125; <span class="keyword">return</span> v;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    rei lim=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(lim&lt;=n) lim&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;lim;++i) rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>) | ((i&amp;<span class="number">1</span>) ? lim&gt;&gt;<span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> lim;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(ll *a,<span class="keyword">int</span> lim,<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;lim;++i) <span class="keyword">if</span>(i&lt;rev[i]) <span class="built_in">swap</span>(a[i],a[ rev[i] ]);</span><br><span class="line">    <span class="keyword">for</span>(rei len=<span class="number">1</span>;len&lt;lim;len&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        ll wn=<span class="built_in">qpow</span>(G,(mod<span class="number">-1</span>)/(len&lt;&lt;<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;lim;i+=len&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line">            ll w=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(rei j=i;j&lt;i+len;++j,w=w*wn%mod)&#123;</span><br><span class="line">                ll x=a[j],y=w*a[j+len]%mod;</span><br><span class="line">                a[j]=(x+y)%mod,a[j+len]=(x-y+mod)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(type==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    ll inv=<span class="built_in">qpow</span>(lim,mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;lim;++i) a[i]=a[i]*inv%mod;</span><br><span class="line">    <span class="built_in">reverse</span>(a+<span class="number">1</span>,a+lim);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">mul</span><span class="params">(ll *f,ll *g)</span></span>&#123;</span><br><span class="line">    rei lim=<span class="built_in">calc</span>(n&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">NTT</span>(f,lim,<span class="number">1</span>),<span class="built_in">NTT</span>(g,lim,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;lim;++i) f[i]=f[i]*g[i]%mod;</span><br><span class="line">    <span class="built_in">NTT</span>(f,lim,<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    Size[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=head[x];i;i=Next[i])&#123;</span><br><span class="line">        rei y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x),Size[x]+=Size[y];</span><br><span class="line">    &#125;</span><br><span class="line">    ++cnt[ Size[x] ],++cnt[ n-Size[x] ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">get_C</span><span class="params">(ll n,ll m)</span></span>&#123; <span class="keyword">return</span> fac[n]*ifac[m]%mod *ifac[n-m]%mod;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=ifac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    ifac[n]=<span class="built_in">qpow</span>(fac[n],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(rei i=n<span class="number">-1</span>;i;--i) ifac[i]=ifac[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,x,y;i&lt;n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y),<span class="built_in">add</span>(x,y),<span class="built_in">add</span>(y,x);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    g[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) f[i]=cnt[n-i]*fac[n-i]%mod,g[i]=ifac[i];</span><br><span class="line">    <span class="built_in">mul</span>(f,g),<span class="built_in">reverse</span>(f,f+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(n*<span class="built_in">get_C</span>(n,i)%mod-ifac[i]*f[i]%mod+mod)%mod);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>思维</tag>
        <tag>dp</tag>
        <tag>博弈论</tag>
        <tag>多项式</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>01801202-AGC007</title>
    <url>/2021/08/10/AGC007/</url>
    <content><![CDATA[<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><blockquote>
<p>一条直线上有 $N$ 个球， $N+1$ 个洞，每个球与相邻的洞距离 $d_i \ (1\leq i\leq N\times 2)$ 。随机选择一个球并向随机方向推，若洞中有球则继续滚，无球掉入。求每个球移动距离的期望</p>
</blockquote>
<p>这个阴间题有一下结论：第一个球滚入洞中后，新的距离序列的期望值仍是一个等差数列</p>
<ul>
<li><p>题解的证明：</p>
<p>共 $2\times n$ 中可能，对于第 $i$ 段，考虑能对其期望长度做出贡献的行为</p>
<ul>
<li>原第 $i$ 段距离被滚过，重新编号后原第 $i+2$ 段成为现第 $i$ 段</li>
<li>原第 $i+1$ 段被滚过，原第 $i,i+2,i+3$ 段成为第 $i$ 段</li>
</ul>
<script type="math/tex; mode=display">\therefore d_i'=d_i+\frac{i\times (d_{i+2}-d_i)+(d_{i+2}+d_{i+3})}{2\times n}=d_i+\frac{i\times 2x+2\times d+5\times x}{2\times n}</script></li>
<li><p>口胡找规律的证明</p>
<p><img src="https://pic.imgdb.cn/item/6171fecf2ab3f51d91664313.png" alt="https://pic.imgdb.cn/item/6171fecf2ab3f51d91664313.png"></p>
<p>$4$ 个距离的期望分别是 $\frac{8\times d+5\times x}{6} \quad \frac{8\times d+15\times x}{6} \quad \frac{8\times d+25\times x}{6} \quad \frac{8\times d+35\times x}{6}$</p>
<p>然后手推一推找规律得：$d’_1=d+\frac{2\times d+5\times x}{2\times n},x’=x+\frac{4\times x}{2\times n}$</p>
<p>最后对于期望距离是 $d+\frac{2\times n-1}{2\times x}$ ，即，数列的中位数</p>
</li>
</ul>
<p>$\therefore O(n)$ 递推数列即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> d,k,ans,n2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%lf%lf&quot;</span>,&amp;n,&amp;d,&amp;k);</span><br><span class="line">    n2=n&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=n;i;--i)&#123;</span><br><span class="line">        ans+=d+k*(n2<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">        d+=(<span class="number">2</span>*d+<span class="number">5</span>*k)/n2;</span><br><span class="line">        k+=<span class="number">4</span>*k/n2;</span><br><span class="line">        n2-=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.10lf\n&quot;</span>,ans);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>数列上有 $n$ 只位于 $x_i$ 熊，到达该熊位置后 $T$ 秒会在该熊的位置生成一个金币，从 $0$ 开始走，每走以一单位长度需要 $1$ 秒，求收集所有金币并到出口的最短时间</p>
</blockquote>
<p><del>经典C比D难</del></p>
<p>显然有 $dp$ 式子：</p>
<script type="math/tex; mode=display">f_i=\min_{j\leq i}\{f_{j}+a_i-a_j+\underbrace{\max\{2\times (a_i-a_{j+1}),T\}}_{返回又回到i后，若时间不够需要在原地等} \}</script><p>考虑优化这个 $O(n^2)$ 的式子</p>
<p>首先注意 $\sum a_i-a_j=lenth$ ，所以提出这个式子并在结果中加上数列总长</p>
<p>其次处理 $\max$ :对于 $(a_i-a_{j+1})$ 的大小分类讨论，其大小随 $a_i$ 单增，维护队列，当 $(a_i-a_{j+1})\leq \frac{T}{2}$ 留在队列中，队首转移时所有弹出的 $j$ 满足 $(a_i-a_{j+1})&gt;T$ ，记录最小值即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line">ll n,T,x[N],f[N],ans,k=<span class="number">1e18</span>;</span><br><span class="line">ll head=<span class="number">1</span>,tail=<span class="number">1</span>,sta[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld%d&quot;</span>,&amp;n,&amp;ans,&amp;T);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x[i]);</span><br><span class="line">	f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;=tail &amp;&amp; (x[i]-x[ sta[head] ]+<span class="number">1</span>)&gt;(T&gt;&gt;<span class="number">1</span>))&#123;</span><br><span class="line">            k=<span class="built_in">min</span>(k,f[ sta[head] ]<span class="number">-2</span>*x[ sta[head]+<span class="number">1</span> ]);</span><br><span class="line">            ++head;</span><br><span class="line">        &#125;</span><br><span class="line">        f[i]=<span class="built_in">min</span>(f[i],<span class="built_in">min</span>(f[ sta[head] ]+T,k+<span class="number">2</span>*x[i]));</span><br><span class="line">        sta[++tail]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    ans+=f[n];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line">ll n,T,x[N],f[N],ans,k=<span class="number">1e18</span>;</span><br><span class="line">ll head=<span class="number">1</span>,tail=<span class="number">1</span>,sta[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld%d&quot;</span>,&amp;n,&amp;ans,&amp;T);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x[i]);</span><br><span class="line">	f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;=tail &amp;&amp; (x[i]-x[ sta[head] ]+<span class="number">1</span>)&gt;(T&gt;&gt;<span class="number">1</span>))&#123;</span><br><span class="line">            k=<span class="built_in">min</span>(k,f[ sta[head] ]<span class="number">-2</span>*x[ sta[head]+<span class="number">1</span> ]);</span><br><span class="line">            ++head;</span><br><span class="line">        &#125;</span><br><span class="line">        f[i]=<span class="built_in">min</span>(f[i],<span class="built_in">min</span>(f[ sta[head] ]+T,k+<span class="number">2</span>*x[i]));</span><br><span class="line">        sta[++tail]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    ans+=f[n];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>给定一个严格二叉树，每条边有边权，找到一条 $\text{Euler}$ 环游路径(从根出发并回到根，期间每条边的两个方向恰被经过一次)，设该路径经过的叶节点按顺序依次为 $l_1,l_2,….$ ,最小化 $\max\{dis(l_1,l_2),dis(l_2,l_3),…,dis(l_{n-1},l_n)\}$</p>
</blockquote>
<p><strong>最小化最大值，自然想到二分答案，转化为判定性问题</strong></p>
<p>二分答案为 $mid$ ，设二元组 $(a,b)_x$ 表示 $x$ 子树下第一次走的代价为 $a$ ,在最后一次走的代价为 $b$ ，中间过程都 $\leq mid$</p>
<p>可以得到暴力做法：枚举当前点左右儿子的二元组 $(a,b)_{ls},(c,d)_{rs}$ ，左儿子边权为 $x$ ，右儿子边权 $y$ ，若满足 $b+c+x+y\leq mid$ ，则能得到一个新二元组 $(a+x,d+y)_x$</p>
<p>考虑优化：</p>
<p>对于两个有序对 $(a,b),(c,d)$ 若 $a\leq d 或 b\leq c$ ，即前者偏序与后者，显然前者优于后者</p>
<p>那么只保留优等情况后， $a,b$ 是反向单调的，即， $a<c \Leftrightarrow b>d$</p>
<p>对于 $(a,b) 和 (c,d)$ 的合并，假设固定 $b$ ，那么需要找 $c$ 满足 $d\leq v-b$</p>
<p>显然希望剩下的 $d$ 尽可能小，有反向单调性可知，需要找尽可能大的 $c$</p>
<p>可以按照单增的顺序枚举 $b$ ，所需的 $c$ 的上界则单减，双指针扫即可</p>
<p>再考虑顶点 $i$ 的所有状态，注意到两子节点可交换，即要同时插入 $(l,r) , (r,l)$</p>
<p>这里并不需要再次排序，由枚举的单调性可知内部有序，只需进行一次有序表合并</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">14e4</span>+<span class="number">100</span>,M=<span class="number">5e5</span>;</span><br><span class="line"><span class="keyword">int</span> n,fa[N],lc[N],rc[N];</span><br><span class="line">ll depth[N];</span><br><span class="line">PLL g[M],h[M],tmp[M];</span><br><span class="line">vector &lt;PLL&gt; f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123; (lc[fa] ? rc[fa] : lc[fa])=x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">valid</span><span class="params">(ll v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(rei x=n;x;--x)&#123;</span><br><span class="line">        f[x].<span class="built_in">clear</span>(); rei l=lc[x],r=rc[x];</span><br><span class="line">        <span class="keyword">if</span>(!(l || r))&#123; f[x].<span class="built_in">emplace_back</span>(depth[x],depth[x]); <span class="keyword">continue</span>;&#125;</span><br><span class="line">        rei L=f[l].<span class="built_in">size</span>(),R=f[r].<span class="built_in">size</span>(),cg,ch,i,j;</span><br><span class="line">        ll lim=v+<span class="number">2</span>*depth[x];</span><br><span class="line">        <span class="keyword">for</span>(cg=ch=j=i=<span class="number">0</span>;i&lt;L;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(;j&lt;R &amp;&amp; f[l][i].first+f[r][j].second&gt;lim;++j);</span><br><span class="line">            <span class="keyword">if</span>(j==R) <span class="keyword">break</span>;</span><br><span class="line">            g[cg++]=<span class="built_in">mk</span>(f[l][i].second,f[r][j].first);</span><br><span class="line">            h[ch++]=<span class="built_in">mk</span>(f[r][j].first,f[l][i].second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(g,g+cg),j=<span class="built_in">merge</span>(g,g+cg,h,h+ch,tmp)-tmp;</span><br><span class="line">        <span class="keyword">if</span>(!j) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(f[x].<span class="built_in">emplace_back</span>(*tmp),i=<span class="number">1</span>;i&lt;j;++i)</span><br><span class="line">            <span class="keyword">if</span>(tmp[i].second&lt;f[x].<span class="built_in">back</span>().second) f[x].<span class="built_in">emplace_back</span>(tmp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll l=<span class="number">0</span>,r=<span class="number">0</span>,mid;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>,&amp;fa[i],&amp;depth[i]),<span class="built_in">link</span>(i,fa[i]),r+=depth[i],depth[i]+=depth[ fa[i] ];</span><br><span class="line">    <span class="keyword">for</span>(;l&lt;r;<span class="built_in">valid</span>(mid=(l+r)/<span class="number">2</span>) ? r=mid : l=mid+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,l);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>给定初始串 $S_0$ 与目标串 $T$ ，第 $i$ 步将 $S_i$ 变为 $S_{i+1}$ ，其中：</p>
<script type="math/tex; mode=display">S_{i+1}[j]=\begin{cases}S_i[1] &j=1 \\S_i[j] 或 S_{i+1}[j-1] &j>1 \\\end{cases}</script><p>求最少几次操作可以变为目标串</p>
</blockquote>
<p>考虑到 $T$ 中的每个字符来源于 $S_0$ ，有对应关系的边不会相交，且一个字符对应一个区间</p>
<p>可以采取的最优策略是：先尽量右移，移动到需要覆盖的左边界处后向下到底线，再横向覆盖，让路径尽量靠右</p>
<p>再考虑最优补数：从后往前考虑每个 $T$ 中须要匹配的左端点，让路径尽量靠右，若当前层数无法完成，则加一层</p>
<p>具体地，用队列维护上一条路径所有右侧转折点，其横纵坐标单增</p>
<p>当 $S_i\rightarrow T_j$ ，末端弹出所有横坐标在 $j$ 后面的所有转折点</p>
<p>答案是所有转折点纵坐标的最大值 $+1$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">char</span> s[N],t[N];</span><br><span class="line"><span class="keyword">int</span> n,pre[N],p[<span class="number">255</span>],ans,ql,qr;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span>&#123;</span><span class="keyword">int</span> i,j;&#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s%s&quot;</span>,&amp;n,s+<span class="number">1</span>,t+<span class="number">1</span>); <span class="keyword">bool</span> flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>(s[i]!=t[i]) flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>),<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) pre[i]=p[ s[i] ],p[ s[i] ]=i;</span><br><span class="line">    rei ql=<span class="number">1</span>,qr=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=n,las=n+<span class="number">1</span>,c=<span class="number">0</span>;i;--i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[i]==t[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span>(p[ t[i] ]&gt;<span class="built_in">min</span>(las,i)) p[ t[i] ]=pre[ p[ t[i] ] ];</span><br><span class="line">        <span class="keyword">if</span>(!p[ t[i] ]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>),<span class="number">0</span>;</span><br><span class="line">        rei u=p[ t[i] ],v=i;</span><br><span class="line">        <span class="keyword">while</span>(ql&lt;=qr &amp;&amp; v&lt;q[ql].i-c+<span class="number">1</span>) ++ql;</span><br><span class="line">        <span class="keyword">if</span>(las!=u &amp;&amp; u&lt;v) q[++qr]=((Data)&#123;u+c,<span class="number">1</span>-c&#125;);</span><br><span class="line">        <span class="keyword">if</span>(ql&lt;=qr) ans=<span class="built_in">max</span>(ans,q[ql].j+c);</span><br><span class="line">        ++c;las=u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>思维</tag>
        <tag>贪心</tag>
        <tag>dp</tag>
        <tag>数列</tag>
      </tags>
  </entry>
  <entry>
    <title>21801202-AGC009</title>
    <url>/2021/08/12/AGC009/</url>
    <content><![CDATA[<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>给定一棵树 $T$ ，递归定义一棵树是否为 $k$ -可点分的：$1$ : 包含一个顶点的树是 $0$ -可点分，$2$ :若存在顶点 $v\in T$ ，满足将 $v$ 删去后所有子树均为 $k$ -可点分的，则 $T$ 为 $(k+1)$ -可点分，求最小的 $k$ 使 $T$ 是 $k$ -可点分的</p>
</blockquote>
<p>设每个点在点分治树种深度 $k_i$ ，对于任意两个深度相同的点路径上深度最大的点一定大于 $k_i$</p>
<p>由此得到性质：</p>
<ul>
<li>对于点 $u$ ，如果在其两个不同子树种同时存在 $k$ ，且到 $u$ 的路径上没有超过 $k$ 的点，则其标号一定大于 $k$</li>
<li>如果某个子树种存在一个值 $k$ 且从它到 $x$ 的路径上都没有超过 $k$ 的点，则 $x$ 标号不能为 $k$</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,u,v,ans;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; a[N];</span><br><span class="line"><span class="keyword">int</span> bit[N],f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	rei l=<span class="number">0</span>,Size=a[x].<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;Size;++i)&#123;</span><br><span class="line">		rei u=a[x][i]; <span class="keyword">if</span>(u==fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(u,x);</span><br><span class="line">		l|=(bit[x] &amp; bit[u]);</span><br><span class="line">		bit[x]|=bit[u];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!bit[x]) bit[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;f[x])&lt;l || (<span class="number">1</span>&lt;&lt;f[x])&amp;bit[x]) ++f[x];</span><br><span class="line">		bit[x]=(bit[x]/(<span class="number">1</span>&lt;&lt;f[x]) * (<span class="number">1</span>&lt;&lt;f[x])) | (<span class="number">1</span>&lt;&lt;f[x]);</span><br><span class="line">	&#125;</span><br><span class="line">	ans=<span class="built_in">max</span>(ans,f[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>,u,v;i&lt;n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v),a[u].<span class="built_in">push_back</span>(v),a[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>有 $n$ 个 $0$ 和 $m$ 个 $1$ ，给定 $K\geq 2$ 且 $n+m\equiv \pmod {K+1}$ ，不断选取 $K$ 个数并替换为他们的平均数，求最终得到的数有多少可能的取值</p>
</blockquote>
<p>考虑建出严格 $k$ 叉树，所有 $0$ 的深度为 $a_1,a_2,…,a_N$ ，所有 $1$ 的深度为 $b_0,b_1,…,b_m$ ,则最终所得到的数就等于 $B=\sum_{i=1}^m k^{-b_i}$</p>
<p>设 $A=\sum_{i=1}^n k^{-a_i}$ ，即，将 $0,1$ 翻过来，有 $A+B=1$</p>
<p>将 $B$ 以 $k$ 进制呈现，进位过程中，$\sum$ 数码 $\mod {k-1}$ 的值是不变量，一个必要条件就是 $\sum数码 \equiv \pmod {k-1}$ ，且有 $\sum 数码 \leq m$</p>
<p>则问题转化为求多少个数对 $(A,B)$ 满足 $A+B=1$ ，且 $S_k(A)\equiv N\pmod {k-1} 或 S_k(B)\equiv m\pmod{k-1}或S_k(B)\leq m$ ，其中 $S_k(x)$ 表示 $x$ 在 $k$ 进制下数码和</p>
<p>显然 $S_k(A)\equiv N\pmod {k-1}\Leftrightarrow S_k(B)\equiv m\pmod{k-1}$ ，保证其一即可</p>
<p>由于 $A+B=1$ ，可得 $S_k(A)+S_k(B)=(i-1)\times (k-1)+k=i\times (k-1)+1$ ，即， $S_k(B)\leq m \Leftrightarrow S_k(A)\geq i\times (k-1)+1-m$</p>
<p>至此，所有条件仅与 $S_k(A)$ 有关</p>
<p>做一个简单的数位 $\text{dp}$ ，加前缀和转移即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> A,B,k,f[N&lt;&lt;<span class="number">1</span>][N],g[N&lt;&lt;<span class="number">1</span>][N];</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> &amp;<span class="title">reduce</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123; <span class="keyword">return</span> x+=x&gt;&gt;<span class="number">31</span>&amp;mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> &amp;<span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">const</span> <span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">return</span> x+=y-mod,x+=x&gt;&gt;<span class="number">31</span>&amp;mod;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;A,&amp;B,&amp;k);</span><br><span class="line">	<span class="keyword">if</span>(A&gt;B) A^=B,B^=A,A^=B;</span><br><span class="line">	rei limit=(A+B<span class="number">-1</span>)/--k;</span><br><span class="line">	**f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=limit;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;=A;++j) <span class="built_in">add</span>(g[i][j+<span class="number">1</span>]=g[i][j],<span class="built_in">add</span>(f[i][j]=f[i<span class="number">-1</span>][j],g[i<span class="number">-1</span>][j]));</span><br><span class="line">		<span class="keyword">for</span>(rei j=A;j&gt;=k;--j) <span class="built_in">reduce</span>(g[i][j]-=g[i][j-k]);</span><br><span class="line">		<span class="keyword">for</span>(rei l=<span class="built_in">max</span>(A%k,i*k-B+<span class="number">1</span>),r=i*k-l+<span class="number">1</span>; l&lt;=A &amp;&amp; r&gt;=<span class="number">0</span> ;l+=k,r-=k) ans+=g[i][l];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans%mod);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>思维</tag>
        <tag>贪心</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>11801202-AGC008</title>
    <url>/2021/08/11/AGC008/</url>
    <content><![CDATA[<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>给定长度为 $n$ 的序列 $a$ ，求有多少长度为 $n$ 的排列 $p$ 满足 $\forall i : p_i=a_i 或 p_{p_i}=a_i$</p>
</blockquote>
<p>对于排列 $p$ ，将 $i$ 向 $p_i$ 连边，显然每个点入度出度都为 $1$ ，即，形成了若干个环</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/z22bnrwt.png" alt="https://cdn.luogu.com.cn/upload/image_hosting/z22bnrwt.png"></p>
<p>对于其中的一个环：删除所有边并将 $i\rightarrow a_i$ ，由题得 $a_i$ 是其前面的点( $p_i=a_i$ )或前面的前面的点( $p_{p_i}=a_i$ )</p>
<p>分成 $3$ ( $4$ )种：</p>
<ul>
<li>所有 $i$ 的 $a_i$ 都是其前面的点，则环不变</li>
<li><p>所有 $i$ 的 $a_i$ 都是其前面的前面的点</p>
<ul>
<li>环是奇环，则环变成同构的另一环<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/bw5esa22.png" alt="https://cdn.luogu.com.cn/upload/image_hosting/bw5esa22.png"><br>-环是偶环，则环被平均拆成两大小相同的环<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/fd4lyhjw.png" alt="https://cdn.luogu.com.cn/upload/image_hosting/fd4lyhjw.png"></li>
</ul>
</li>
<li><p>有的是前面的点，有的是前面的前面，则构成基环内向树<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/zjpns0w4.png" alt="https://cdn.luogu.com.cn/upload/image_hosting/zjpns0w4.png"></p>
</li>
</ul>
<p>现在有 $a$ 构成的图，反向考虑</p>
<ul>
<li><p>对于环</p>
<p>记录每个大小的环的个数，单独考虑每种大小， $\text{dp}$ 决策第 $k$ 个环合并还是单独组成，最后乘法原理</p>
</li>
<li><p>对基环内向树</p>
<p>考虑两条相邻的链，试图将链塞回环里，该链可以塞到树里的位置就是到下一个链的边，设 $l_2$ 条这样的边， $l_1$ 是该链长度</p>
<script type="math/tex; mode=display">\begin{cases}
l_2<l_1 &ans=0 \\
l_2=l_1 &ans=1 \\
l_2>l_1 &ans=2 \\
\end{cases}</script></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,ans;</span><br><span class="line"><span class="keyword">int</span> a[N],du[N],cir[N],vis[N],chain_len[N],sum[N],f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fix</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123; x&gt;=mod ? x-=mod : <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deal_cirtree</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> now=<span class="number">0</span>,fir_ch=<span class="number">0</span>,la_ch=<span class="number">0</span>,fir_len=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//从x走环到的点，第一个链，上一个链，链长度</span></span><br><span class="line">	<span class="keyword">while</span>(cir[x])&#123;</span><br><span class="line">		++now,cir[x]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(chain_len[x])&#123;</span><br><span class="line">			<span class="keyword">if</span>(!fir_ch) la_ch=fir_ch=now,fir_len=chain_len[x];</span><br><span class="line">			<span class="keyword">else</span>&#123;<span class="comment">//尝试把链塞回环里</span></span><br><span class="line">				<span class="keyword">int</span> kl=(chain_len[x]&lt;now-la_ch)+(chain_len[x]&lt;=now-la_ch);</span><br><span class="line">				ans=(ll) ans*kl%mod,la_ch=now;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		x=a[x];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!fir_ch) ++sum[now];<span class="comment">//简单环</span></span><br><span class="line">	<span class="keyword">else</span>&#123;<span class="comment">//第一个链</span></span><br><span class="line">		<span class="keyword">int</span> kl=(fir_len&lt;now-la_ch+fir_ch)+(fir_len&lt;=now-la_ch+fir_ch);</span><br><span class="line">		ans=(ll) ans*kl%mod;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(du[i]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">int</span> x=i,len=<span class="number">0</span>; <span class="keyword">while</span>(!cir[x]) x=a[x],++len;</span><br><span class="line">		chain_len[x]=len;</span><br><span class="line">	&#125;</span><br><span class="line">	ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>(cir[i]) <span class="built_in">deal_cirtree</span>(i);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;<span class="comment">//对每一种长度的简单环DP</span></span><br><span class="line">		<span class="keyword">if</span>(!sum[i]) <span class="keyword">continue</span>;</span><br><span class="line">		f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=sum[i];++j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i&gt;<span class="number">1</span> &amp;&amp; (i&amp;<span class="number">1</span>)) <span class="built_in">fix</span>(f[j]=f[j<span class="number">-1</span>]+f[j<span class="number">-1</span>]);<span class="comment">//情况1,2</span></span><br><span class="line">			<span class="keyword">else</span> f[j]=f[j<span class="number">-1</span>];<span class="comment">//情况1</span></span><br><span class="line">			<span class="keyword">if</span>(j&gt;<span class="number">1</span>) <span class="built_in">fix</span>(f[j]+=(ll) f[j<span class="number">-2</span>]*(j<span class="number">-1</span>)%mod*i%mod);<span class="comment">//情况3</span></span><br><span class="line">		&#125;</span><br><span class="line">		ans=(ll) ans*f[sum[i]]%mod;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]),++du[ a[i] ];</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">        rei x=i; <span class="keyword">while</span>(!vis[x]) vis[x]=i,x=a[x];</span><br><span class="line">		<span class="keyword">if</span>(vis[x]!=i) <span class="keyword">continue</span>;<span class="comment">//说明i在链上</span></span><br><span class="line">		<span class="keyword">while</span>(!cir[x]) cir[x]=<span class="number">1</span>,x=a[x];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>((cir[i] &amp;&amp; du[i]&gt;<span class="number">2</span>) || (!cir[i] &amp;&amp; du[i]&gt;<span class="number">1</span>)) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>),<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">work</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>给定 $n$ 个点的树，每条边长度为 $1$ 给定 $S$ 表示喜欢的顶点集合，起初所有点为白色，可以做一次操作，其中选择顶v点 $\in S$ 和整数 $d$ 将所有满足 $dis(v,u)\leq d$ 的点 $u$ 染成黑色，求最终能得到多少形态不同的树</p>
</blockquote>
<p>先考虑 $S$ 为全集，即每个点都能以其自身为中心操作，那么最终黑色的点形成一个连通块</p>
<p>注意到不同操作方案可能得出同一种连通块，即，这并不是一一对应的</p>
<p>考虑到操作有一定距离且连通块是树，考虑取直径中点，即，对于每个连通块，看成以其中心为操作中心的操作，同时得到尽可能小的 $d$</p>
<p>当中心是边时，显然一侧为子树，规定以该边靠近叶子的点作为操作中心</p>
<p>而对于整棵树并不计入，仅在最后将答案 $+1$</p>
<p>对于每个顶点 $v$ ，考虑以其为操作中心的操作个数，对于全集 $S$ ，一定有 $d\in [0,sup]$</p>
<p>而对 $d$ 的约束有：</p>
<ul>
<li>$d&lt;f_v$ ，即， $d$ 小于整棵树的深度，以防整棵树被染黑</li>
<li>$d\leq g_v-1$ ，即，$d$ 小于以 $child(v)$ 中点为根的所有子树中第二大深度为 $g_v$ 的 ： 即考虑 $v$ 不是中心的情况，若中心在某子树中，朝根方向走，黑色点的最大深度严格递减，即 $\forall c\in child(v)$ 必须有 $\{u\mid dis(c,u)\leq d-1\}\not =\{u\mid (v,u)\leq d\}$ ，即，至少需要两颗子树存在深度 $\geq d-1$ 的顶点</li>
</ul>
<p>即，$d\leq \min(f_v-1,g_v+1)$ ，对于其余的 $v$ ，换根 $\text{dp}$ 即可</p>
<p>再考虑 $S$ 不是全集，此时 $d$ 要考虑下界</p>
<p>以 $v$ 为操作中心的一些操作可以被 以 $u\in child(v)$ 为中心的操作 $(u,d’)$ 代替，则 $d’\geq d+dis(v,u)&gt;d$</p>
<p>则，子树 $subtree(u)$ 中不能存在深度 $\geq d$ 的顶点，即，操作 $(v,d)$ 至少覆盖了它的一个子节点的子树 $subtree(u)$</p>
<p>这说明 $d$ 至少大于其所有子树中深度最大值的最小值，且保证子树中至少有一个 $S$ 中的点，否则 $v$ 不存在</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[N&lt;&lt;<span class="number">1</span>],Next[N&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line"><span class="keyword">int</span> fa[N],Size[N],f[N],g[N],inf[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line">ll ans=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">const</span> <span class="keyword">int</span> y)</span></span>&#123; x&lt;y ? x=y : <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">const</span> <span class="keyword">int</span> y)</span></span>&#123; x&gt;y ? x=y : <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123; ver[++tot]=v,Next[tot]=head[u],head[u]=tot;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	Size[x]=s[x]&amp;=<span class="number">1</span>;</span><br><span class="line">	inf[x]=(s[x]<span class="number">-1</span>)&amp;INT_MAX;</span><br><span class="line">	<span class="keyword">for</span>(rei i=head[x];i;i=Next[i])&#123;</span><br><span class="line">		rei y=ver[i]; <span class="keyword">if</span>(y==fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">		fa[y]=x; <span class="built_in">dfs1</span>(y); Size[x]+=Size[y];</span><br><span class="line">		f[x]&lt;=f[y] ? (g[x]=f[x],f[x]=f[y]+<span class="number">1</span>) : (<span class="built_in">up</span>(g[x],f[y]+<span class="number">1</span>),<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(Size[y]) <span class="built_in">down</span>(inf[x],f[y]+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fy=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">	rei sup;</span><br><span class="line">	f[x]&lt;=fy ? (g[x]=f[x],f[x]=fy+<span class="number">1</span>) : (<span class="built_in">up</span>(g[x],fy+<span class="number">1</span>),<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(Size[x]&lt;Size[<span class="number">1</span>]) <span class="built_in">down</span>(inf[x],fy+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(inf[x]&lt;=(sup=<span class="built_in">min</span>(f[x]<span class="number">-1</span>,g[x]+<span class="number">1</span>))) ans+=sup-inf[x]+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=head[x];i;i=Next[i])&#123;</span><br><span class="line">		rei y=ver[i]; <span class="keyword">if</span>(fa[y]!=x) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs2</span>(y,f[y]+<span class="number">1</span>==f[x] ? g[x] : f[x]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>,u,v;i&lt;n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v),<span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">dfs1</span>(<span class="number">1</span>),<span class="built_in">dfs2</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>思维</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>61801202-AGC011</title>
    <url>/2021/08/16/AGC011/</url>
    <content><![CDATA[<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>给定一张 $n$ 个点 $m$ 个边的图，现在构成一张 $n^2$ 个点的新图，每个点是一个二元组 $(a,b)$ ,其中，新图中点 $(a,b) , (c,d)$ 有边当且仅当 原图中 $a,c ; b,d$ 有边，求新图中连通块个数</p>
<p>观察新图中两点间有边的条件：<strong>在原图中的两个点 $i,j$ 分别向其相邻的点走一步，到达点 $u,v$ ，那么新图中连边 $(i,j)\rightarrow (u,v)$</strong></p>
<p>考虑单一连通块内部：对于任意点对 $(u,v)$ 可将两点均向中间缩，最后有两种情况：</p>
<ul>
<li>$u,v$ 重合：路径长偶数</li>
<li>$u,v$ 位于边两端：路径长奇数</li>
</ul>
<p>那么，原图的连通块在新图中会形成一个或两个连通块</p>
<p>可以得出神奇的结论：</p>
<ul>
<li>对于一个原图中的独立点 $u$ ，新图的 $(u,v)$ 与 $(v,x)$ 均为独立的点 $( v\in n )$ 。故设原图中独立点数量为 $single$ ，那么独立点对答案的贡献就是 $single\times n+(n-single)\times single$</li>
<li>对于原图中的无奇环联通块，可以与任一联通块组成新图的两个不同联通块。设这种联通块有 $c$ 个，其两两组合对答案的贡献为 $c\times c\times 2$</li>
<li>对于原图中的有奇环联通块，可以与任一联通块组成新图的一个联通块（若与它组合的是无奇环联通块，则两个）。设这种联通块有 $d$ 个，则它对答案的贡献就是 $d*\times (d+c\times 2)$</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[N&lt;&lt;<span class="number">1</span>],Next[N&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line"><span class="keyword">int</span> fa[N],Size[N],n,m,cnt[<span class="number">2</span>];</span><br><span class="line">PII circle[N]; <span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">bool</span> parity[N],odd[N];</span><br><span class="line"><span class="keyword">int</span> single; ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123; ver[++tot]=v,Next[tot]=head[u],head[u]=tot;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> fa[x]==x ? x : fa[x]=<span class="built_in">find</span>(fa[x]);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fath)</span></span>&#123;</span><br><span class="line">    parity[x]=parity[fath]^<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=head[x];i;i=Next[i])&#123;</span><br><span class="line">        rei y=ver[i]; <span class="keyword">if</span>(y==fath) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) fa[i]=i,Size[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,u,v;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(u)!=<span class="built_in">find</span>(v))&#123; <span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u); u=<span class="built_in">find</span>(u),v=<span class="built_in">find</span>(v); fa[u]=v,Size[v]+=Size[u];&#125;</span><br><span class="line">        <span class="keyword">else</span> circle[++num]=<span class="built_in">mk</span>(u,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>(fa[i]==i) <span class="built_in">dfs</span>(i,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=num;++i) <span class="keyword">if</span>(parity[ circle[i].first ]==parity[ circle[i].second ]) odd[ <span class="built_in">find</span>(circle[i].first) ]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[i]!=i) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(Size[i]==<span class="number">1</span>) ++single,ans+=n;</span><br><span class="line">        <span class="keyword">else</span> ++cnt[ odd[i] ];</span><br><span class="line">    &#125;</span><br><span class="line">    ans+=(ll) (n-single)*single + (ll) <span class="number">2</span>*cnt[<span class="number">0</span>]*cnt[<span class="number">0</span>] + (ll) cnt[<span class="number">1</span>]*(cnt[<span class="number">1</span>]+<span class="number">2</span>*cnt[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>有 $n$ 个机器排成一排，每个装置有 $A,B$ 两种状态，一小球从左侧进入该系统。其中 $A$ 使球反弹回原方向，$B$ 无作用，球经过一个装之后装置状态将改变，给定初始状态，求 $k$ 个小球经过后装置最终状态</p>
</blockquote>
<p>先看小一点的情况：</p>
<ul>
<li>第一个是 $A$ ：球弹回去，第一个变成 $B$</li>
<li>第一个是 $B$ ：球继续，如果后面还有 $A$ 则会撞上之前经过的 $B$ 变成的 $A$ 而弹回去</li>
</ul>
<p>可以发现对于一次滚球：删去序列第一个，序列整体取反，末尾加上一个 $A$ 可以完成</p>
<p>再考虑 $k$ ，由于<strong>删除-取反-添加</strong>的操作，整个字符串逐渐从后向前变成 $ABAB…或BABA…$ 的形态</p>
<p>而在 $k&gt;n$ 时，对于 $ABAB…$ 奇数次会变为 $BABA…$ ，偶数次不变，对于 $BABA…$ 形态不会改变</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">4e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,k,num[N],st;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) num[i]=s[i]-<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    st=num[<span class="number">1</span>];</span><br><span class="line">    rei pos=<span class="number">1</span>,cnt=<span class="number">0</span>;<span class="comment">//p表示删到哪里了，cnt是操作次数</span></span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!st) st^=<span class="number">1</span>,num[pos]^=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> ++pos,++cnt,st=num[pos],st^=(cnt&amp;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(pos&gt;n) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(rei i=pos;i&lt;=n;++i) <span class="built_in">putchar</span>(<span class="string">&#x27;A&#x27;</span>+(num[i]^(cnt&amp;<span class="number">1</span>)));</span><br><span class="line">        rei t=pos<span class="number">-1</span>,c=(cnt<span class="number">-1</span>)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(t--) <span class="built_in">putchar</span>(<span class="string">&#x27;A&#x27;</span>+c),c^=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((cnt<span class="number">-1</span>)&amp;<span class="number">1</span>) <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">putchar</span>(<span class="string">&#x27;A&#x27;</span>+(i&amp;<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="built_in">putchar</span>(<span class="string">&#x27;A&#x27;</span>+(k&amp;<span class="number">1</span>)); <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;n;++i) <span class="built_in">putchar</span>(<span class="string">&#x27;A&#x27;</span>+(i&amp;<span class="number">1</span>)); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>定义一个数是“递增的”，当且仅当对于它的任意相邻的两位都有左边小于等于右边。给定一个数 $n\leq 10^{500000}$ 求其最少可以被表示为一个递增的数之和</p>
</blockquote>
<p>考虑找到一个数时递增的充要条件</p>
<p>定义一个数纯一数，如果其所有数码都为 $1$ ， 显然其可被写成 $\frac{1}{9}(10^n-1)$ 的形式。那么一个数时递增的当且仅当它是不超过 $9$ 个纯一数的和，由于 $0$ 也可以被写成该形式，定义纯一数都表示为 $9$ 个形如 $\frac{1}{9}(10^n-1)$ 的数的和</p>
<p>于是 $x=\frac{1}{9}(10^{n_1}-1) + …+\frac{1}{9}(10^{n_9}-1)\ \Leftrightarrow \ 9x+9=10^{n_1}+…+10^{n_9}$</p>
<p>$\therefore$ $9x+9$ 的数码和一定为 $9$</p>
<p>现在需要判断 $n$ 是多少递增数的和，需要算出 $9n$ ，然后加上 $9k$ 其中 $k$ 是答案</p>
<p>假设 $n$ 是 $k$ 个递增数的和， $9\times (n+k)$ 就是不超过 $9k$ 个 $10$ 的幂的和，从而数码和 $\leq 9\times k$ ，反之亦能推出，故这是充要条件</p>
<p>问题转化为：求最小的 $k$ 使 $9(n+k)$ 的数码和 $\leq 9\times k$</p>
<p><strong>对于这种高精的题，尝试直接枚举，以利用均摊复杂度</strong></p>
<p>枚举 $k$ ，每次对 $9n$ 加 $9$ ，加法过程中维护数码和，答案不会超过 $\lg n+O(1)$ ，均摊复杂度为 $O(k+\lg n)=O(\log n)$</p>
<p><del>压位减小常数</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e5</span>+<span class="number">100</span>,BASE=<span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">int</span> n,s[N],f[<span class="number">10000</span>],cur,dsum,ans,len;</span><br><span class="line"><span class="keyword">char</span> str[N],tok[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">digit_sum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> f[x/<span class="number">10000</span>]+f[x%<span class="number">10000</span>];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    tok[<span class="number">8</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;<span class="number">10000</span>;++i) f[i]=f[i/<span class="number">10</span>]+i%<span class="number">10</span>;<span class="comment">//数码和分高低位打表</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str); len=<span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i*<span class="number">8</span>&lt;=len;++i) <span class="built_in">memcpy</span>(tok,str+(len-i*<span class="number">8</span>),<span class="number">8</span>),s[n++]=<span class="built_in">strtol</span>(tok,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span>(len&amp;<span class="number">7</span>) <span class="built_in">memcpy</span>(tok,str,len&amp;<span class="number">7</span>),tok[len&amp;<span class="number">7</span>]=<span class="number">0</span>,s[n++]=<span class="built_in">strtol</span>(tok,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;n+<span class="number">2</span>;++i) cur=s[i]*<span class="number">9</span>+cur,s[i]=cur%BASE,cur/=BASE,dsum+=<span class="built_in">digit_sum</span>(s[i]);</span><br><span class="line">    <span class="keyword">for</span>(ans=<span class="number">1</span>;;++ans)&#123;</span><br><span class="line">        dsum-=<span class="built_in">digit_sum</span>(*s),*s+=<span class="number">9</span>;</span><br><span class="line">        rei i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;s[i]&gt;=BASE;++i) dsum+=<span class="built_in">digit_sum</span>(s[i]-=BASE)-<span class="built_in">digit_sum</span>(s[i+<span class="number">1</span>]++);<span class="comment">//数码和的守恒</span></span><br><span class="line">        dsum+=<span class="built_in">digit_sum</span>(s[i]);</span><br><span class="line">        <span class="keyword">if</span>(dsum&lt;=<span class="number">9</span>*ans)&#123; <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans); <span class="keyword">goto</span> done;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    done:</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>有一条分成 $n$ 段的铁路共有 $n+1$ 个站台，标号为 $0\sim N$ ，其中铁路 $i$ 连接站台 $i-1,i$ ，长度为 $a_i$ ，铁路分为单向双向两种，需要制定一个时间表，满足：</p>
<p>所有火车要么正向要么反向，中途不能掉头</p>
<p>所有火车速度 $1$ 单位，且保持匀速</p>
<p>所有正向，反向火车发车间隔均为 $k$ 且在站 $i$ 上的停靠时间只与 $i$ 有关</p>
<p>对于任意一条单向铁路，不能有正向反向火车在非站台的地方相遇</p>
<p>求一个时间表，使正向火车 $0\sim n$ 的时间加上反向火车 $n\sim 0$ 的时间总合(包括停靠时间)最小</p>
</blockquote>
<p>把铁路放在数轴上考虑，每个站台 $i$ 都有坐标 $x_i=a_1+a_2+…+a_i$ ，且将时间模 $k$ ，在 $\pmod k$ 的范围下讨论</p>
<p>先考虑无解：</p>
<p>一段单项铁路长度 $l&gt;\frac{k}{2}$ 时无解：$\pmod k$ 意义下两个长度 $&gt;\frac{k}{2}$ 的区间并相交，显然正反向列车行车区间相交则无解； 反之，若所有长度 $l\leq \frac{k}{2}$ 则一定有解。</p>
<p>设 $p_0$ 时正向列车发车时刻， $p_i$ 时列车在站台 $i$ 的停靠时间，则正向列车在铁路 $i$ 上的行车区间为 $[p_0+p_1+…+p_{i-1}+x_{i-1} \ ,\ p_0+p_1+…+p_{i-1}+x_i]$</p>
<p>简记 $P_n=\sum_{i=1}^n p_i$ 则区间 $\mathcal{P_i}=[P_{i-1}+x_{i-1}\ ,\ P_{i-1}+x_i]$</p>
<p>而对于反向列车，将整个过程倒过来，设 $-n_0$ 为到达时刻， $n_i$ 为停靠时间，$N_n=\sum_{i=1}^n n_i$ ，则区间 $\mathcal{N_i}=[-N_{i-1}-x_i\ ,\ -N_{i-1}-x_{i-1}]$</p>
<p>考虑环上区间 $[l_1,r_1],[l_2,r_2]$ 不交的充要条件，为 $l_1\in [r_2,l_1+l_2-r_1]$</p>
<p>$\therefore$ 列车不碰撞的条件转化为表达式： $P_{i-1}+x_{i-1}\in [-N_{i-1}-x_{i-1}\ ,\ -N_{i-1}+x_{i-1}-2x_i] \Leftrightarrow P_{i-1}+N_{i-1}\in[-2x_{i-1}\ ,\ -2x_i]$</p>
<p>再考虑最终答案，若不计停靠时间显然为 $2\times x_n$ ，所以需要最小化停靠时间之和 $\sum_{i=1}^{n-1} (p_i+n_i)$</p>
<p>将上述不碰撞区间看为 $R_i$ ，转化为一般问题：</p>
<blockquote>
<p>若干个区间 $R_1,R_2,…,R_n$ 有一个 $\pmod k$ 意义下的数 $x$ ，且初值任意。需要核实的移动 $x$ 使其落入 $R_i$ 中，仅能正向移动，且模 $k$ ，求最小化移动距离</p>
</blockquote>
<p>当起点固定，有贪心：能不移就不移，否则移至区间左端点</p>
<p>由于不知道起点，考虑 $\text{dp}$ ，$f_{i,x}$ 表示前 $i$ 个区间，从最有七点移动到已知终点 $x$ 所需最小总距离</p>
<p>设 $j$ 是最大的使 $x\notin R_j$ 的 $j$ ，整个过程的最后一步就是将 $x$ 从 $R_j$ 的右端点移回 $x$ </p>
<p>$f_{i,x}=f_{j,r_j}+\left(x∸r_j\right)$ ，其中 $a∸b$ 表示 $a-b$ 取 $\pmod k$ 的最小非负剩余</p>
<p>添加区间时依次求出 $f_{1,r_1},f_{2,r_2},…,f_{n,r_n}$ ，最后的位置一定是某个区间的左端点，将所有左端点带入 $x$ 询问即可</p>
<p>最后，考虑如何找到最大的 $j$ 使 $x\notin R_j$ 的 $j$ 最大</p>
<p>对于每个 $x$ ,设 $pre_x=j$ ，考虑操作对 $pre$ 的影响</p>
<p>每一次操作相当于对不在 $[l_i,r_i]$ 的所有数 $e$ 令 $pre_e=i$</p>
<p>这可以看成区间赋值，而查询只需要单点查询，然后就会用到珂朵莉树</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,T;</span><br><span class="line">ll x[N],f[N],ans=LLONG_MAX;</span><br><span class="line">PII seg[N];</span><br><span class="line"><span class="keyword">bool</span> directed[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(ll &amp;x,<span class="keyword">const</span> ll y)</span></span>&#123;x&gt;y ? x=y : <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">fix</span><span class="params">(ll x)</span></span>&#123;<span class="keyword">return</span> x%=T,x+=x&gt;&gt;<span class="number">63</span>&amp;T;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> CTree&#123;</span><br><span class="line">	map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; C;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; C.<span class="built_in">emplace</span>(<span class="number">0</span>,<span class="number">-1</span>),C.<span class="built_in">emplace</span>(T,<span class="number">-1</span>);&#125;</span><br><span class="line">	map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::<span class="function">iterator <span class="title">split</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">		map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator it=C.<span class="built_in">lower_bound</span>(pos),jt=it;</span><br><span class="line">		<span class="keyword">return</span> it-&gt;first==pos ? it : C.<span class="built_in">emplace_hint</span>(it,pos,(--jt)-&gt;second);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator it=<span class="built_in">split</span>(l),jt=<span class="built_in">split</span>(r);</span><br><span class="line">		C.<span class="built_in">erase</span>(it,jt),C.<span class="built_in">emplace</span>(l,v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> h)</span></span>&#123;<span class="keyword">return</span>(--C.<span class="built_in">upper_bound</span>(h))-&gt;second;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rei j,L,R;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;T);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%lld%d&quot;</span>,x+i,&amp;j),directed[i]=j&amp;<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="number">2</span>*x[i]&gt;T) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>),<span class="number">0</span>;</span><br><span class="line">			x[i]+=x[i<span class="number">-1</span>],seg[m++]=<span class="built_in">mk</span>(L=<span class="built_in">fix</span>(<span class="number">-2</span>*x[i<span class="number">-1</span>]),R=<span class="built_in">fix</span>(<span class="number">-2</span>*x[i]));</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">else</span> x[i]+=x[i<span class="number">-1</span>];</span><br><span class="line">	CTree::<span class="built_in">init</span>();</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">		std::<span class="built_in">tie</span>(L,R)=seg[i],j=CTree::<span class="built_in">query</span>(R);</span><br><span class="line">		f[i]=(~j ? f[j]+<span class="built_in">fix</span>(R - seg[j].second) : <span class="number">0</span>);</span><br><span class="line">		L&lt;=R ? (CTree::<span class="built_in">modify</span>(<span class="number">0</span>,L,i),CTree::<span class="built_in">modify</span>(R+<span class="number">1</span>,T,i)) : (CTree::<span class="built_in">modify</span>(R+<span class="number">1</span>,L,i));</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">const</span> PII &amp;e : CTree::C)&#123;</span><br><span class="line">		<span class="keyword">if</span>(e.first&gt;=T) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(!~e.second)&#123; ans=<span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">		<span class="built_in">down</span>(ans,f[e.second]+<span class="built_in">fix</span>(e.first-seg[e.second].second));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans+<span class="number">2</span>*x[n]);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>思维</tag>
        <tag>dp</tag>
        <tag>数论</tag>
        <tag>珂朵莉树</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>90801202-AGC006</title>
    <url>/2021/08/09/AGC006/</url>
    <content><![CDATA[<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><blockquote>
<p>一个数字三角形，最下层的值是 $1\sim 2n-1$ 的排列，其余的值是正下，左下，右下方三个值的中位数，给定 $n,x$ ， 求能构造出顶端是 $x$ 的最下层排列</p>
</blockquote>
<p>先考虑无解：即 $x=1 或 x=2n-1$ 时无解</p>
<p>其次可以发现，对于两个相邻的相同数字，该数字会一直向上延伸</p>
<p>而 $x$ 就是离对称轴最近且满足条件的数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,x,p[N],vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;x);</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1</span> || x==<span class="number">2</span>*n<span class="number">-1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>),<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    p[n]=x;</span><br><span class="line">	p[n<span class="number">-1</span>]=x==<span class="number">2</span> ? x+<span class="number">1</span> : x<span class="number">-1</span>,p[n+<span class="number">1</span>]=x==<span class="number">2</span> ? x<span class="number">-1</span> : x+<span class="number">1</span>,p[n+<span class="number">2</span>]=x==<span class="number">2</span> ? x+<span class="number">2</span> : x<span class="number">-2</span>;</span><br><span class="line">    vis[x]=vis[x+<span class="number">1</span>]=vis[x<span class="number">-1</span>]=vis[x==<span class="number">2</span> ? x+<span class="number">2</span> : x<span class="number">-2</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,j=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n<span class="number">-1</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">while</span>(vis[j]) ++j;</span><br><span class="line">        p[i]=j,vis[j]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n<span class="number">-1</span>;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p[i]);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><blockquote>
<p>数轴上有 $n$ 只兔子，第 $i$ 只位于 $a_i$ ，做 $k$ 次移动，每次由 $m$ 次跳跃，对于第 $j$ 次跳跃，第 $c_j$ 只兔子等概率选取 $c_{j-1}$ 或 $c_{j+1}$ 的兔子并跳到其对称点，求每一只兔子最终位置的期望</p>
</blockquote>
<p>对于兔子 $c_j$ ，跳跃后会转移到 $2\times c_{j-1}-c_j$ 或 $2\times c_{j+1}-c_j$</p>
<p>所以有 $f’_{c_j}=\frac{2\times f_{c_{j-1}}-f_{c_j}+2\times f_{c_{j+1}}-f_{c_j}}{2}=f_{c_{j-1}}+f_{c_{j+1}}-f_{c_j}$</p>
<p>而进行 $k\leq 10^{18}$ 轮，时间复杂度显然会爆</p>
<p>$\text{ctp_314}$ 告诉我们，遇到转移问题难以转移就想一想差分，即， $d_i=f_i-f_{i-1}$</p>
<p>差分的转移为:</p>
<script type="math/tex; mode=display">d'_i=(f_{i-1}+f_{i+1}-f_i)-f_{i-1}=f_{i+1}-f_i=d_{i+1} \\
d'_{i+1}=f_{i+1}-(f_{i-1}+f_{i+1}-f_i)=f_i-f_{i-1}=d_i \\</script><p>恰好是交换，那么求出循环节即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[N],f[N],s[N],top,vis[N];</span><br><span class="line">ll ans[N],k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(rei i=n;i;--i) a[i]-=a[i<span class="number">-1</span>],f[i]=i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>,&amp;m,&amp;k);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>,p;i&lt;=m;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p),<span class="built_in">swap</span>(f[p],f[p+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i,top=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            <span class="keyword">for</span>(rei j=i;!vis[j];j=f[j]) vis[j]=<span class="number">1</span>,s[++top]=j;</span><br><span class="line">            <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=top;++j) ans[ s[j] ]=a[ s[(j+k<span class="number">-1</span>)%top+<span class="number">1</span>] ];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans[i]+=ans[i<span class="number">-1</span>]);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>数字三角形，生成规则与 $B$ 相同，给定第 $n$ 行的数列，求第 $1$ 行的</p>
</blockquote>
<p>不会的二分贪心思维题</p>
<p>二分顶端的数，由于用中位数生成，所以数列中只需要保留与顶端数的大小关系，即将原数列转化为 $01$ 串</p>
<p>由 $B$ 推出的性质推广得：当存在两个相邻的 $0/1$，且不与边界相邻，那么可以一直向上走</p>
<p>即，离对称轴最近且长度至少为 $2$ 的连续段就是顶端答案</p>
<p>最后特判不存在该连续段的情况</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,ans=<span class="number">2</span>,p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">valid</span><span class="params">(<span class="keyword">int</span> mid)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;++i)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">max</span>(p[n-i],p[n-i<span class="number">-1</span>])&lt;=mid || <span class="built_in">max</span>(p[n+i],p[n+i+<span class="number">1</span>])&lt;=mid) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">min</span>(p[n-i],p[n-i<span class="number">-1</span>])&gt;mid || <span class="built_in">min</span>(p[n+i],p[n+i+<span class="number">1</span>])&gt;mid) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> p[<span class="number">1</span>]&lt;=mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n); <span class="keyword">for</span>(rei i=<span class="number">2</span>*n<span class="number">-1</span>;i;--i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p[i]);</span><br><span class="line">    rei l=<span class="number">2</span>,r=<span class="number">2</span>*n<span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        rei mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">valid</span>(mid) ? r=mid<span class="number">-1</span>,ans=mid : l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>给定 $3\times N$ 的矩阵，点 $(i,j)$ 的数为 $i+3j-3$ 。有操作：选择 $3\times 3$ 的矩阵，并将其旋转 $180^。$ 。给定目标矩阵，询问是否可以转化</p>
</blockquote>
<p>首先考虑无解：</p>
<ul>
<li>将每一列看为一个整体，整体内部的元素组成不变</li>
<li>所有模 $3$ 余 $2$ 的数一定在第二行</li>
</ul>
<p>再考虑性质：每次以 $(i,2)$ 为中心旋转实际是交换 $i-1,i+1$ 列，并将 $[i-1,i+1]$ 上下颠倒 —— 将上下颠倒看作奇偶性，奇数时要上下颠倒</p>
<p>将每一列当成字母，小写为颠倒前，大写为颠倒后，设 $abcde$ 为原矩形的部分</p>
<p>其次可以推出结论：</p>
<ul>
<li><p>可以将隔着一列的两列数同时颠倒</p>
<script type="math/tex; mode=display">\underline{abc}de \Rightarrow CB\underline{Ade} \Rightarrow \underline{CBE}Da \Rightarrow eb\underline{cDa}\Rightarrow \underline{ebA}dC \Rightarrow aBcDe</script></li>
<li><p>可以同时改变相邻 $4$ 列的奇偶性</p>
<script type="math/tex; mode=display">\underline{abc}d \Rightarrow C\underline{BAd} \Rightarrow \underline{CDa}b \Rightarrow A\underline{dcb} \Rightarrow ABCD</script></li>
</ul>
<p>$\therefore$ 可以成对改变边的奇偶性，那么只需要考虑最终状态 奇数列 与 偶数列上下颠倒个数 的奇偶性，若都为偶则合法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">3</span>][N],f[N],h[<span class="number">2</span>],n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i) <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=n;++j) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i][j]);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        rei a=w[<span class="number">0</span>][i],b=w[<span class="number">1</span>][i],c=w[<span class="number">2</span>][i];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(a-b)&gt;<span class="number">1</span> || <span class="built_in">abs</span>(b-c)&gt;<span class="number">1</span> || b%<span class="number">3</span>!=<span class="number">2</span> || (b%<span class="number">6</span> &amp; i&amp;<span class="number">1</span>)) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>),<span class="number">0</span>;</span><br><span class="line">        f[i]=b/<span class="number">3</span>+<span class="number">1</span>,h[i&amp;<span class="number">1</span>]^=a&gt;c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">while</span>(f[i]!=i) h[ i&amp;<span class="number">1</span>^<span class="number">1</span> ]^=<span class="number">1</span>,<span class="built_in">swap</span>(f[i],f[ f[i] ]);</span><br><span class="line">    h[<span class="number">0</span>]||h[<span class="number">1</span>] ? <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>) : <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>给定 $n\times n$ 的网格，给定黑点坐标，其余白色，若存在 $(x,y)$ 和 $(y,z)$ 则会出现一个 $(z,x)$ 的黑点，求最终黑点数</p>
</blockquote>
<p>若 $(x,y)$ 为黑色，则连 $x\rightarrow y$ 的边，将题目等价于：若有 $x\rightarrow y 且 y\rightarrow z$ ，则有 $z\rightarrow x$</p>
<p>如此连边不会影响连通性，只需考虑一个连通块内的情况并累加即可</p>
<p><strong>由连边方式构成的三元环结构引导我们对图染色</strong></p>
<p>连边方式自然定为：若 $x\rightarrow y$ , 则有 $col(x)+1\equiv col(y) \pmod 3$</p>
<p>对染色情况分类：</p>
<ul>
<li><p>所有点只用 $\leq 2$ 中颜色且成功</p>
<p>即没有出现新边，最终边数 $|E’|$ 等于原边数 $|E|$</p>
</li>
<li><p>所有点用 $3$ 种颜色且成功</p>
<p>可以证明此时图 $G$ 具有完全三分图的结构</p>
<p>在此情况下，总边数等于各个部分大小的两两乘积和</p>
</li>
<li><p>染色失败</p>
<p>设加入边 $(u,v)$ 时失败，即，加入该边前 $u,v$ 已经连通，此时他们所在的连通分量是一个完全三分图</p>
<p>考虑失败原因</p>
<ul>
<li><p>$1\rightarrow 0$</p>
<p>即自环存在于 $0\rightarrow 1\rightarrow 0$</p>
</li>
<li><p>$0\rightarrow 0$</p>
<p>即有 $0\rightarrow 0\rightarrow 1\rightarrow 0$</p>
</li>
</ul>
<p>对于自环 $s\rightarrow s$ ,可以证明所有与 $s$ 相连的点 $u$ ,都有重边； 而对于 $\forall v,u$ 都有 $v\rightarrow s\rightarrow u \rightarrow v$</p>
<p>即，图 $G$ 完全图</p>
<p>该情况下总边数时连通分量大小的平方</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],Next[N&lt;&lt;<span class="number">1</span>],ver[N&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line"><span class="keyword">int</span> col[N],c[<span class="number">3</span>],n,m,ce;</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123; ver[++tot]=v,Next[tot]=head[u],head[u]=tot;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> result=<span class="literal">true</span>; ++c[ col[x] ];</span><br><span class="line">    <span class="keyword">for</span>(rei i=head[x];i;i=Next[i])&#123;</span><br><span class="line">        rei y=ver[i];</span><br><span class="line">        rei c=(col[x]+<span class="number">2</span>-(i&amp;<span class="number">1</span>))%<span class="number">3</span>; ++ce;</span><br><span class="line">        result&amp;=(~col[y] ? col[y]==c : (col[y]=c,<span class="built_in">dfs</span>(y)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,u,v;i&lt;=m;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v),<span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">    <span class="built_in">memset</span>(col,<span class="number">-1</span>,<span class="keyword">sizeof</span> col);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span>(!~col[i])&#123;</span><br><span class="line">            c[<span class="number">0</span>]=c[<span class="number">1</span>]=c[<span class="number">2</span>]=ce=col[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(i)) ans+=(ll) (c[<span class="number">0</span>]+c[<span class="number">1</span>]+c[<span class="number">2</span>])*(c[<span class="number">0</span>]+c[<span class="number">1</span>]+c[<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c[<span class="number">0</span>] &amp;&amp; c[<span class="number">1</span>] &amp;&amp; c[<span class="number">2</span>]) ans+=(ll) c[<span class="number">0</span>]*c[<span class="number">1</span>]+(ll) (c[<span class="number">0</span>]+c[<span class="number">1</span>])*c[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">else</span> ans+=ce&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>思维</tag>
        <tag>染色</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>41801202-AGC010</title>
    <url>/2021/08/14/AGC010/</url>
    <content><![CDATA[<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><blockquote>
<p>$n$ 个数字 $a_i$ ，构成一个环，每次从一个起点出发顺时针给这个环依次 $-1,-2,…,-n$ ，求是否有一种方案使所有数恰好被减到 $0$</p>
</blockquote>
<p><strong>注意这里 $-1,-2,…,-n$ 就要考虑差分</strong></p>
<p>每次对 $i$ 操作使 $d_i-=n-1 , \forall j\in n 有 \ d_j+=1 (j!=i)$</p>
<p>每次操作会使整个数列共减少 $c=\frac{n\times (n+1)}{2}$ 显然必须满足 $\sum a_i \mod c=0$</p>
<p>设 $m_i$ 代表以 $i$ 开头的操作的个数</p>
<script type="math/tex; mode=display">d_i=(\frac{\sum a_i}{c}-m_i)-m_i\times (n-1)=\frac{\sum a_i}{c}-m_i\times n</script><script type="math/tex; mode=display">m_i=\frac{\frac{\sum a_i}{c}-d_i}{n}</script><p>满足 $m_i$ 非负整数即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line">ll a[N],d[N],c,n,sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n); c=(ll) n*(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]),sum+=a[i];</span><br><span class="line">    <span class="keyword">if</span>(sum%c) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>),<span class="number">0</span>;</span><br><span class="line">    sum/=c;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) d[i]=a[i%n+<span class="number">1</span>]-a[i];</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>(d[i]&gt;sum || (sum-d[i])%n)&#123; <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>); <span class="keyword">goto</span> done;&#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">    done:</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="剩下三道博弈论蚌埠住了"><a href="#剩下三道博弈论蚌埠住了" class="headerlink" title="剩下三道博弈论蚌埠住了"></a>剩下三道博弈论蚌埠住了</h2><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>$n$ 个正整数满足 $\gcd(a_1,a_2,…,a_N)=1$ ，两人轮流以下操作：选择 $i\in n且 a_i&gt;2 使 a_i—$ ，设 $g=\gcd(a_1,a_2,…,a_n) : \forall i\in n \ \ \  a_i=\frac{a_i}{g}$<br>当轮到某玩家操作时 $a_1=a_2=…=a_n$ 该玩家负</p>
</blockquote>
<p>从特殊到一般考虑：</p>
<p>已经有一个 $a_i=1$ 时 $\gcd一定1$ ，此时的操作就简化为每个人每次将一个数 $-1$ ，即，此时先手必胜当且仅当偶数的个数为奇数</p>
<p>将偶数个数记为 $d_1$ ，奇数个数记为 $d_0$</p>
<p>在考虑一般情况：如果除的 $\gcd$ 是奇数，则对局面的奇偶性不影响，即， $d_1,d_0$ 都不变</p>
<p>由此，如果在某一方发现 $d_1$ 是奇数，则他希望 $\gcd$ 是奇数</p>
<p>有结论： 若 $2\nmid d_1$ 则先手必胜 ； 若 $2\mid d_1 且 d_0\geq 2 ; 或 2\mid d_1 且 数列中有 1$ 则后手必胜</p>
<p><del>证明被吃掉了Σ(っ °Д °;)っ</del></p>
<p>剩余的情况是：偶数个偶数，且剩一个 $&gt;1$ 的奇数</p>
<p>此时先手一定不操作偶数，否则 $\gcd$ 为奇不改变就行，而后手满足 $2\nmid d_1$ 则后手必胜</p>
<p>先手一定会把奇数 $-1$ <strong>让 $\gcd$ 变成偶数</strong></p>
<p>那么模拟先手的操作，更换先后手，判断新局面即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span>&#123;</span><br><span class="line">    rei c[<span class="number">2</span>]=&#123;<span class="number">0</span>&#125;,g=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> one=<span class="literal">false</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">u</span><span class="params">(v)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x:v) ++c[x&amp;<span class="number">1</span>],one|= x==<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(*c&amp;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(one || c[<span class="number">1</span>]&gt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> &amp;x:u) g=__gcd(g,x&amp;=<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> &amp;x:u) x/=g;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">judge</span>(u);<span class="comment">//换手</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n); a.<span class="built_in">reserve</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,x;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x),a.<span class="built_in">emplace_back</span>(x);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="built_in">judge</span>(a) ? <span class="string">&quot;First&quot;</span> : <span class="string">&quot;Second&quot;</span>);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>一个长度为 $n$ 的数列 $a$ ，$A$ 会将整个序列任意排列，$B$ 选择一个相邻的互质数交换位置。 $A$ 希望最终序列字典序尽可能小， $B$ 希望尽可能大，求最终序列</p>
</blockquote>
<p>考虑到 $B$ 只能交换互质的数，那么，所有不互质的数在 $A$ 确定位置后相对位置不会改变，即，对于 $i,j \ 其中 i&lt;j 且 \gcd(a_i,a_j)\not ={1}$ ，连 $i\rightarrow j$ 以确保 $a_i$ 在 $a_j$ 左边，这构成一个DAG</p>
<p>通过拓扑可以得到合法解，而加入优先队列可以得到后手想要的最大解</p>
<p>注意先手尽可能把较小的往前面放，按权值小到大枚举 $u$ 的儿子 $v$ ，并连 $u\rightarrow v$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2010</span>;</span><br><span class="line"><span class="keyword">int</span> n,c[N],deg[N],G[N][N]; <span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> head[N],Next[N&lt;&lt;<span class="number">1</span>],ver[N&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123; ver[++tot]=v,Next[tot]=head[u],head[u]=tot; ++deg[v];&#125;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    vis[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i] || !G[i][x]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">add</span>(x,i); <span class="built_in">dfs</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topsort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>(!deg[i]) q.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        rei x=q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,c[x]);</span><br><span class="line">        <span class="keyword">for</span>(rei i=head[x];i;i=Next[i]) q.<span class="built_in">push</span>(ver[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;c[i]);</span><br><span class="line">    <span class="built_in">sort</span>(c+<span class="number">1</span>,c+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span>(rei j=i+<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(__gcd(c[i],c[j])==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            G[i][j]=G[j][i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>(!vis[i]) <span class="built_in">dfs</span>(i);</span><br><span class="line">    <span class="built_in">topsort</span>();</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>给定 $n$ 个节点的数，顶点 $i$ 上有 $a_i$ 枚石子，开始前 $A$ 可以选择一个节点并在其上面放一枚棋子，然后 $AB$ 交替以下操作：设棋子当前在点 $v$ ，若当前点 $v$ 行已经没有石子则当前玩家输，否则移除点 $v$ 上的一个石子；将棋子移到相邻的点 $u$。 要求找到所有点 $v$ 使 $A$ 开局前把棋子放到 $v$ 上时必胜</p>
</blockquote>
<p>证明一个神仙结论：任何时候，每个人只会向满足 $A$ 更小的地方走，即，任何人不会向 $A_u\geq A_v$ 的点 $u$ 移动</p>
<ul>
<li><p>不妨设 $A$ 如此移动，即，棋子 $v\rightarrow u$ ，将原树看成以 $v$ 为根的有根树，考虑以 $u$ 为根的子树</p>
<ul>
<li>若 $B$ 在当前有必胜策略，则 $B$ 赢了</li>
<li>若 $B$ 无必胜策略，则 $B$ 的最优策略是逃离 $u$ ，那么 $B:u\rightarrow v$ 如此 $A$ 会失去先手优势</li>
<li>由此， $A$ 不可能取胜，则其不会这么走</li>
</ul>
</li>
</ul>
<p>由上可知，若子树中 $B$ 赢，则原树中 $A$ 赢，反之亦成立</p>
<p>$\text{dfs}$ 判断 ，$O(n^2)$ 解决即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3010</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],Next[N&lt;&lt;<span class="number">1</span>],ver[N&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line"><span class="keyword">int</span> a[N],n;</span><br><span class="line"><span class="keyword">bool</span> first=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123; ver[++tot]=v,Next[tot]=head[u],head[u]=tot;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa=<span class="number">0</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> flag=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=head[x];i;i=Next[i])&#123;</span><br><span class="line">		rei y=ver[i]; <span class="keyword">if</span>(y==fa || a[y]&gt;=a[x]) <span class="keyword">continue</span>;</span><br><span class="line">		flag&amp;=<span class="built_in">dfs</span>(y,x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> !flag;<span class="comment">//经典换手</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>,u,v;i&lt;n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v),<span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>(<span class="built_in">dfs</span>(i)) first ? first=<span class="literal">false</span> : <span class="built_in">putchar</span>(<span class="number">32</span>),<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>思维</tag>
        <tag>贪心</tag>
        <tag>博弈论</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>71801202-AGC012</title>
    <url>/2021/08/17/AGC012/</url>
    <content><![CDATA[<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><blockquote>
<p>定义一个好字符串 $x$ 满足：$x=yy$ ，给出 $n$ , 求一个串 $s$ 满足 $|s|\leq 200$ ，且每个字符用 $[1,100]$ 的整数表示，且在 $s$ 的所有 $2^{|s|}$ 哥子序列中，恰好有 $n$ 个串是好的</p>
</blockquote>
<p>有一个巧妙的构造方案：</p>
<p>分成前后两部分，后半部分为 $1\sim 100$ ，前半部分为 $1$ 至 $x \ (x\leq 100)$ ，<strong>好序列的个数为前半部分上升子序列的个数</strong></p>
<p>从小到大增加前半部分的字符，放到最前面使方案数 $+1$ ，最后面使方案数 $\times 2$ ，而反向过来就是一个二进制拆分过程</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">210</span>;</span><br><span class="line"><span class="keyword">int</span> p[N],q[N],cnt;</span><br><span class="line">ll n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(~n&amp;<span class="number">1</span>) q[ ++q[<span class="number">0</span>] ]=cnt++,<span class="built_in">solve</span>(n<span class="number">-1</span>);<span class="comment">//放前面,会使数量加1</span></span><br><span class="line">    <span class="keyword">else</span> p[ ++p[<span class="number">0</span>] ]=cnt++,<span class="built_in">solve</span>(n&gt;&gt;<span class="number">1</span>);<span class="comment">//放后面，会使数量 *2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">solve</span>(n); <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cnt+<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=q[<span class="number">0</span>];++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,cnt-q[i]);</span><br><span class="line">    <span class="keyword">for</span>(rei i=p[<span class="number">0</span>];i;--i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,cnt-p[i]);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>$n$ 个球，第 $i$ 个颜色为 $c_i$ ，质量为 $w_i$ ，有两种操作：选择两个同色且质量和不超过 $x$ 的球并交换位置 ; 选择两个异色且质量和不超过 $Y$ 的球并交换位置</p>
<p>求一共能得到多少不同的颜色序列</p>
</blockquote>
<p>对于一种颜色，设所有球质量分别为 $w_1,w_2…w_n$ ，假设 $w_1&lt;w_2&lt;w_n$ ，易得若 $w_1+w_n\leq x$ 则这 $n$ 个球可以任意交换位置（以 $1$ 号球为媒介依次交换 $(1,i),(1,j),(i,1)$</p>
<p>若 $w_1+w_n&gt;x$ 再设 $m$ 为最大的满足 $w_1+w_m\leq x$ 的数，考虑处理 $w_m\sim w_n$</p>
<p>考虑使用全局最小值，指与 $w_i$ 不同颜色的最小值，设为 $w_g$ ，对于要处理的部分，若 $w_g+w_i\leq y$ ，则 $(i,g)$ 可以互换位置（同样以 $1$ 为媒介），也就是数，满足 $w_g+w_i\leq y$ 的 $i$ 与 $1\leq i\leq m$ 的 $i$ 性质一样</p>
<p>但若 $w_g+w_i&gt;y$  则该球不能移动</p>
<p>对于剩下的球，将每种颜色视为整体，质量为所有球的总质量，可以发现其性质与小球一样</p>
<p>答案就是前 $m$ 种颜色的所有球的排列总数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,S,D;</span><br><span class="line"><span class="keyword">int</span> fac[N],facinv[N];</span><br><span class="line">ll ans=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> m,MIN=INF,sec=INF;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">const</span> <span class="keyword">int</span> y)</span></span>&#123; x&gt;y ? x=y : <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">qpow</span><span class="params">(ll x,<span class="keyword">int</span> y)</span></span>&#123; ll ans=<span class="number">1</span>; <span class="keyword">while</span>(y)&#123; <span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod; x=x*x%mod; y&gt;&gt;=<span class="number">1</span>;&#125; <span class="keyword">return</span> ans;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) fac[i]=(ll) fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    facinv[n]=<span class="built_in">qpow</span>(fac[n],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(rei i=n;i;--i) facinv[i<span class="number">-1</span>]=(ll) facinv[i]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;S,&amp;D); <span class="built_in">init</span>();</span><br><span class="line">    <span class="comment">// puts(&quot;here&quot;);</span></span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,c,v;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;c,&amp;v),s[c].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>(s[i].<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="built_in">iter_swap</span>(s[i].<span class="built_in">begin</span>(),<span class="built_in">min_element</span>(s[i].<span class="built_in">begin</span>(),s[i].<span class="built_in">end</span>()));</span><br><span class="line">        <span class="keyword">if</span>(s[i].<span class="built_in">front</span>()&lt;MIN) sec=MIN,MIN=s[i].<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">down</span>(sec,s[i].<span class="built_in">front</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// puts(&quot;here&quot;);</span></span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>(s[i].<span class="built_in">size</span>() &amp;&amp; s[i].<span class="built_in">front</span>()+MIN&lt;=D)&#123;</span><br><span class="line">        rei c=<span class="number">0</span>,v=s[i].<span class="built_in">front</span>()==MIN ? sec : MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u:s[i]) c+=u+s[i].<span class="built_in">front</span>()&lt;=S || u+v&lt;=D;</span><br><span class="line">        m+=c,ans=ans*facinv[c]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// puts(&quot;here&quot;);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans*fac[m]%mod);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>数轴上有 $n(n\leq 2\times 10^5)$ 个绿洲，有一只储水量 $V(V\leq 2\times 10^5)$ 的骆驼，骆驼有两个操作：走到距离 $V$ 以内的一个绿洲；跳到任意绿洲，代价是 $V$ 会变为 $\left\lfloor \frac{V}{2} \right\rfloor$ ，注意当 $V=0$ 时不能跳，骆驼会从每个绿洲出发，对每一个判断能否一次性遍历所有绿洲</p>
</blockquote>
<p>对于 $V,\frac{V}{2},\frac{V}{4},…$ 可以先预处理出此时那些绿洲之间可以直接走</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ntzucbso.png" alt="https://cdn.luogu.com.cn/upload/image_hosting/ntzucbso.png"></p>
<p>每跳一次相当于向下走一层，题目转化为钦定第一条线段，然后从每一层选一条，问是否能覆盖整个区间</p>
<p>神仙状压</p>
<p>设状态 $s$ 的第 $i$ 位为 $1$ 表示从第 $i$ 层选出一条线段， $f_1[s]$ 表示状态 $s$ 时从 $1$ 向右最多能延伸到的位置，$f_2[s]$ 表示状态 $s$ 时从 $n$ 向左做多能延伸到的位置</p>
<p>有转移：</p>
<script type="math/tex; mode=display">\begin{aligned}
f_1[s]=\max(f_1[s],upFind(f_1[s_0])) \\
f_2[s]=\min(f_2[s],downFind(f_2[s_0]-1)) \\
\end{aligned}</script><p>即，从 $s_0$ 加上一条线段能延伸到的位置</p>
<p>检查答案时，对第一层的每一条线段寻找是否有 $s$ 使 $f_1[s],f_2[U-s-1]$ 贺该线段覆盖整个区间。用状态 $s$ 的线段尽可能扩展左半部分，剩下的线段（不包括第一层的）尽可能扩展右半部分</p>
<p>最多会跳 $\log {V+1}$ 所以全集的状态 $U=2^{\log {V+1}}-1$ 所以要开到 $2^{19}$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,S=<span class="number">1</span>&lt;&lt;<span class="number">19</span>;</span><br><span class="line"><span class="keyword">int</span> n,V;</span><br><span class="line">ll d[N];</span><br><span class="line"><span class="keyword">int</span> logV,a[<span class="number">25</span>][N],U,f1[S],f2[S];</span><br><span class="line"><span class="comment">//a[i][j] 表示第i层第j条线段的右端点，而a[i][0]记录第i层线段的条数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">upFind</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//第一个严格大于x的右端点，该端点所在区间一定能延伸当前f_1</span></span><br><span class="line">    rei L=<span class="number">1</span>,R=a[<span class="number">0</span>];<span class="comment">//a[i][0]被用成边界了</span></span><br><span class="line">    <span class="keyword">while</span>(L&lt;R<span class="number">-1</span>)&#123;</span><br><span class="line">        rei mid=L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        a[mid]&lt;=x ? L=mid+<span class="number">1</span> : R=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a[L]&gt;x ? a[L] : a[R];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowFind</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//lowfind(x-1):第一个严格小于x-1的右端点，该点的下一个区间一定能延伸当前的f_2</span></span><br><span class="line"><span class="comment">//特别注意这里不能写lowfind(x) : 要是找到x-1，说明有一段以x-1为右端点的区间以及一段以x为左端点的区间，显然加入前者更优，但却加入后者导致错误</span></span><br><span class="line">    rei L=<span class="number">1</span>,R=a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span>(L&lt;R<span class="number">-1</span>)&#123;</span><br><span class="line">        rei mid=L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        a[mid]&lt;x ? L=mid : R=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a[R]&lt;x ? a[R]+<span class="number">1</span> : a[L]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;V);</span><br><span class="line">    <span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;logV)&lt;=V) ++logV; ++logV;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;d[i]),d[i<span class="number">-1</span>]=d[i]-d[i<span class="number">-1</span>]; d[n]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=logV;++i)&#123;</span><br><span class="line">        a[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">            a[i][ a[i][<span class="number">0</span>] ]=j;</span><br><span class="line">            <span class="keyword">if</span>(d[j]&gt;(V&gt;&gt;(i<span class="number">-1</span>))) ++a[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">1</span>][<span class="number">0</span>]&gt;logV)&#123;</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">puts</span>(<span class="string">&quot;Impossible&quot;</span>);</span><br><span class="line">        <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    U=(<span class="number">1</span>&lt;&lt;logV)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei s=<span class="number">0</span>;s&lt;=U;++s) f1[s]=<span class="number">0</span>,f2[s]=n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei s=<span class="number">0</span>;s&lt;=U;s+=<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;=logV;++i)&#123;</span><br><span class="line">            rei s0=<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span>(s&amp;s0) <span class="keyword">continue</span>;</span><br><span class="line">            f1[s|s0]=<span class="built_in">max</span>(f1[s|s0],<span class="built_in">upFind</span>(a[i],f1[s]));</span><br><span class="line">            f2[s|s0]=<span class="built_in">min</span>(f2[s|s0],<span class="built_in">lowFind</span>(a[i],f2[s]<span class="number">-1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=a[<span class="number">1</span>][<span class="number">0</span>];++i)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">        rei fr=a[<span class="number">1</span>][i<span class="number">-1</span>]+<span class="number">1</span>,to=a[<span class="number">1</span>][i];</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>) fr=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(rei s=<span class="number">0</span>;s&lt;=U&amp;&amp;!flag;s+=<span class="number">2</span>) <span class="keyword">if</span>(fr&lt;=f1[s]+<span class="number">1</span> &amp;&amp; f2[U-s<span class="number">-1</span>]<span class="number">-1</span>&lt;=to) flag=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">for</span>(rei j=fr;j&lt;=to;++j) <span class="built_in">puts</span>(<span class="string">&quot;Possible&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">for</span>(rei j=fr;j&lt;=to;++j) <span class="built_in">puts</span>(<span class="string">&quot;Impossible&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>给定长度为 $2n-1 \ (n\leq 60)$ 的数组 $a$ ，可以重排 $a$ 中的元素，再生成一个长度为 $n$ 的数组 $b$ ，其中 $b_i$ 是 $a_1\sim a_{2\times i-1}$ 的中位数，对于给定的 $a$ 球能生成多少种 $b$ ，对 $998244353$ 取模</p>
</blockquote>
<p>神仙 $\text{dp}$ qwq</p>
<p>可以设 $a_i$ 升序，那么 $b_i$ 有两条性质：</p>
<ul>
<li>$b_i\in \{a_i,a_{i+1},…,a_n,…,a_{2n-i}\}$</li>
<li>不存在 $i&lt;j$ 使 $b_i$ 介于 $b_j,b_{j+1}$ 之间</li>
</ul>
<p>设 $f_{i,j,k}$ 表示当前确定了 $b_i\sim b_n$ 且第 $i$ 层左边还有 $j$ 个不同的数可供选择，右边还有 $k$ 个不同的数可供选择（不含 $b_i$ ），边界为 $f_{n,0,0}=1$</p>
<p>考虑转移：</p>
<ul>
<li>若 $b_{i-1}=b_i$ 则两侧可供选择的数的个数不变，只需加上两侧新增的数 ($le$ 表示 $a_i$ 是否等于 $a_{i-1}$ ，$re$ 同理): $f_{i-1,j+le,k+re}\leftarrow f_{i,j,k}$</li>
<li>若 $b_{i-1}&lt;b_i$ 由性质 $2$ 得之前的 $b_j$ 不能在范围 $(b_{i-1},b_i)$ 之间，那么这些数无用。则右侧可选的数多 $1$ ，左侧可选的数数量在 $0\sim j+le-1$ 任取: $f_{i-1,v,k+1+re}\leftarrow f_{i,j,k} \ \ \ \ (v\in [0,j+le])$</li>
</ul>
<p>答案为当 $i=1$ ，任取 $j,k\in[0,2\times n-1]$ 求和</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">125</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,G,ans;</span><br><span class="line"><span class="keyword">int</span> a[N],f[<span class="number">2</span>][N][N],(*cur)[N]=*f,(*Next)[N]=f[<span class="number">1</span>];<span class="comment">//滚动</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fix</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123; x&gt;=mod ? x-=mod : <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n); G=(n&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=G;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+G);</span><br><span class="line">    Next[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=n;i&gt;<span class="number">1</span>;--i)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(cur,Next); <span class="built_in">memset</span>(Next,<span class="number">0</span>,<span class="keyword">sizeof</span> *f);</span><br><span class="line">        rei le=a[i]!=a[i<span class="number">-1</span>],re=a[G-i+<span class="number">1</span>]!=a[G-i+<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;=n-i&lt;&lt;<span class="number">1</span>;++j)</span><br><span class="line">            <span class="keyword">for</span>(rei k=<span class="number">0</span>;k&lt;=n-i&lt;&lt;<span class="number">1</span>;++k)&#123;</span><br><span class="line">                rei c=cur[j][k]; <span class="keyword">if</span>(!c) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">fix</span>(Next[j+le][k+re]+=c);</span><br><span class="line">                <span class="keyword">for</span>(rei v=<span class="number">0</span>;v&lt;j+le;++v) <span class="built_in">fix</span>(Next[v][k+<span class="number">1</span>+re]+=c);<span class="comment">//右边</span></span><br><span class="line">                <span class="keyword">for</span>(rei v=<span class="number">0</span>;v&lt;k+re;++v) <span class="built_in">fix</span>(Next[j+<span class="number">1</span>+le][v]+=c);<span class="comment">//左边</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;=G;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;=G;++j) <span class="built_in">fix</span>(ans+=Next[i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>思维</tag>
        <tag>贪心</tag>
        <tag>dp</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>81801202-AGC013</title>
    <url>/2021/08/18/AGC013/</url>
    <content><![CDATA[<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><blockquote>
<p>长度为 $l$ 的圆环上有 $n$ 个蚂蚁，位置为 $x_i$ ，运动方向为 $d_i$ ，$1$ 为顺时针，$2$ 为逆时针。每只蚂蚁同时开始以单位速度移动，若两蚂蚁相遇则会改变自身方向，求 $t$ 秒后每只蚂蚁位置</p>
</blockquote>
<p>易知蚂蚁的相对位置不变，将相遇掉头看成交换编号，可以算出 $t$ 秒后的有蚂蚁的位置</p>
<p>记录第一只蚂蚁的 $rank$ ，对于每一只蚂蚁来说，每当一只蚂蚁倒着穿过， $rank—$ ；正着穿过 $rank++$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,l,t,rank_1,rnk[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,w;</span><br><span class="line">&#125;a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;l,&amp;t);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a[i].x,&amp;a[i].w); a[i].w==<span class="number">2</span> ? a[i].w=<span class="number">-1</span> : <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        rei length=a[i].x+a[i].w*t;</span><br><span class="line">        rank_1+=length/l;</span><br><span class="line">        <span class="keyword">if</span>(length%l&lt;<span class="number">0</span>) --rank_1;</span><br><span class="line">        rnk[i]=(length%l+l)%l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(rnk+<span class="number">1</span>,rnk+<span class="number">1</span>+n);</span><br><span class="line">    rank_1=(rank_1%n+n)%n;</span><br><span class="line">    <span class="comment">// for(rei i=1;i&lt;=n;++i) printf(&quot;%d &quot;,rnk[i]);</span></span><br><span class="line">    <span class="comment">// printf(&quot;rank_1:%d\n&quot;,rank_1);</span></span><br><span class="line">    <span class="keyword">for</span>(rei i=rank_1+<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,rnk[i]);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=rank_1;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,rnk[i]);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>盒子里有黑白两种颜色 $n$ 个球，进行 $m$ 次操作，每次操作：从盒子中任取一个球，向盒子里添加黑白球各一个，在任取一个球。初始的球颜色不给出，求取出的 $2m$ 个球有多少种颜色序列</p>
</blockquote>
<p>本质上仅有四种操作：BB；BW；WB；WW</p>
<p>以操作次数为 $x$ 轴，盒子里白球数为 $y$ ，则有</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ox2813ev.png" alt="https://cdn.luogu.com.cn/upload/image_hosting/ox2813ev.png"></p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/au35glpi.png" alt="https://cdn.luogu.com.cn/upload/image_hosting/au35glpi.png"></p>
<p>显然四种操作会形成 $4$ 种不同序列，以任一点为起点画个图</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/rprt0vu0.png" alt="https://cdn.luogu.com.cn/upload/image_hosting/rprt0vu0.png"></p>
<p>设状态 $f_{i,j}$ 表示操作 $i$ 次，盒子里有 $j$ 个白球时序列的情况</p>
<p>但注意以所有盒子里情况为起点时会存在操作相同且最终序列也相同的情况，有结论：只统计白球数量到达过 $0$ 的操作组即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,f[N][N][<span class="number">2</span>],ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fix</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123; x&gt;=mod ? x-=mod : <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) f[<span class="number">0</span>][i][<span class="number">0</span>]=<span class="number">1</span>; f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">		<span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;=n;++j)&#123;</span><br><span class="line">			f[i][j][<span class="number">0</span>]%=mod,f[i][j][<span class="number">1</span>]%=mod;</span><br><span class="line">			<span class="keyword">if</span>(j<span class="number">-1</span>&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(j==<span class="number">1</span>) <span class="built_in">fix</span>(f[i+<span class="number">1</span>][j<span class="number">-1</span>][<span class="number">1</span>]+=f[i][j][<span class="number">0</span>]);</span><br><span class="line">				<span class="keyword">else</span> <span class="built_in">fix</span>(f[i+<span class="number">1</span>][j<span class="number">-1</span>][<span class="number">0</span>]+=f[i][j][<span class="number">0</span>]);</span><br><span class="line">				<span class="built_in">fix</span>(f[i+<span class="number">1</span>][j<span class="number">-1</span>][<span class="number">1</span>]+=f[i][j][<span class="number">1</span>]);</span><br><span class="line">				<span class="keyword">if</span>(j==<span class="number">1</span>) <span class="built_in">fix</span>(f[i+<span class="number">1</span>][j][<span class="number">1</span>]+=f[i][j][<span class="number">0</span>]);</span><br><span class="line">				<span class="keyword">else</span> <span class="built_in">fix</span>(f[i+<span class="number">1</span>][j][<span class="number">0</span>]+=f[i][j][<span class="number">0</span>]);</span><br><span class="line">				<span class="built_in">fix</span>(f[i+<span class="number">1</span>][j][<span class="number">1</span>]+=f[i][j][<span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(j+<span class="number">1</span>&lt;=n)&#123;</span><br><span class="line">				<span class="built_in">fix</span>(f[i+<span class="number">1</span>][j+<span class="number">1</span>][<span class="number">0</span>]+=f[i][j][<span class="number">0</span>]);</span><br><span class="line">				<span class="built_in">fix</span>(f[i+<span class="number">1</span>][j+<span class="number">1</span>][<span class="number">1</span>]+=f[i][j][<span class="number">1</span>]);</span><br><span class="line">				<span class="built_in">fix</span>(f[i+<span class="number">1</span>][j][<span class="number">0</span>]+=f[i][j][<span class="number">0</span>]);</span><br><span class="line">				<span class="built_in">fix</span>(f[i+<span class="number">1</span>][j][<span class="number">1</span>]+=f[i][j][<span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;=n;++i) <span class="built_in">fix</span>(ans+=f[m][i][<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>长度为 $n$ 的木板上有 $m$ 个标记点，距离木板左端点的距离分别为 $x_i$ ，在木板上放置一些不相交正方形满足：边长整数，底面紧贴木板，不能超出木板且覆盖所有木板，标记点的位置不能再两正方形交界处，记贡献为所有正方形面积的乘积，求出所有合法方案的贡献和</p>
<p>具体图例见<a href="https://atcoder.jp/contests/agc013/tasks/agc013_e">原题</a></p>
</blockquote>
<p>转化成神仙组合意义：</p>
<ul>
<li>在 $N+1$ 个间隔（包含位置为 $0$ 和 $N$ 的间隔）中放置若干个隔板。</li>
<li>其中位置 $0$ 和 $N$ 必须放置隔板，且有 $M$ 个位置禁止放置隔板。</li>
<li>对于 $N$ 个格子，每个格子中可以放球，蓝球或者红球。</li>
<li>特别满足：在相邻两个隔板间的每个格子中，蓝球数恰为 $1$，红球数恰为 $1$</li>
</ul>
<p>隔板对应正方形边界，对于长度为 $l$ 的段，放一个蓝球一个红球的方案数恰为 $l^2$</p>
<p>对于一种放置隔板的方案，放球的方案数为 $\prod_{i=1}^k (a_i)^2$ ，那么转化为统计放置隔板和球的方案数</p>
<p>设 $f_{i,j}$ 表示考虑前 $i$ 个格子和前 $i+1$ 个间隔，且最后一个隔板右边的球为 $j$ 个时发放置方案数</p>
<p>显然可以写出 $f[i+1]\leftarrow f[i]$ 的转移式子，取决于第 $i+1$ 个格子右侧是否进制放置隔板</p>
<ul>
<li><p>对于非标记点：</p>
<script type="math/tex; mode=display">\begin{aligned}
f_{i+1,0}=f_{i,0}+f_{i,2} \quad &\text{$i$ 与 $i+1$ 之间放/不放隔板}\\
f_{i+1,1}=2\times f_{i,0}+f_{i,1}+2\times f_{i,2} \quad &\text{放隔板仅由 $f_{i,2}$ 转移 $\times$ 红蓝两种颜色+不放隔板，同理有 $2\times f_{i,0}$}\\
f_{i+1,2}=f_{i,0}+f_{i,1}+2\times f_{i,2} \quad &\text{不放的话三种状态都能转移，放的话只有 $f_{i,2}$ 能转移}\\
\end{aligned}</script></li>
<li><p>对于标记点：</p>
<script type="math/tex; mode=display">\begin{aligned}
f_{i+1,0}=f_{i,0} \\
f_{i+1,1}=2\times f_{i,0}+f_{i,1} \\
f_{i+1,2}=f_{i,0}+f_{i,1}+f_{i,2} \\
\end{aligned}</script></li>
</ul>
<p>考虑到上述转移均为常系数齐次线性递推形式，故写成矩阵：</p>
<ul>
<li><p>对于非标记点</p>
<script type="math/tex; mode=display">\begin{bmatrix}
f_{i+1,0} \\ f_{i+1,1} \\ f_{i+1,2} \\
\end{bmatrix}
=
\underbrace{\begin{bmatrix}
1&0&1 \\ 2&1&2 \\1&1&2\\
\end{bmatrix}}_{A}
\times
\begin{bmatrix}
f_{i,0} \\ f_{i,1} \\ f_{i,2} \\
\end{bmatrix}</script></li>
<li><p>对于标记点</p>
<script type="math/tex; mode=display">\begin{bmatrix}
f_{i+1,0} \\ f_{i+1,1} \\ f_{i+1,2} \\
\end{bmatrix}
=
\underbrace{\begin{bmatrix}
1&0&0 \\ 2&1&0 \\1&1&1\\
\end{bmatrix}}_{B}
\times
\begin{bmatrix}
f_{i,0} \\ f_{i,1} \\ f_{i,2} \\
\end{bmatrix}</script></li>
</ul>
<p>即有 $N$ 个 $A$ 矩阵连乘，其中 $M$ 个被替换为 $B$ 矩阵，求一向量乘矩阵的结果</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line">	ll a[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">	<span class="built_in">Matrix</span>()&#123; <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span> a);&#125;</span><br><span class="line">	<span class="keyword">friend</span> Matrix <span class="keyword">operator</span> *(<span class="keyword">const</span> Matrix &amp;x,<span class="keyword">const</span> Matrix &amp;y)&#123;</span><br><span class="line">		Matrix res;</span><br><span class="line">		<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;<span class="number">3</span>;++j) <span class="keyword">for</span>(rei k=<span class="number">0</span>;k&lt;<span class="number">3</span>;++k)</span><br><span class="line">			res.a[i][j]+=x.a[i][k]*y.a[k][j];</span><br><span class="line">		<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;<span class="number">3</span>;++j) res.a[i][j]%=mod;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Matrix A,B,ans;</span><br><span class="line">    ans.a[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	A.a[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;A.a[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;A.a[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">	A.a[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">2</span>;A.a[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;A.a[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">	A.a[<span class="number">2</span>][<span class="number">0</span>]=<span class="number">1</span>;A.a[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">1</span>;A.a[<span class="number">2</span>][<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">	B.a[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;B.a[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;B.a[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">	B.a[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">2</span>;B.a[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;B.a[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">	B.a[<span class="number">2</span>][<span class="number">0</span>]=<span class="number">1</span>;B.a[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">1</span>;B.a[<span class="number">2</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    rei pre=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>,v;i&lt;=m;++i)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;v);</span><br><span class="line">        rei stp=v-pre<span class="number">-1</span>;</span><br><span class="line">		Matrix z=A;</span><br><span class="line">        <span class="keyword">for</span>(;stp;stp&gt;&gt;=<span class="number">1</span>,z=z*z) <span class="keyword">if</span>(stp&amp;<span class="number">1</span>) ans=z*ans;</span><br><span class="line">		ans=B*ans;</span><br><span class="line">        pre=v;</span><br><span class="line">	&#125;</span><br><span class="line">    rei stp=n-pre<span class="number">-1</span>;</span><br><span class="line">	Matrix z=A;</span><br><span class="line">    <span class="keyword">for</span>(;stp;stp&gt;&gt;=<span class="number">1</span>,z=z*z) <span class="keyword">if</span>(stp&amp;<span class="number">1</span>) ans=z*ans;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans.a[<span class="number">2</span>][<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>给定一个有 $n$ 个二元组的数组 $(A,B)$ ，数组 $C$ 包含 $n+1$ 个正整数，有 $q$ 个独立操作，每次向 $(A,B)$ 中加入一个二元组，需要：对 $(A,B)$ 中每个二元组选定一个元素 $L_i$ 为该二元组的值，将 $L,C$ 中的数两两匹配，当 $L$ 能匹配 $C$ 当且仅当 $L_i\leq C_i$ ，若成功，获得的分数为第 $1$ 步中取 $A$ 作为值的二元组的数量，对于每个操作，操作后给出最大可能分数，无解 $-1$</p>
</blockquote>
<p>神仙贪心题qwq</p>
<p>为偷懒，将范围从 $1\sim n+1$ 扩展至 $0\sim n$</p>
<p>由于只需要大小关系，考虑将 $C$ 离散化，假设 $C_i=i-1$ ，考虑 $L$ 是否能与 $0\sim n$ 匹配</p>
<p>一个显然的贪心是：排序后若始终有 $L_i\leq i$ 则成立，把匹配看成括号序列，将 $L_i$ 看成左括号权值 $1$， $i$ 看成右括号权值 $-1$ ，合法序列为前缀和处处非负</p>
<p>可以把 $L_i$ 看成对区间 $[L_i,n)$ 的所有数 $+1$ ，即正覆盖 ；$i$ 对区间 $[i,n)$ 所有数 $-1$ ，即负覆盖</p>
<h3 id="先考虑只有一种情况"><a href="#先考虑只有一种情况" class="headerlink" title="先考虑只有一种情况"></a>先考虑只有一种情况</h3><p>对于二元组 $(A_i,B_i)$ 保证 $B_i\leq A_i$</p>
<p>先固定 $L_i=A_i$ ，做正覆盖，而最终的数中若还有负的，就需要最若干次 $[B_i,A_i)$ 的正覆盖来保证合法</p>
<p>问题转化为：</p>
<blockquote>
<p>给定长度为 $n(0\sim n-1)$ 的序列 ，有 $n$ 个区间 $[B_i,A_i)$ 需要做尽可能少的正覆盖使所有数非负，求这个最小值</p>
</blockquote>
<p>从左到右考虑每个 $x_i&lt;0$ ， 设已经完成 $1\sim i-1$ 的部分，即，不需关心区间的左端点，有贪心：<strong>每次选择当前能覆盖 $i$ ，右端点最右的区间进行正覆盖直到 $x_i\geq 0$</strong> ，正确性显然</p>
<p>考虑用堆来维护右端点，$0\sim n-1$ 枚举左端点 $i$ ，填入可行的右端点，不断选择最右的区间覆盖</p>
<p>若最终仍有负数则无解，否则用 $n$ 减去’额外的正覆盖次数’就是答案</p>
<h3 id="再考虑如何处理多组询问"><a href="#再考虑如何处理多组询问" class="headerlink" title="再考虑如何处理多组询问"></a>再考虑如何处理多组询问</h3><p>对于加入的数组 $(D,E)$ ，称<strong>补给正覆盖</strong>为其对原数组的影响</p>
<p>对于询问的数对，枚举其使用的时左/右侧元素以避免动态覆盖</p>
<p>对于询问的数对，选择正覆盖区间 $[\lambda,n)$ ，会转化为原序列中令 $x_\lambda,…,x_{n-1}$ 都 $+1$ 后的原问题</p>
<p>显然，$\lambda$ 越小，正覆盖的次数就越小，即这个区间只能靠补给正覆盖，即原来的区间正覆盖无法使 $x_i$ 非负</p>
<p>覆盖完后设 $i$ 是最小的满足 $x’_i=-1$ ，则显然必须有 $\lambda\leq i$</p>
<p>先前的正覆盖从左至右进行，现在需要从右至左考虑是否能删去一些正覆盖，仅考虑 $i$ 位置做过正覆盖时</p>
<ul>
<li><p>最终 $x’_i=0$</p>
<p>此时 $[i,n]$ 存在补给正覆盖</p>
<p><strong>每个位置至多去掉一个</strong>，只考虑右端点 $r$ 最小(即1最后一次覆盖)的区间能否删去</p>
<p>即，判断 $[i,r)$ 是否有 $0$ 的地方：</p>
<ul>
<li>$x_i’=-1$ ，在补给正覆盖后 $x_i’=0$</li>
<li>枚举到 $i_0$ 时区间被删去一个，从而 $x_{i_0}’=0$</li>
</ul>
<p>所以枚举当前 $x_i’=0$ 的最左位置，与 $r$ 比较，若删除成功更新最左位置</p>
</li>
<li><p>最终 $x_i=-1$</p>
<p>仅更新最左位置</p>
</li>
</ul>
<p>对于每个 $\lambda \in [0,n)$ 求出补给正覆盖为 $[\lambda,n)$ 时额外正覆盖次数最小值 $ans_{\lambda}$</p>
<p>对每个询问 $(D_i,E_i)$ 答案就是 $n-\min\{ans_D,ans_E\}$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,Q;</span><br><span class="line"><span class="keyword">int</span> c[N],C[N],x[N],last[N],ans[N];</span><br><span class="line"><span class="keyword">int</span> cur=<span class="number">0</span>,cov=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">PII a[N];</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">const</span> <span class="keyword">int</span> y)</span></span>&#123; x&gt;y ? x=y : <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pos</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">lower_bound</span>(x,x+n,val)-x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n),++n;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a[i].first,&amp;a[i].second);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x[i]);</span><br><span class="line">	<span class="built_in">sort</span>(x,x+n);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;n;++i) <span class="built_in">down</span>(a[i].second=<span class="built_in">pos</span>(a[i].second),a[i].first=<span class="built_in">pos</span>(a[i].first));</span><br><span class="line">	<span class="built_in">fill</span>(c,c+n,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;n;++i) ++c[a[i].first],<span class="built_in">swap</span>(a[i].first,a[i].second);</span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>,a+n);</span><br><span class="line">	<span class="keyword">for</span>(rei j=<span class="number">1</span>,i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(cur+=c[i];j&lt;n &amp;&amp; a[j].first==i;++j) q.<span class="built_in">emplace</span>(a[j].second);</span><br><span class="line">        rei r=INF;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>() &amp;&amp; q.<span class="built_in">top</span>()&gt;i &amp;&amp; cur&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            r=q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            ++cur,++cov; --c[r];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>() &amp;&amp; q.<span class="built_in">top</span>()&lt;=i) q.<span class="built_in">pop</span>();</span><br><span class="line">		C[i]=cur,last[i]=r;</span><br><span class="line">		<span class="keyword">if</span>(cur &lt; <span class="number">-1</span>)&#123; flag=<span class="literal">true</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;Q);</span><br><span class="line">	<span class="keyword">if</span>(flag)&#123; <span class="keyword">for</span>(;Q;--Q) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    rei j;</span><br><span class="line">	<span class="keyword">for</span>(rei r=n<span class="number">-1</span>,i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i) ~C[i] ? last[i]&lt;=r&amp;&amp;(r=i,--cov) : (r=j=i) ,ans[i]=cov;</span><br><span class="line">	<span class="built_in">memset</span>(ans+(j+<span class="number">1</span>),<span class="number">63</span>,(n-j+<span class="number">5</span>)&lt;&lt;<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        rei d,e,MIN;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;d,&amp;e),MIN=<span class="built_in">min</span>(ans[ <span class="built_in">pos</span>(d) ],ans[ <span class="built_in">pos</span>(e) ]+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,MIN&gt;=INF ? <span class="number">-1</span> : n-MIN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>思维</tag>
        <tag>贪心</tag>
        <tag>dp</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>02801202-AGC014</title>
    <url>/2021/08/20/AGC014/</url>
    <content><![CDATA[<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>$n$ 个顶点的树，初始时每条边为蓝色，执行 $n-1$ 次操作：选定只包含蓝色边的路径 $u\rightarrow v$ ，并移除路径上的某一条蓝边，并加入一条 $u\rightarrow v$ 的红边。问是否能让最终的红树与给定的红树相同</p>
</blockquote>
<p>开始时状态不好考虑，先考虑最后一步操作时：蓝边一定同时存在于蓝树和红树上</p>
<p>可以找到任意一条这样的边，分别在红蓝图上合并两端的点，剩下继续处理子问题</p>
<p>用并查集合并节点，暴力遍历出度数小的点进行启发式合并</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,d[N];</span><br><span class="line">queue&lt;PII&gt; q;</span><br><span class="line">set&lt;<span class="keyword">int</span>&gt; e[N];</span><br><span class="line">map&lt;PII,<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DSU</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> fa[N];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> fa[x]==x ? x : fa[x]=<span class="built_in">find</span>(fa[x]);&#125;</span><br><span class="line">&#125;dsu;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> PII <span class="title">get</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">mk</span>(<span class="built_in">min</span>(x,y),<span class="built_in">max</span>(x,y));&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	e[x].<span class="built_in">insert</span>(y),e[y].<span class="built_in">insert</span>(x);</span><br><span class="line">	PII now=<span class="built_in">get</span>(x,y); ++s[now];</span><br><span class="line">	<span class="keyword">if</span>(s[now]==<span class="number">2</span>) q.<span class="built_in">push</span>(now);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    dsu.<span class="built_in">init</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>,u,v;i&lt;n*<span class="number">2</span><span class="number">-1</span>;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v),<span class="built_in">ins</span>(u,v);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>,x,y;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!q.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>),<span class="number">0</span>;</span><br><span class="line">            PII top=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">			x=dsu.<span class="built_in">find</span>( top.first ),y=dsu.<span class="built_in">find</span>( top.second );</span><br><span class="line">			<span class="keyword">if</span>(x!=y) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(e[x].<span class="built_in">size</span>()&gt;e[y].<span class="built_in">size</span>()) x^=y,y^=x,x^=y;</span><br><span class="line">		dsu.fa[x]=y;</span><br><span class="line">        s.<span class="built_in">erase</span>(<span class="built_in">get</span>(x,y)),e[y].<span class="built_in">erase</span>(x);</span><br><span class="line">		<span class="keyword">for</span>(set&lt;<span class="keyword">int</span>&gt;::iterator it=e[x].<span class="built_in">begin</span>();it!=e[x].<span class="built_in">end</span>();++it)&#123;</span><br><span class="line">			rei t=dsu.<span class="built_in">find</span>(*it);</span><br><span class="line">			<span class="keyword">if</span>(t==y) <span class="keyword">continue</span>;</span><br><span class="line">			s.<span class="built_in">erase</span>(<span class="built_in">get</span>(x,t)); <span class="built_in">ins</span>(t,y);</span><br><span class="line">			e[t].<span class="built_in">erase</span>(x),e[x].<span class="built_in">erase</span>(t);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>给定长度 $n$ 排列 $P$ ，对其进行奇怪排序直至升序：</p>
<p>对于每一轮： 找到序列 $P$ 的所有前缀最大值（ $P_i$ 为前缀最大值当且仅当 $\forall 1\leq j\leq i \quad 有 P_j\leq P_i$），取出所有前缀最大值并按照原顺序移到队尾</p>
<p>求至少需要多少轮才能对 $P$ 排序</p>
</blockquote>
<p>定义 $high$ 为前缀最大值, $low$ 为前缀最小值</p>
<p>假设忽略 $1$ ，用 $T$ 次排列好 $[2,n]$ ，答案就是 $T/T+1$</p>
<p>考虑 $T-1$ 轮后序列状态：设 $f$ 为第一个数，如果 $1$ 出现在 $f,2$ 之间则答案为 $T$ ，否则为 $T-1$</p>
<ul>
<li><p>结论 $1$ : $f$ 不会出现：不在第一个位置且为 $high$ 的情况</p>
<p>反证法易得</p>
</li>
<li><p>结论 $2$ : 定义循环序列 $(a,b,c)=(b,c,a)=(c,a,b)$ ，则 $1,2,f$ 在前 $T-1$ 次组成的，关于位置的循环序列不变</p>
</li>
</ul>
<p>考虑 $[i,n]$ ，设 $T_i$ 为对该序列排序需要的操作数</p>
<p>设 $f_i$ 为 $T_i-1$ 次操作后的第一个整数 ，$q_i$ 为 $i$ 在初始序列中的位置( $p_{q_i}=i$ ) 。按照 $i=n\sim 1$ 的顺序计算 $T_i,f_1$ ，答案就为 $T_1$</p>
<ul>
<li>若 $T_{i+1}=0$<ul>
<li>若 $q_i&gt;q_{i+1}$ ，则 $T_i=1,f_i=i+1$</li>
<li>否则 $T_i=0,f_i无$</li>
</ul>
</li>
<li>否则<ul>
<li>若 $q_{f_{i+1}},q_i,q_{i+1}$ 处于循环顺序，则 $T_i=T_{i+1},f_i=f_{i+1}$</li>
<li>否则 $T_i=T_{i+1}+1,f_i=i+1$</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> q[N],p[N],n,T[N],f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p[i]),q[ p[i] ]=i;</span><br><span class="line">	<span class="keyword">for</span>(rei i=n<span class="number">-1</span>;i;--i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!T[i+<span class="number">1</span>])</span><br><span class="line">			<span class="keyword">if</span>(q[i]&gt;q[i+<span class="number">1</span>]) T[i]=<span class="number">1</span>,f[i]=i+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> T[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			rei cnt=<span class="number">0</span>;</span><br><span class="line">			cnt+=q[ f[i+<span class="number">1</span>] ]&lt;q[i];</span><br><span class="line">			cnt+=q[i]&lt;q[i+<span class="number">1</span>];</span><br><span class="line">			cnt+=q[i+<span class="number">1</span>]&lt;q[ f[i+<span class="number">1</span>] ];</span><br><span class="line">			<span class="keyword">if</span>(cnt==<span class="number">2</span>) T[i]=T[i+<span class="number">1</span>],f[i]=f[i+<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">else</span> T[i]=T[i+<span class="number">1</span>]+<span class="number">1</span>,f[i]=i+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,T[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>思维</tag>
        <tag>贪心</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title>12801202-AGC015</title>
    <url>/2021/08/21/AGC015/</url>
    <content><![CDATA[<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>给定正整数 $A,B \quad (1\leq A,B\leq 2^{60})$ ，令 $S=\{A,A+1,A+2,…,B-1,B\}$ ，求 $S$ 的所有非空子集的元素按位或的结果有多少不同取值</p>
</blockquote>
<p>首先有 $A=B$ 时答案为 $1$</p>
<p>设 $AB$ 最高的不一样的位为第 $b$ 位，则 $A$ 的第 $b$ 位一定为 $0$ ， $B$ 的第 $b$ 位一定是 $1$</p>
<p>考虑比 $b$ 高的那些位，无论取 $S$ 中的哪些数，其比 $b$ 高的位结构相同，或的结果也相同，所以不必考虑这些位，只考虑前 $b$ 位</p>
<p>设 $U$ 在第 $b$ 位为 $0$ ，$b-1\sim 1$ 位为 $1$ ； $V$ 在第 $b$ 位为 $1$ ，$b-1\sim 1$ 位为 $0$</p>
<p>$S$ 子集或的结果有：</p>
<ul>
<li><p>第 $b$ 位为 $0$</p>
<p>只能使用 $A\sim U$ 的元素，设 $T=\{A,A+1,…,U\}$ ，或的结果（或闭包）显然包含 $T$</p>
<p>又由于 $a\mid b\geq \max(a,b)$ 所以或闭包中所有元素均 $\geq A$ ，且 $T$ 中所有数值可能为 $1$ 的位只有 $0,1,…,b-1$ 位，于是结果的每个数中，值为 $1$ 的为是这些位的子集，所以它们 $\leq T$</p>
<p>综上， $T$ 就是 $T$ 的或闭包，共 $|T|$ 个</p>
</li>
<li><p>第 $b$ 位为 $1$</p>
<p>首先，$T\cup \{V\}$ 的或闭包中，考虑第 $b$ 位为 $1$ 的元素，和上面类似可知是 $\{V+A,V+A+1,…,V+U\}=[V+A,2V)$ 而它们的或闭包是 $[V,2V)$ ，即 $\left[2^b,2^{b+1}\right)$ 的子集，于是剩下的元素只有 $[V,V+A)$</p>
<p>考虑「或闭包」在这个区间中的表现</p>
<p><strong>注意此时不能使用 $T$ 中的元素</strong></p>
<p>于是，只需要考虑 $V\sim B$ 中的元素，而这是原问题的一个子问题。从而，我们把 $V$ 和 $B$ 相同的位删掉 —— 即找到 $B$ 中除了 $b$ 外最高为 $1$ 的位，记为 $d$</p>
<p>它们的或闭包就是 $\left[0,2^{d+1}\right)$ ，这部分的贡献就是 $\left[V,V+2^{d+1}\right)$</p>
<p>综上，该部分答案就是 $\left[V,V+2^{d+1}\right)\cup [V+A,2V)$</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> b, d; ll L, R;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">doz</span><span class="params">(ll x)</span></span>&#123; <span class="keyword">return</span> ~(x&gt;&gt;<span class="number">63</span>)&amp;x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;L,&amp;R);</span><br><span class="line">	<span class="keyword">if</span>(L==R) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>),<span class="number">0</span>;</span><br><span class="line">	b=__lg(L^R),L&amp;=~(<span class="number">-2ll</span>&lt;&lt;b),R&amp;=~(<span class="number">-1ll</span>&lt;&lt;b),d=R ? __lg(R)+<span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(<span class="number">2ll</span>&lt;&lt;b)-L-<span class="built_in">doz</span>(L-(<span class="number">1ll</span>&lt;&lt;d)));</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>数轴上有 $N$ 个点，每个点初始时在位置 $X_i$ ，以 $V_i$ 的速度向数轴正方向前进。 初始时刻，选择一些点为其染色，之后的行走过程中，染色的点会将其碰到的所有点都染上色，之后被染上色的点亦是如。此<br>在所有 $2^N$ 种初始染色方案中，问有多少种初始染色方案，能使得最终所有的点都被染色</p>
</blockquote>
<p>按 $x_i$ 将所有点排序，第 $i$ 个点被选中后，对于 $j<i且v_j>v_i 和 j&gt;i且v_j<v_i$ 的点会被直接打上标记，而对于 $j>i,v_j\leq \max_{k\leq i} v_k$ 的点都会被间接打上标记</p>
<p>考虑初始时最靠右的标记点 $i$ ，由于 $i$ 对右侧影响最强，故点 $j,j&lt;i$ 被打标记当且仅当 $v_j\max{k\leq i} \ v_k$ 。只需要确保 $[1,i-1]$ 的点使 $j&lt;i,v_j&lt;\min_{k\geq i} \ v_k$ 的点都被打标记</p>
<p>设 $f_i$ 表示操纵 $[1,i-1]$ 的点使 $j&lt;i ,v_j&lt;\min_{k\geq i} \ v_k$ 的点都被打标记的方案数， 设 $j$ 是初始时 $[1,i-1]$ 内最靠右被打上标记的点，满足 $\max_{j&lt;k&lt;i\ ,\ v_k&lt;\min_{t\geq i}\ v_t} \ v_k&lt;\max_{1\leq k\leq j} \ v_k$</p>
<p>考虑用 $f_j$ 转移：合法的 $j$ 是一段右端点为 $i$ 的区间，考虑左端点：设 $mx$ 表示最大的 $mx$ 满足 $mx&lt;i,v_{mx}&lt;\min_{t\leq i} \ v_t$ 的 $v_{mx}$</p>
<p>对于 $v_{mx}$ 可以作为 $j$ 左侧只需要考虑 $\max_{1\leq k\leq j} \ v_k&gt;v_{mx}$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>,INF=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> x,<span class="keyword">const</span> <span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">return</span> x+y&lt;mod ? x+y : x+y-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dec</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> x,<span class="keyword">const</span> <span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">return</span> x&lt;y ? x-y+mod : x-y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,f[N],sf[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,v;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node &amp;a,<span class="keyword">const</span> node &amp;b)&#123; <span class="keyword">return</span> a.x&lt;b.x;&#125;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="keyword">int</span> id[N];</span><br><span class="line"><span class="keyword">int</span> premn[N],sufmn[N],premx[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">return</span> a[x].v&lt;a[y].v;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a[i].x,&amp;a[i].v);</span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">	premn[<span class="number">0</span>]=sufmn[n+<span class="number">1</span>]=INF;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) premn[i]=<span class="built_in">min</span>(premn[i<span class="number">-1</span>],a[i].v);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) premx[i]=<span class="built_in">max</span>(premx[i<span class="number">-1</span>],a[i].v);</span><br><span class="line">	<span class="keyword">for</span>(rei i=n;i&gt;=<span class="number">1</span>;--i) sufmn[i]=<span class="built_in">min</span>(sufmn[i+<span class="number">1</span>],a[i].v);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) id[i]=i;</span><br><span class="line">	<span class="built_in">sort</span>(id+<span class="number">1</span>,id+n+<span class="number">1</span>,cmp);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>,j=<span class="number">1</span>,p1=<span class="number">0</span>,p2=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i!=<span class="number">1</span>) <span class="keyword">if</span>(a[i<span class="number">-1</span>].v&lt;sufmn[i]) <span class="keyword">if</span>(!p1 || a[i<span class="number">-1</span>].v&gt;a[p1].v) p1=i<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">while</span>(j&lt;=n &amp;&amp; a[ id[j] ].v&lt;sufmn[i])&#123;</span><br><span class="line">			<span class="keyword">if</span>(id[j]&lt;i) <span class="keyword">if</span>(!p1||a[ id[j] ].v&gt;a[p1].v) p1=id[j];</span><br><span class="line">			++j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(p2&lt;=n &amp;&amp; a[p2].v&lt;a[p1].v) ++p2;</span><br><span class="line">		<span class="keyword">if</span>(p1)&#123;</span><br><span class="line">			rei p=<span class="built_in">min</span>(p2,p1);</span><br><span class="line">			f[i]=<span class="built_in">dec</span>(sf[i<span class="number">-1</span>],sf[p<span class="number">-1</span>]);</span><br><span class="line">			sf[i]=<span class="built_in">add</span>(sf[i<span class="number">-1</span>],f[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> f[i]=<span class="built_in">add</span>(sf[i<span class="number">-1</span>],<span class="number">1</span>);</span><br><span class="line">		sf[i]=<span class="built_in">add</span>(sf[i<span class="number">-1</span>],f[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[n+<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>定义 $E(x,y)$ 是对 $x,y$ 进行 $\text{Euclid}$ 算法需要的步数。其中 $E(a,b)=E(b,a) \forall a,b\in \N$ ; $E(0,a)=0$ ; 若 $0&lt;a\leq b$ ，则 $E(a,b)=E(b\mod a,a)+1$ 。 有多次询问，每次给定 $x,y\in \N^+$ 求出 $\displaystyle{M=\max_{1\leq x\leq X} \max_{1\leq y\leq Y} E(x,y)}$ 以及 $\displaystyle{C_M=\sum_{x=1}^X\sum_{y=1}^Y [E(x,y)=M]}$</p>
</blockquote>
<p>只会打表找结论，具体的数学过程参见yhx的博客</p>
<ul>
<li><p>结论 $1$ :</p>
<p>$f(Fib(x),Fib(x+1))=x$ ，且不存在 $i,j \forall i,j\in \N 使 f(i,j)\geq x,i&lt;Fib(x),j&lt;Fib(x+1)$</p>
</li>
<li><p>结论 $2$ :<br>定义一个二元组 $(x,y)$ 是好的，当且仅当 不存在 $(i,j)$ 满足 $i<x,j<y,f(i,j)>f(x,y)$</p>
<p>一个二元组 $(x,y)$ 是优秀的，当且仅当 $x,y\leq Fib(v+2)+Fib(v-1)$ ，其中 $v=f(x,y)$</p>
<p>那么：<strong>一个好的二元组进行一次 $\text{Euclid}$ 后一定变为一个优秀二元组</strong>，反证法易得</p>
</li>
</ul>
<p>预处理所有优秀二元组就好qwq</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;PII&gt; t[N];</span><br><span class="line"><span class="keyword">int</span> n,m,q,f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    t[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="built_in">mk</span>(<span class="number">1</span>,<span class="number">2</span>)),t[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="built_in">mk</span>(<span class="number">1</span>,<span class="number">3</span>)),t[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="built_in">mk</span>(<span class="number">1</span>,<span class="number">4</span>));</span><br><span class="line">    f[<span class="number">0</span>]=f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;=<span class="number">100</span>;++i) f[i]=f[i<span class="number">-1</span>]+f[i<span class="number">-2</span>];</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;++i)</span><br><span class="line">        <span class="keyword">for</span>(rei j=<span class="number">0</span>,l=t[i].<span class="built_in">size</span>()<span class="number">-1</span>;j&lt;=l;++j)&#123;</span><br><span class="line">            rei x=t[i][j].second,y=t[i][j].first+x;</span><br><span class="line">            <span class="keyword">while</span>(y&lt;=f[i+<span class="number">3</span>]+f[i]) t[i+<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="built_in">mk</span>(x,y)),y+=x;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;m); <span class="keyword">if</span>(n&gt;m) n^=m,m^=n,n^=m;</span><br><span class="line">        rei pos=<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(f[pos+<span class="number">1</span>]&lt;=n &amp;&amp; f[pos+<span class="number">2</span>]&lt;=m) ++pos;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,pos);</span><br><span class="line">        <span class="keyword">if</span>(pos==<span class="number">1</span>)&#123; <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n%mod*m%mod); <span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">for</span>(rei j=<span class="number">0</span>,l=t[pos<span class="number">-1</span>].<span class="built_in">size</span>()<span class="number">-1</span>;j&lt;=l;++j)&#123;</span><br><span class="line">            rei x=t[pos<span class="number">-1</span>] [j].first,y=t[pos<span class="number">-1</span>][j].second;</span><br><span class="line">            <span class="keyword">if</span>(y&lt;=n) ans=(ans+(m-x)/y)%mod;</span><br><span class="line">            <span class="keyword">if</span>(y&lt;=m) ans=(ans+(n-x)/y)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>思维</tag>
        <tag>dp</tag>
        <tag>数论</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>32801202-AGC016</title>
    <url>/2021/08/23/AGC016/</url>
    <content><![CDATA[<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>给定一序列 $a$ ，每次操作可以使指定位置的数变成整个序列的异或和，求达到目标序列的最少次数</p>
</blockquote>
<p>设初始时异或和为 $x$ ，转化为每次将 $a_i$ 变为 $x$ 并将 $a_i$ 拿在手上下一次替换</p>
<p>显然有解当且仅当 $a\cup \{x\} \in b$</p>
<p>再考虑替换的过程，<strong>最后一定要用 $b_i$ 替换掉 $a_i$ ，这启发连边 $b_i\rightarrow a_i$ ，再从 $x$ 开始遍历每一条边</strong></p>
<p>如果图是一个包含 $x$ 的连通块，则一定有一条 $1$ 欧拉路径覆盖所有边</p>
<p>如果不连通，或 $x$ 是孤立点/不在连通块内，则答案就是 $边数+连通块数-(x不是孤立点)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],b[N],x;</span><br><span class="line"><span class="keyword">int</span> cnt,edge_cnt,block_cnt;</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line">map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	vis[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> y:G[x]) <span class="keyword">if</span> (!vis[y]) <span class="built_in">dfs</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]),++mp[ a[i] ],x^=a[i];</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]),--mp[ b[i] ];</span><br><span class="line">    ++mp[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it:mp) <span class="keyword">if</span>(it.second&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>),<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;it:mp) it.second=++cnt;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span>(a[i]!=b[i])&#123;</span><br><span class="line">            rei u=mp[ b[i] ],v=mp[ a[i] ];</span><br><span class="line">            G[u].<span class="built_in">push_back</span>(v),G[v].<span class="built_in">push_back</span>(u); ++edge_cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=cnt;++i) <span class="keyword">if</span>(G[i].<span class="built_in">size</span>()) <span class="keyword">if</span>(!vis[i]) ++block_cnt,<span class="built_in">dfs</span>(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,edge_cnt+block_cnt-(!G[ mp[x] ].<span class="built_in">empty</span>()));</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>$2\leq N\leq 400$ 只火鸡， $m$ 个人，每人指定两只火鸡2 $x,y$ ，若两只都活着，则会等概率随机吃掉一只；若只活着一只，则悲吃掉；若都死亡则不做操作。第 $1$ 个人到第 $m$ 个人依次操作，求有多少 $(i,j)$ 满足最终时刻 $i,j$ 可能都活着</p>
</blockquote>
<p>考虑如何使 $i$ 存活：第 $I$ 人选中 $i,j$ 只，则必须让 $j$ 死亡 ，则在第 $1\sim I-1$ 中第 $j$ 只不能死亡</p>
<p>而如果选择了 $(i,j),(i,k)$ 则如果前面的人选择 $(j,k)$ ，则第 $i$ 只必死</p>
<p>对于第 $i$ 只，设 $S_i$ 表示为了使 $i$ 存活需要保护的鸡的编号，从后往前扫到 $(x,y)$ ：</p>
<ul>
<li>初始时 $S_i=\{i\}$</li>
<li>不妨设 $x\in S_i , y\notin S_i$ ，则将 $y$ 加入 $S_i$</li>
<li>若 $x,y\in S_i$ ，则 $i$ 一定会死亡</li>
</ul>
<p>再考虑鸡 $(i,j)$ 的存活：枚举 $i,j$ 并判断 $S_i\cap S_j$ 是否为空</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,ans,x[N],y[N],dead[N];</span><br><span class="line">bitset&lt;410&gt; f[<span class="number">401</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=m;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x[i],&amp;y[i]);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		f[i][i]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(rei j=m;j;--j)&#123;</span><br><span class="line">			rei u=f[i][ x[j] ],v=f[i][ y[j] ];</span><br><span class="line">            u&amp;&amp;v ? dead[i]=<span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">			u ? f[i][ y[j] ]=<span class="number">1</span> : (v ? f[i][ x[j] ]=<span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(dead[i]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span>(rei j=i+<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dead[j]) <span class="keyword">continue</span>;</span><br><span class="line">			ans+=!((f[i]&amp;f[j]).<span class="built_in">count</span>());</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>42801202-AGC017</title>
    <url>/2021/08/24/AGC017/</url>
    <content><![CDATA[<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>一个 $N$ 节点的树，两人轮流选择一条树上的边并断开，删除不包含 $1$ 号点的连通块，当一人不能操作时输，求胜者</p>
</blockquote>
<p>树上 $\text{nim}$ 游戏，每个节点的 $\text{sg}$ 值是所有儿子 $\text{sg}$ 值 $+1$ 的异或和，判断根节点 $\text{sg}$ 函数值是否为 $1$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa=<span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    rei res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y:G[x]) <span class="keyword">if</span>(y!=fa) res^=<span class="built_in">dfs</span>(y,x)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,u,v;i&lt;n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v),G[u].<span class="built_in">push_back</span>(v),G[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="built_in">dfs</span>(<span class="number">1</span>) ? <span class="string">&quot;Alice&quot;</span> : <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>有 $n$ 块不规则拼图，每块拼图看成连接在一起的三个宽度为 $1$ 的矩形，如图<img src="https://atcoder.jp/img/agc017/2b6cd7f4500d3621bc18de407f167522.png" alt="https://atcoder.jp/img/agc017/2b6cd7f4500d3621bc18de407f167522.png"><br>具体地，其中中间的矩形的高度为 $H$ ，左侧矩形的高度为 $A_i$ ，距离中间矩形底部 $C_i$ ，右侧矩形的高度为 $B_i$ ，距离中间矩形底部 $D_i$<br>将这些拼图放入一个边长为 $10^{100}$<br> 的正方形中，需要满足如下条件：</p>
<ul>
<li><p>所有 $N$ 块拼图都必须用上</p>
</li>
<li><p>所有拼图的中间矩形的下底面需要和正方形的下底面对齐</p>
</li>
<li><p>对于非中间的部分的下底面，要么和正方形的下底面对齐，要么和另一块拼图的非中间部分的上顶面对齐</p>
</li>
<li><p>拼图只能平移，不能旋转或翻转</p>
</li>
</ul>
</blockquote>
<p>对于一块拼图，如果其一侧的小矩形不接地，那么这个小矩形一定与另一拼图接地的小矩形相接，即，其高度无关紧要，只关心非 “接地” 小矩形的 $C_i,D_i$</p>
<p>而对于接地的小矩形有 $C_i=0 / D_i=0$ ，此时需要关注高度</p>
<p>于是，对于每块拼图的一侧，我们可以给它对应到个参数：如果是接地的，称它是 $下A_i$ 或 $下B_i$ ，否则，称它为 $上C_i$或 $上D_i$</p>
<p>显然有： $上x$ 的一侧与某矩形 $下x$ 相接，且最两端矩形的两侧是 $下x$</p>
<p>考虑到 $上下x$ 相连没有什么好性质，不妨利用左右矩形：对于左侧小矩形，点 $N_x$ 表示 $上x$ ，点 $P_x$ 表示 $下x$ ；右侧矩形则相反，点 $P_x$ 表示 $上x$ ，点 $N_x$ 表示 $下x$</p>
<p>两个拼图的连接处就是相同的点：全为 $P_x$ 或全为 $N_x$</p>
<p>那么，对于拼图 $(u,v)$ 连接 $u\rightarrow v$ ，那么一连串拼图构成的组对应所得的图上的一条有向边，且路径起点为 $P_x$ ，终点为 $N_x$</p>
<p>那么转化为<strong>判断整张图是否能被拆分成若干个从 $P_x$ 连向 $N_x$ 的有向路径即可</strong></p>
<p>考虑建立超级点 $S$ ，能向所有形如 $P_x$ 的点不断提供入边，也能使足够多的 $N_x$ 连向它</p>
<p>那么对于路径 $P_x\rightarrow v_1\rightarrow v_2\rightarrow …\rightarrow N_y$ ，在两侧分别补上 $N_y\rightarrow S$ 和 $S\rightarrow P_x$ ，如此得到一个有向圈</p>
<p>那么在连接若干条与 $S$ 的边后，图 $G$ 将变为 $\text{Euler}$ 图</p>
<p>考虑到 $\text{Euler}$ 图的性质: $\forall v\in G , 有 d^+(v)=d^-(v)$</p>
<p>由此：在删去 $S$ 及其关联的边后， $\forall P_x\in G , 有d^-(P_x)\leq d^+(P_x)$ ，$\forall N_x\in G , 有d^-(N_x)\geq d^+(N_x)$</p>
<p>首先，如果一张图满足上述条件，那么我们将 $S$ 点与若干个点连边后，可以得到一张 $\text{Euler}$ 图 (且这个方案事实上是唯一的，即我们可以算出 $S$ 该向每个点连多少条边)。</p>
<p>其次，由 $\text{Euler}$ 图的性质，可得到 $S$ 的若干条 $\text{Euler}$ 回路 (这里用若干的原因是 $G$ 不一定连通)。</p>
<p>那么，考虑其中的每个圈 (注意与回路的区别)：</p>
<ul>
<li><p>如果它经过 $S$ ，那么将 $S$ 点去掉后，就得到一个可行的路径。</p>
</li>
<li><p>如果这个圈不经过点 $S$</p>
<p>那么，如果这个圈可以和一个包含 $S$ 点的圈合并，得到一个大的回路，那么这个回路也满足条件，即，边不重复。于是，希望这些圈尽可能地进行合并</p>
<p>所以，考虑最终得到的每个图的连通分量 ($\text{Euler}$ 图的强连通性保证这里的强连通分量和弱连通分量是同一个)，如果存在一个不包含 $S$ 的连通分量，则问题是无解的 —— 因为这个圈/回路不包含 $S$ ，从而不可能找到一条对应的路径经过 $S$ 和圈/回路中所有的边。</p>
<p>而反之，如果所有连通分量都包含 $S$ (从而只有一个连通分量)，那么问题就是有解的了。</p>
</li>
</ul>
<p>于是，我们使用并查集维护一下连通性就可以了。注意到，在满足性质的条件下，一个点和 $S$ 相连当且仅当它的入度和出度不相等。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">410</span>;</span><br><span class="line"><span class="keyword">int</span> n,H,V;</span><br><span class="line"><span class="keyword">int</span> fa[N],in[N],out[N];</span><br><span class="line"><span class="keyword">bool</span> dicyc[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_anc</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x ? x : fa[x]=<span class="built_in">get_anc</span>(fa[x]);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> Lu,Ld,Ru,Rd,L,R;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;H); V=H&lt;&lt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">iota</span>(fa,fa+V,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;Lu,&amp;Ru,&amp;Ld,&amp;Rd);</span><br><span class="line">		++out[ L=(Ld ? Ld+H : Lu)<span class="number">-1</span> ];</span><br><span class="line">        ++in[ R=(Rd ? Rd : Ru+H)<span class="number">-1</span> ];</span><br><span class="line">		fa[ <span class="built_in">get_anc</span>(L) ]=<span class="built_in">get_anc</span>(R);</span><br><span class="line">    &#125;</span><br><span class="line">	rei i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;H &amp;&amp; in[i]&lt;=out[i] &amp;&amp; in[i+H]&gt;=out[i+H];++i);</span><br><span class="line">	<span class="keyword">if</span>(i!=H) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>),<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;V;++i) dicyc[ <span class="built_in">get_anc</span>(i) ] |= in[i]!=out[i] || !in[i];</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;V &amp;&amp; (fa[i]!=i || dicyc[i]);++i);</span><br><span class="line">    <span class="built_in">puts</span>(i==V ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>你有一个由 $\frac{n(n+1)}{2}$ 个点组成的等边三角形。 在 $(i,j)$ 点左下的是 $(i+1,j)$ 点， 右下的是 $(i+1,j+1)$ 点. 现在在上面画 $m$ 条从 $(1,1)$ 开始，$(n,p)$ 结束的连续路径 $(p\in[1,n])$ ， 满足对于任意 $1\leq i\leq j\leq m$, 第 $j$ 条线的任意一个部分不在第 $i$ 条线的左边。<br><img src="https://atcoder.jp/img/agc017/8d354fb1a389a0aa5b64ba93f6ca7801.png" alt="https://atcoder.jp/img/agc017/8d354fb1a389a0aa5b64ba93f6ca7801.png"><br>另外，还有 $k$ 个限制 , 第 $i$ 个限制形如 $A_i,B_i,C_i$ ，表示第 $A_i$ 条路径， 在第 $B_i$ 次决策的时候， 如果 $C_i=0$ ​则必须走左下， 否则必须走右下。</p>
<p>求出一共有多少种不同的画路径的方案满足以上的要求。</p>
</blockquote>
<p>有一个朴素状压 $\text{dp}$ ，用 $O(m\times 4^n)$ 直接枚举状态转移</p>
<p>而直接枚举状态显然多余考虑了很多不合法状态</p>
<p>有神仙思路如下：</p>
<p>设 $0$ 为向左走，$1$ 为向右走，不考虑方向的限制，合法转移后的状态一定满足任何一个前缀 $1$ 的个数都大于之前状态前缀 $1$ 的个数</p>
<p>那么设 $dp_{i,j,k}$ 表示第 $i$ 条路径的第 $j$ 条转移，转移状态的前 $j$ 位与 $k$ 相同，考虑向右的情况：直接把后面的第一个 $1$ 变为 $0$ ，然后提到前面，如此，中间段取 $1/0$ 都满足要求，不会向左越过原来的，总复杂度 $O(n\times m\times 2^n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">21</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k,all,last=<span class="number">1</span>,cur,ans;</span><br><span class="line"><span class="keyword">int</span> dir[N][N],dp[<span class="number">2</span>][<span class="number">1</span>&lt;&lt;N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fix</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123; x&gt;=mod ? x-=mod : <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x&amp;(-x);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);--n;</span><br><span class="line">	all=(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>,x,y,foo;i&lt;=k;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;foo),dir[x][y<span class="number">-1</span>]=foo+<span class="number">1</span>;</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=m;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">		<span class="built_in">swap</span>(last,cur);</span><br><span class="line">		rei foo=<span class="number">1</span>&lt;&lt;j,bar=all^((foo&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">for</span>(rei s=<span class="number">0</span>;s&lt;=all;++s) dp[cur][s]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(rei s=<span class="number">0</span>;s&lt;=all;++s)&#123;</span><br><span class="line">			<span class="keyword">if</span>(dp[last][s])&#123;</span><br><span class="line">				<span class="keyword">if</span>(dir[i][j]!=<span class="number">2</span> &amp;&amp; (!(foo&amp;s))) <span class="built_in">fix</span>(dp[cur][s]+=dp[last][s]);<span class="comment">//左</span></span><br><span class="line">				<span class="keyword">if</span>(dir[i][j]!=<span class="number">1</span>)&#123;<span class="comment">//右</span></span><br><span class="line">					rei x;</span><br><span class="line">					<span class="keyword">if</span>(foo&amp;s) x=s;<span class="comment">//必须右</span></span><br><span class="line">					<span class="keyword">else</span>&#123;</span><br><span class="line">						<span class="keyword">if</span>(!(bar&amp;s)) x=s|foo;</span><br><span class="line">						<span class="keyword">else</span> x=(s|foo)^<span class="built_in">lowbit</span>(bar&amp;s);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="built_in">fix</span>(dp[cur][x]+=dp[last][s]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;=all;++i) <span class="built_in">fix</span>(ans+=dp[cur][i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>思维</tag>
        <tag>dp</tag>
        <tag>博弈论</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>52801202-AGC018</title>
    <url>/2021/08/25/AGC018/</url>
    <content><![CDATA[<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>有一颗 $N$ 个顶点的树，顶点依次标号 $1\sim N$ ，第 $i$ 条边连接着顶点 $A_i$ 和 $B_i$ ，且第 $i$ 条边的长度为  $C_i$ 。有一张 $N$ 个点的完全图，图上两点之间的边的边权为它们在树上的距离。求最长 $\text{Hamilton}$ 路径（即不重不漏恰好经过每个点一次）。</p>
</blockquote>
<p>求 $\text{Hamilton}$ 路径转化为求 $\text{Hamilton}$ 回路再减去一条路径</p>
<ul>
<li><p>对于 $\text{Hamilton}$ 回路，有一个结论：对于每一个边，把它断开后树分成了连通块 $x,y$ ，则有 $\min(x,y)$ 条路径通过该边</p>
</li>
<li><p>对于减掉的那条路径：</p>
<p><strong>需要发现：不经过重心的路径都不会被包含在任意最优解中</strong></p>
<p>那么每一条路径都是在重心的两个不同子树中各任取一点相连，于是，当重心为点时，删去以重心为端点的最短的一条边，重心为边时，删去那条边</p>
</li>
</ul>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>给定平面上三个矩形：$[X_1,X_2]\times [Y_1,Y_2] ; [X_3,X_4]\times [Y_3,Y_4] ; [X_5,X_6]\times [Y_5,Y_6]$ ，在三个矩形中各选一个整点 $A,B,C$ ，再选择一条 $A\rightarrow B$ 的 $HV$ 格路以及 $B\rightarrow C$ 的 $HV$ 格路 ，求方案数</p>
</blockquote>
<p>先考虑只有两个矩形，统计 $A\rightarrow C$ 的 $HV$ 格路数：</p>
<script type="math/tex; mode=display">\sum_{i=X_1}^{X_2} \sum_{j=Y_1}^{Y_2} \sum_{u=X_5}^{X_6} \sum_{v=Y_5}^{Y_6} \binom {u-i+v-j} {u-i}</script><p>固定 $i,j,u$ 能进行上指标求和：</p>
<script type="math/tex; mode=display">\sum_{v=Y_5}^{Y_6} \binom {u-i+v-j} {u-i} = \binom {u-i+\left( Y_6+1 \right)-j} {u-i}-\binom {u-i+Y_5-j} {u-i}</script><p>同理，对其他三个均进行上指标求和，得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=X_1}^{X_2} \sum_{j=Y_1}^{Y_2} \sum_{u=X_5}^{X_6} \sum_{v=Y_5}^{Y_6} \binom {u-i+v-j} {u-i} &= \binom {\left( X_6+1 \right)-\left( X_1-1 \right)+\left( Y_6+1 \right)-\left( Y_1-1 \right)} {\left( X_6+1 \right)-\left( X_1-1 \right)} +\binom {\left( X_6+1 \right)-\left( X_1-1 \right)+Y_5-\left( Y_1-1 \right)} {\left( X_6+1 \right)-\left( X_1-1 \right)} +\binom {X_5-\left( X_1-1 \right)+\left( Y_6+1 \right)-\left( Y_1-1 \right)} {X_5-\left( X_1-1 \right)} +\binom {X_5-\left( X_1-1 \right)+Y_5-\left( Y_1-1 \right)} {X_5-\left( X_1-1 \right)} \\ &- \binom {\left( X_6+1 \right)-\left( X_1-1 \right)+\left( Y_6+1 \right)-Y_2} {\left( X_6+1 \right)-\left( X_1-1 \right)} + \binom {\left( X_6+1 \right)-\left( X_1-1 \right)+Y_5-Y_2} {\left( X_6+1 \right)-\left( X_1-1 \right)} + \binom {X_5-\left( X_1-1 \right)+\left( Y_6+1 \right)-Y_2} {X_5-\left( X_1-1 \right)}- \binom {X_5-\left( X_1-1 \right)+Y_5-Y_2} {X_5-\left( X_1-1 \right)} \\  &- \binom {\left( X_6+1 \right)-X_2+\left( Y_6+1 \right)-\left( Y_1-1 \right)} {\left( X_6+1 \right)-X_2} + \binom {\left( X_6+1 \right)-X_2+Y_5-\left( Y_1-1 \right)} {\left( X_6+1 \right)-X_2} + \binom {X_5-X_2+\left( Y_6+1 \right)-\left( Y_1-1 \right)} {X_5-X_2} - \binom {X_5-X_2+Y_5-\left( Y_1-1 \right)} {X_5-X_2} \\  &+ \binom {\left( X_6+1 \right)-X_2+\left( Y_6+1 \right)-Y_2} {\left( X_6+1 \right)-X_2} - \binom {\left( X_6+1 \right)-X_2+Y_5-Y_2} {\left( X_6+1 \right)-X_2} -\binom {X_5-X_2+\left( Y_6+1 \right)-Y_2} {X_5-X_2}+\binom {X_5-X_2+Y_5-Y_2} {X_5-X_2}
\end{aligned}</script><p>再考虑三个矩形：</p>
<p>假设固定了 $(x,y)\in [X_3,X_4]\times [Y_3,Y_4]$ ，那么只需对左下和右上方的矩形分别做一个二维部分和，同上转化出四个二项式系数</p>
<p>将问题看成：左下角的矩形集合可以等价于 $4$ 个 (带权的) 点，每个点有系数 $±1$ ，同理，右上角的矩形也可以等价于 $4$ 个 (带权的) 点，每个点有系数 $±1$</p>
<p>由此，原问题转化为 $16$ 个问题：给定起点 $(x_L,y_L)$<br>，终点 $(x_R,y_R)$ 和一个中途矩形 $[x_3,x_4]\times [y_3,y_4]$ ，求有多少种方案在中途矩形中选择点 $P$ ，以及一条 $(x_L,y_L)\rightarrow P$ 的 $HV$ 格路和一条 $P\rightarrow (x_R,y_R)$ 的 $HV$ 格路</p>
<p>首先考虑经过矩形 $[x_3,x_4]\times [y_3,y_4]$ 的格路数量：注意到任何一条经过某个矩形的格路至少经过这 $(x_4-x_3+1)+(y_4-y_3+1)$ 条边之一</p>
<p>那么枚举经过的这条边，后计算该边终点到 $(x_R,y_R)$ 的 $HV$ 格路数</p>
<p>而需要经过矩形中特定点的格路数，那么对于经过矩形的每一条格路，经过矩形内 $c$ 个点就会对最终方案数贡献 $c$</p>
<p>转化为求每条经过中途矩形的格路在中途矩形内长度之和：设到达时坐标 $(x_a,y_a)$ ，离开时 $(x_b,y_b)$ ，该格路在中途矩形内的长度就是 $(x_b-x_a)+(y_b-y_a)+1$</p>
<p>由于枚举起点终点，对上式求和会达到无法接受的 $O(n^2)$</p>
<p><strong>这里考虑用分离变量</strong>：即，把 $(x_b-x_a)+(y_b-y_a)+1$ 拆成 $(x_b+y_b+1)-(x_a+y_a)$ ，然后在起点终点处分别统计并将贡献相加即可</p>
<p>再把该子问题做 $16$ 遍就好了</p>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>给定两个 $n$ 个点的树，给每个点赋值满足两棵树上均有任意节点子树权值和为 $1/-1$</p>
</blockquote>
<ul>
<li><p>先考虑一棵树情况</p>
<p>直接从叶子往上构造。但为便于推广，找出一个等价过程</p>
<p>由于一个子树对父亲的 $Size$ 的贡献只有 $1/-1$ ，所以考虑给树边定向：儿子指向父亲代表贡献为 $1$ ，反过来代表贡献为 $-1$</p>
<p>由于整个树的权值和也为 $1$ 或 $-1$ ，所以新建一个根 $0$ ，然后 $0$ 连向当前根，对 $0$ 点的定向就是整棵树的贡献</p>
<p>由此：先给所有边定向(随机即可)，对于一条儿子指向父亲的边，把儿子 $+1$ ，父亲 $-1$ ，这样只有以儿子为根的一个子树的大小改变，反之同理</p>
<p>实际上就是定向完后，$a_i=out_i-in_i$</p>
</li>
<li><p>两棵树</p>
<p>考虑此时如何保证对两棵树定向后的 $a_i=b_i$ ，考虑再加一些边</p>
<p>首先，如果两棵树上某个标号对应的两个点的度数奇偶性不一样，那么一定无解</p>
<p>其次，如果度数为奇数，就把这两个点连起来</p>
<p>这样得到的新图满足，连通（两个 $0$ 节点之间一定有连边），而且所有点度数均为偶数，即，存在欧拉回路</p>
<p>由欧拉回路的性质，对任意点 $in=out$</p>
<p>那么如果按照欧拉回路去定向，每个点的点权就都为 $0$ ，那么显然相等</p>
</li>
</ul>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>思维</tag>
        <tag>贪心</tag>
        <tag>图论</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>62801202-AGC019</title>
    <url>/2021/08/26/AGC019/</url>
    <content><![CDATA[<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>给定两个长度为 $n(1\leq n\leq 2000)$ 的 $0/1$ 串，对 $A$ 执行任意次一下操作的任意一种：</p>
<ul>
<li>将 $A$ 左移一位，即 $A\leftarrow A_2A_3…A_nA_1$</li>
<li>将 $A$ 右移一位，即 $A\leftarrow A_nA_1AA_2…A_{n-1}$</li>
<li>选择任意 $i$ 满足 $B_i=1$ ，令 $A_i=1-A_i$</li>
</ul>
<p>求最少需要多少次操作</p>
</blockquote>
<p>首先当 $A$ 有 $1$ ，$B$ 没有 $1$ 那么一定无解。当 $A,B$ 均没有 $1$ 时代价为 $0$</p>
<p>其余情况 $B$ 中一定有 $1$ ，将$A$的环状移动用将 $B$ 左右倍长为 $3$ 倍，$A$ 直接左右移动。</p>
<p>对于 $A$ 中每一个位置 $i$ ，预处理每一个 $i$ 需要向左向右最少移动多少步才能使得 $A_i$ 对应了一个 $B_j$ 使得 $B_j=1$ ，记为 $L_i,R_i$</p>
<p>其次，考虑暴力枚举最终 $A$ 在与原来的相对位置与 $B$ 对应，假设 $A$ 与原来的位置相对向右移动了 $k$ 个，然后对于每一个 $A_i \not = B_{i+k}$ ，我们至少将 $A$ 左移 $L_i$ 位或右移 $R_i$</p>
<p>假设我们最终要向右移动 $k$ 位与 $B$ 对应，考虑枚举先向左走了 $x$ 步，那么对于所有 $L_i\leq x$ 对答案无影响了，只需要统计对 $L_i&gt;x$ 的 $R_i$ 最大值(记为 $RS$ )，即先向左移 $x$ 步再移回来，再向右移到 $RS$ ，最后移到 $k$ 最优</p>
<p>过程中要对每一个 $A_i \not = B_{i+k}$ 的进行一步操作，记为 $m$ 个，用 $2x+RS+|RS-k|+m$ 来更新答案。</p>
<p>将 $A$ 向左移动同理。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">8e3</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">char</span> s1[N],s2[N];</span><br><span class="line"><span class="keyword">int</span> n,m,p[N],t[N],L[N],R[N];</span><br><span class="line"><span class="keyword">int</span> pre[N],suf[N],ls[N],rs[N],ct1,ct2,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">return</span> L[x]&gt;L[y] || (L[x]==L[y] &amp;&amp; R[x]&lt;R[y]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> tar,<span class="keyword">int</span> hd,<span class="keyword">int</span> rev,<span class="keyword">int</span> con)</span></span>&#123;</span><br><span class="line">	tar&gt;=hd ? ans=<span class="built_in">min</span>(ans,rev*<span class="number">2</span>+tar+con) : ans=<span class="built_in">min</span>(ans,rev*<span class="number">2</span>+(hd*<span class="number">2</span>-tar)+con);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,s1+<span class="number">1</span>,s2+<span class="number">1</span>),n=<span class="built_in">strlen</span>(s1+<span class="number">1</span>),ans=n*n;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) p[i]=s1[i]-<span class="string">&#x27;0&#x27;</span>,t[i]=t[i+n]=t[i+n+n]=s2[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) ct1+=p[i],ct2+=t[i];</span><br><span class="line">    <span class="keyword">if</span>(!ct2) <span class="keyword">return</span> <span class="built_in">puts</span>(ct1 ? <span class="string">&quot;-1&quot;</span> : <span class="string">&quot;0&quot;</span>),<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n+n;++i) <span class="keyword">if</span>(!t[i]) ls[i]=(ls[i<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(rei i=n+n+n;i&gt;n;--i) <span class="keyword">if</span>(!t[i]) rs[i]=(rs[i+<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(rei k=<span class="number">0</span>;k&lt;=n;++k)&#123;</span><br><span class="line">        m=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(pre,<span class="number">0</span>,<span class="keyword">sizeof</span> pre),<span class="built_in">memset</span>(suf,<span class="number">0</span>,<span class="keyword">sizeof</span> suf);</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[i]^t[i+k])&#123;</span><br><span class="line">                ++m; <span class="keyword">if</span>(t[i+k]) <span class="keyword">continue</span>;</span><br><span class="line">                pre[ ls[i+n] ]=<span class="built_in">max</span>(pre[ ls[i+n] ],rs[i+n]);</span><br><span class="line">                suf[ rs[i+n] ]=<span class="built_in">max</span>(suf[ rs[i+n] ],ls[i+n]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(rei i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i) suf[i]=<span class="built_in">max</span>(suf[i],suf[i+<span class="number">1</span>]),pre[i]=<span class="built_in">max</span>(pre[i],pre[i+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;n;++i) <span class="built_in">upd</span>(k,pre[i+<span class="number">1</span>],i,m),<span class="built_in">upd</span>(n-k,suf[i+<span class="number">1</span>],i,m);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>给定长度 $n (1\leq n\leq 10^4)$ 的 $0/1$ 串 $A,B$ ，两个串均有 $k$ 个 $1$ ，令 $a_{1\sim k},b_{1\sim k}$ 分别表示 $AB$ 中所有 $1$ 出现的位置。 将 $a,b$ 等概率随机排列，按 $1\sim k$ 的顺序交换 $A_{a_i},B_{b_i}$ ，设 $P$ 表示操作后 $AB$ 相等的概率，求 $P\times k^2$ 在模 $998244353$ 意义下的值</p>
</blockquote>
<p>定义 $A_i=1 \land B_i=0$ 的 $i$ 为富余点，能为其他位置提供 $1$ ；$A_i=B_i=1$ 的 $i$ 为公共点，可以传递 $1$ ；$A_i=0 \land B_i=1$ 的位置为缺失点，富余点需要移动到那里</p>
<p>考虑 $dp$ ：设 $f(i,j)$ 表示在传递链中用了 $i$ 个公共点， $j$ 个富余点时传递链中的方案数，有转移： $\displaystyle {f(i,j)=f(i-1,j)\times ij+f(i,j-1)\times j^2}$</p>
<p>即：将一个公共点加入一条传递链的末尾： $j$ 条链中，新的点可以与已有的 $i-1$ 个点交换链中的位置 + 新建一条链：拿出新的一对缺失-富余点，考虑到可以与原来的点交换位置，系数 $j^2$</p>
<p>最后统计，公共点没有必要用完，设链中用了 $a$ 个公共点，还剩 $b$ 个，方案数 $\binom{a+b}{b}$ ；公共点内部方案 $(b!)^2$ ； $b$ 次操作安排进 $k$ 次操作里，方案数 $\binom{k}{b}$ 。设公共点 $s$ ，富余点 $t$ ，答案为： $\displaystyle{\sum_{t=0}^s \binom{s}{i}\times \binom{s+t}{i}\times (i!)^2\times f_{s-i,t}}$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n,sur,bal,f[N][N],fac[N],fac_inv[N],ans;</span><br><span class="line"><span class="keyword">char</span> A[N],B[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fix</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123; x&gt;=mod ? x-=mod : <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(ll a,<span class="keyword">const</span> <span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">return</span>(a*=b)&lt;mod ? a : a%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">int</span> res=<span class="number">1</span>;<span class="keyword">while</span>(b)&#123; <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=(ll) res*a%mod;a=(ll) a*a%mod;b&gt;&gt;=<span class="number">1</span>;&#125; <span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_C</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">return</span> x&lt;y ? <span class="number">0</span> : (ll) fac[x]*((ll) fac_inv[y]*fac_inv[x-y]%mod)%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)fac[i]=<span class="built_in">mul</span>(i,fac[i<span class="number">-1</span>]);</span><br><span class="line">	fac_inv[n]=<span class="built_in">qpow</span>(fac[n],mod<span class="number">-2</span>);</span><br><span class="line">	<span class="keyword">for</span>(rei i=n<span class="number">-1</span>;~i;--i)fac_inv[i]=<span class="built_in">mul</span>(i+<span class="number">1</span>,fac_inv[i+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,A+<span class="number">1</span>,B+<span class="number">1</span>),n=<span class="built_in">strlen</span>(A+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(A[i]^<span class="string">&#x27;0&#x27;</span> &amp;&amp; B[i]^<span class="string">&#x27;0&#x27;</span>) ++bal;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(A[i] &gt; B[i]) ++sur;</span><br><span class="line">	&#125;</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;=bal;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(rei j=<span class="number">0</span>,cur;j&lt;=sur;++j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!(cur=f[i][j])) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">fix</span>(f[i+<span class="number">1</span>][j]+=<span class="built_in">mul</span>(cur,<span class="built_in">mul</span>(i+<span class="number">1</span>,j)));</span><br><span class="line">			<span class="built_in">fix</span>(f[i][j+<span class="number">1</span>]+=<span class="built_in">mul</span>(cur,<span class="built_in">mul</span>(j+<span class="number">1</span>,j+<span class="number">1</span>)));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;=bal;++i)&#123;</span><br><span class="line">		rei fre=bal-i;</span><br><span class="line">		rei self=<span class="built_in">mul</span>(<span class="built_in">mul</span>(fac[fre],fac[fre]), <span class="built_in">mul</span>(<span class="built_in">get_C</span>(bal+sur,fre),<span class="built_in">get_C</span>(bal,fre)));</span><br><span class="line">		<span class="built_in">fix</span>(ans+=<span class="built_in">mul</span>(f[i][sur],self));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>$N+M$ 个问题，其中 $N$ 个问题的答案为 $Yes$ ，$M$ 个答案的问题为 $No$ ，且这些问题的排列均匀随机。 依次回答每一个问题，回答完该问题后会得知答案，在最优策略下，最多能期望蒙对多少题</p>
</blockquote>
<p>显然有 $N&gt;M$ 时，下一个问题需要贪心猜 $Yes$</p>
<p>而当 $N=M$ 时，两种的期望相同，不妨均猜 $Yes$</p>
<p>考虑如何统计：当 $N=M$ 时猜对一道题，称这个为好运题，其他猜对的称为平凡题</p>
<p>有一个比较显然的性质：<strong>不论题目的排列顺序，平凡题的数量始终为 $\max\{N,M\}$</strong></p>
<p><del>应该由归纳法易得对吧</del></p>
<p>于是由期望的线性得，只需要统计好运题的数量即可，且只需要对于每个 $i=i,2,…,\min\{N,M\}$，求出<strong>有 $\frac{p_i}{2}$ 的概率遇到 $i$ 道对 $i$ 道错的题并将该题蒙对</strong>，最后对于每个 $i$ ，将这样的概率相加即得好运题的数量期望。</p>
<p>如果我们把 $(N,M)$ 看成坐标平面上的一个整点，那么整个过程可以看成一条 $HV$ 格路，由顺序均匀随机可知，在所有 $\binom{N+M}{N}$ 条 $HV$ 格路中，每条格路出现的概率均相等。</p>
<p>而我们就是要统计这条 $HV$ 格路经过点 $(i,i)$ 的概率，因而只需统计经过这个点的格路个数。</p>
<p>由二项式系数得：$\displaystyle{p_i=\frac{\binom{2\times i}{i}\times \binom{(N-i)+(M-i)}{N-i}}{\binom{N+M}{N}}}$</p>
<p>最终答案就是 $\frac{1}{2}\sum_{i&gt;1} p_i +\max\{N,M\}$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">998244353</span>,iv2=(mod+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> A,B,n,ans;</span><br><span class="line"><span class="keyword">int</span> fac[N],fac_inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">qpow</span><span class="params">(ll a,<span class="keyword">int</span> n,ll c=<span class="number">1</span>)</span></span>&#123; <span class="keyword">for</span>(;n;n&gt;&gt;=<span class="number">1</span>,a=a*a%mod) <span class="keyword">if</span>(n&amp;<span class="number">1</span>) c=c*a%mod; <span class="keyword">return</span> c;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">get_C</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">return</span> (ll) fac[a+b]*fac_inv[a]%mod *fac_inv[b]%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">get_C_inv</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">return</span> (ll) fac_inv[a+b]*fac[a]%mod *fac[b]%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) fac[i]=(ll) fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">	fac_inv[n]=<span class="built_in">qpow</span>(fac[n],mod<span class="number">-2</span>);</span><br><span class="line">	<span class="keyword">for</span>(rei i=n;i;--i) fac_inv[i<span class="number">-1</span>]=(ll) fac_inv[i]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;A,&amp;B),n=std::<span class="built_in">min</span>(A,B);</span><br><span class="line">	<span class="built_in">init</span>(A+B);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) ans=(ans+<span class="built_in">get_C</span>(i,i)*<span class="built_in">get_C</span>(A-i,B-i)%mod)%mod;</span><br><span class="line">	ans=(ans*<span class="built_in">get_C_inv</span>(A,B)%mod*iv2%mod+(A^B^n))%mod;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>思维</tag>
        <tag>dp</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>82801202-AGC021</title>
    <url>/2021/08/28/AGC021/</url>
    <content><![CDATA[<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><blockquote>
<p>无限大的平面上给出 $n$ 个点，任选一点出发，走到离自己欧几里得距离最近的点停下，求到每个点停下的概率</p>
</blockquote>
<p>对于点 $x$ ，对该点到其余点的 $atan2$ 函数值排序</p>
<p>设相邻两个向量的夹角 $\theta$ ，对于点 $i$ 答案为 $\displaystyle{\frac{\max_{1\leq j\leq N,j\not ={i}}\{\theta_{i\rightarrow j},0\}}{2\times \pi}}$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">int</span> n,tot; <span class="keyword">double</span> ans;</span><br><span class="line"><span class="keyword">double</span> slope[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span> <span class="keyword">int</span> x,y; &#125;p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;p[i].x,&amp;p[i].y);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        tot=<span class="number">0</span>; ans=<span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=n;++j) <span class="keyword">if</span>(i!=j) slope[++tot]=<span class="built_in">atan2</span>(p[j].y-p[i].y,p[j].x-p[i].x);</span><br><span class="line">        <span class="built_in">sort</span>(slope+<span class="number">1</span>,slope+<span class="number">1</span>+tot);</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,PI-(slope[tot]-slope[<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">for</span>(rei j=<span class="number">2</span>;j&lt;=tot;++j) ans=<span class="built_in">max</span>(ans,(slope[j]-slope[j<span class="number">-1</span>])-PI);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.10lf\n&quot;</span>,ans/(<span class="number">2</span>*PI));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>给定字符串 $S(1\leq S\leq 300)$ ，最多更改其中的 $k$ 个字符 ，求 $S$ 和 $S’(S的反串)$ 的 $\text{LCS}$ 的最长长度</p>
</blockquote>
<p>有神仙结论：<strong>字符串的最长回文子序列 $\text{lps}$ 的长度等于其自身与反转的最长公共子序列的长度</strong></p>
<ul>
<li><p>证明</p>
<p>要求得到 $|LPS|=|LCS|$ ，即 $|LPS|\leq |LCS| \And |LPS|\geq |LCS|$</p>
<p>显然只需要考虑 $|LPS|\geq |LCS|$</p>
<p>设 $T$ 是 $S,S’$ 的一个最长公共子序列，不妨设 $|T|$ 是奇数（偶数时证明同理可得）</p>
<p>设 $T$ 的第 $k$ 位是 $S$ 的第 $i$ 位与 $S’$ 的第 $j$ 位的匹配</p>
<p>令</p>
<script type="math/tex; mode=display">\begin{aligned}
    n=|S|,m=|T| \\
    S_l=S_{1\sim i-1},S_r=S_{i+1\sim n} \\
    S'_l=S'_{1\sim j-1},S'_r=S'_{j+1\sim m} \\
    T_l=T_{1\sim k-1},T_r=T_{k+1\sim m}
\end{aligned}</script><p>那么有 $T_l$ 是 $S_l$ 和 $S’_l$ 的一个最长公共子序列， $T_r$ 是 $S_r$ 和 $S’_r$ 的一个最长公共子序列</p>
<ul>
<li><p>若 $S’_r$ 是 ${S_l}’$ 的一个后缀</p>
<p>$\because T_r$ 是 $S_r$ 和 $S’_r$ 的最长公共子序列       $\therefore T_r$ 一定是 ${S_l}’$ 和 ${S’_l}’$ 的公共子序列，则 ${T_r}’+T_k+T_r$ 是 $S$ 的一个回文子序列。则 $|LPS|\geq |LCS|$</p>
</li>
<li><p>否则</p>
<p>$S_l$ 一定是 ${S’_r}’$ 的一个前缀，那么 $S’_l$ 就是 $S_r’$ 的一个前缀，同理得 $|LPS|\geq |LCS|$</p>
</li>
</ul>
<p>综上得证</p>
</li>
</ul>
<p>那么转化为求更改最多 $K$ 个字符后 $S$ 的最长回文子序列长度</p>
<p>区间 $dp$ ，$dp_{i,j,k}$ 含义显然</p>
<script type="math/tex; mode=display">
dp_{i,j,k}=
\begin{cases}
    \max\{dp_{i+1,j,k},dp_{i,j-1,k}\} &\text{显然的更新} \\
    \max\{dp_{i+1,j-1,k}+2\} &s_i=s_j \\
    \max\{dp_{i+1,j-1,k-1}+2\} &k!=0 \\
\end{cases}</script><p>注意这三个判断并不冲突</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">310</span>;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> f[N][N][N],K,n,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>,s+<span class="number">1</span>,&amp;K);</span><br><span class="line">    n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) f[i][i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei l=<span class="number">1</span>;l&lt;=n;++l)</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i+l&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span>(rei k=<span class="number">0</span>,j=i+l;k&lt;=K;++k)&#123;</span><br><span class="line">            f[i][j][k]=<span class="built_in">max</span>(f[i+<span class="number">1</span>][j][k],f[i][j<span class="number">-1</span>][k]);</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[j]) f[i][j][k]=<span class="built_in">max</span>(f[i][j][k],f[i+<span class="number">1</span>][j<span class="number">-1</span>][k]+<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(k) f[i][j][k]=<span class="built_in">max</span>(f[i][j][k],f[i+<span class="number">1</span>][j<span class="number">-1</span>][k<span class="number">-1</span>]+<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;=K;++i) ans=<span class="built_in">max</span>(ans,f[<span class="number">1</span>][n][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>$n$ 值变色龙，初始时均为蓝色，喂 $k$ 次球，每次让指定变色龙吃下指定颜色的球，变色龙蓝变红当且仅当吃的红球数严格多余蓝球数，反之亦有，求最后使所有变色龙变红的方案数，这里，方案数指 $k$ 个球按顺序组成的颜色序列不同</p>
</blockquote>
<p>设 $R$ 个红球 ，$B$ 个蓝球</p>
<p>当 $R<B$ 显然无解；$R>N$ 时一定有解，将多出来的这部分暂时搁置，只考虑 $B\leq R&lt;B+N$ 的情况</p>
<p>得出有解的的必要条件为 $R\geq B,R\geq N$</p>
<ul>
<li><p>R=B</p>
<p>那么每只变色龙必须吃球 $RB$ ,而若最后一只吃的是 $BR$ 则无解，故转化为考虑 $(R=R，B=R-1)$ 的情况</p>
</li>
<li><p>R&gt;B</p>
<p>有一些结论：</p>
<ul>
<li>一个变色龙最多不会吃超过 $1$ 个 $R$ ，且吃完后最多吃 $1$ 个 $B$</li>
<li>对于多个蓝球，全部喂给一条变色龙优于喂给多个</li>
<li>任何变色龙的 $R-B\leq 1$</li>
</ul>
<p>那么要将组合分为：</p>
<ul>
<li>若干配对的 $RB$</li>
<li>若干 $R=B+1$</li>
</ul>
<p>显然 $组合 R=B+1$ 至多产生 $R-B$ 个，即，当 $N\leq R-B$ 时所有情况均可，否则需要有 $N-(R-B)$ 个 $组合 RB$</p>
<p>且 $B$ 必须在 $R$ 后面出现</p>
<p>这个条件等价于: <strong>对于序列的任何一个前缀，$B-R\leq B-(N-(R-B))=R-N$ 个</strong></p>
<p>即，统计 $(0,0)\rightarrow (R,B)$ 中处于直线 $y=x+(R-N)$ 及其下方的 $HV$ 格路数量</p>
<p>总方案数为 $\displaystyle{\binom{R+B}{R}-\binom{R+B}{2\times R-N+1}}$</p>
</li>
<li><p>再考虑 $R=B$ 时，总方案数为 $\displaystyle{\binom{2\times R-1}{R}-\binom{2\times R-1}{2\times R-N+1}}$</p>
</li>
</ul>
<p>综上，再加上省略的比 $N$ 多出来的东西，答案为</p>
<script type="math/tex; mode=display">\sum_{\max \left\{ \left \lfloor K/2 \right \rfloor + 1, N \right\} \leq R \leq K} \left( \binom K R - \binom K {2 R - N + 1} \right) + \left[ 2 \mid K \right] \left[ K \geq 2 N \right] \left( \binom {K - 1} {K / 2} - \binom {K - 1} {K - N + 1} \right)</script><p>把这一坨化简试试：</p>
<ul>
<li><p>当 $k$ 奇数，只有左边的式子</p>
<script type="math/tex; mode=display">\begin{aligned}
原式&=\sum_{\max\{\frac{K+1}{2},N\}\leq R\leq K} \left(\binom{K-1}{R-1} + \binom{K-1}{R} - \binom{K-1}{2R-N} - \binom{K-1}{2R-N+1}\right) \\
&=\sum_{i\geq \max\{\frac{K+1}{2},N-1\}\leq R\leq K} \binom{K-1}{i} + \sum_{i\geq \max\{\frac{K+1}{2},N\}} \binom{K-1}{i} - \sum_{i\geq \max\{K+1-N,N\}} \binom{K-1}{i} &\text{emmm这一步稍微有点玄学}\\
&=\sum_{i\geq \max\{\frac{K+1}{2},N-1\}\leq R\leq K} \binom{K-1}{i} + \sum_{\max\{\frac{K+1}{2},N\}\leq i\leq \max\{K+1-N,N\}} \binom{K-1}{i} \\
\end{aligned}</script><ul>
<li><p>$N\leq \frac{K+1}{2}$</p>
<script type="math/tex; mode=display">\begin{aligned}
原式&=\sum_{i\geq \frac{K-1}{2}}\binom{K-1}{i} + \sum_{\frac{K+1}{2}\leq i< K+1-N}\binom{K-1}{i} &\text{这里注意k是奇数，边界注意内个是小于号} \\
&\text{如果这里向下有困难的话就只考虑 $N< \frac{K+1}{2}$ 的情况，再单独考虑相等，那时仅有第一个式子有意义，小于号使第二个式子不存在合法的 $i$ ,结论不变} \\
&=\sum_{\frac{K-1}{2}\leq i\leq K-1} \binom{K-1}{i} + \sum_{N-1\leq i\leq \frac{k-3}{2}} \binom{K-1}{i} &\text{完善一下第一个的范围，画个数轴，整数范围内就能得到下式}\\
&=\sum_{i=N-1}^{K-1} \binom{K-1}{i} &\text{typora里面空的怎么这么多啊}\\
\end{aligned}</script></li>
<li><p>$N&gt;\frac{K+1}{2}$</p>
<script type="math/tex; mode=display">\begin{aligned}
原式&=\sum_{i\geq N-1}\binom{K-1}{i} + \sum_{N\leq i<N} \binom{K-1}{i} \\
&=\sum_{i=N-1}^{K-1}\binom{K-1}{i} \\
\end{aligned}</script></li>
</ul>
</li>
<li><p>当 $K$ 为偶数</p>
<p>这里推到显然相同，只是原式中的第二个会在 $N\leq \frac{K}{2}$ 时对式子产生贡献，使其不变，这里推到略去</p>
</li>
</ul>
<p>综上所述，<del>有人是懒狗但我不说是谁</del> 原式始终为 $\sum_{i=N-1}^{K-1}\binom{K-1}{i}$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n,K,inv[N];</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fix</span><span class="params">(ll &amp;x)</span></span>&#123; x&gt;=mod ? x-=mod : <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;K);</span><br><span class="line">	rei cur=<span class="number">1</span>;</span><br><span class="line">	n=K---n; inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;=n;++i) inv[i]=(ll) (mod-mod/i)*inv[mod%i]%mod;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;=n;++i) <span class="built_in">fix</span>(ans+=cur),cur=(ll) cur*(K-i)%mod *inv[i+<span class="number">1</span>]%mod;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(<span class="keyword">int</span>) ans%mod);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>思维</tag>
        <tag>dp</tag>
        <tag>数论</tag>
        <tag>组合数学</tag>
        <tag>字符串</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>03801202-AGC022</title>
    <url>/2021/08/30/AGC022/</url>
    <content><![CDATA[<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><blockquote>
<p>给定序列 $A$ ，通过若干次操作使其变为序列 $B$ 。对于每次操作，选择一个正整数 $k$ ，对于每个数选择将其变为 $a_i\pmod k$ 或不变，这次操作代价 $2^k$ 。总代价为所有操作代价和，球最小总代价</p>
</blockquote>
<p><strong>注意这个 $2^k$ 的代价，其意味着从高位到地位贪心</strong></p>
<p>然后对每个 $k$ 建图判断一下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">55</span>;</span><br><span class="line"><span class="keyword">int</span> n,f[N][N],a[N],b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(ll sta)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;N;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;N;++j) f[i][j]=i==j ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;N;++i) <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=i;++j) <span class="keyword">if</span>(sta &amp; (<span class="number">1ll</span>&lt;&lt;j)) f[i][i%j]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei k=<span class="number">0</span>;k&lt;N;++k) <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;N;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;N;++j) f[i][j]|=(f[i][k] &amp; f[k][j]);</span><br><span class="line">	<span class="keyword">bool</span> ret=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>(!f[ a[i] ][ b[i] ])&#123; ret=<span class="literal">false</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">    ll sta=(<span class="number">1ll</span>&lt;&lt;<span class="number">38</span>)<span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">check</span>(sta))&#123; <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>),<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">37</span>;i;--i)&#123;</span><br><span class="line">        ll tmp=sta^(<span class="number">1ll</span>&lt;&lt;i);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(tmp))&#123; sta=tmp;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,sta);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>$N$ 个商场，第 $i$ 个在数轴的 $x_i$ ，需要花费连续的 $t_i$ 时间购物。一趟火车在 $0,L$ 处往返，行驶一单位长度用一单位时间，在 $0$ 时于 $0$ 处上车，只有在 $商场，0，L$ 处才可下车，求在每个超市购物后返回 $0$ 处的最少时间</p>
</blockquote>
<p>有一个神仙思路：</p>
<p>对于每个 $t_i$ ，先 $\% 2\times L$ ，再把 $2\times L\times n$ 加到答案里</p>
<p>考虑一个点，如果从左边进只需要到达依次端点就看作左括号，从右边进只需要依次达到端点就看作右括号</p>
<p>先默认每个点贡献都是 $2\times L$ ，那么左右括号匹配时则可以减少 $2\times L$</p>
<p>某些点可以看作左/右括号，此时考虑最大化匹配数</p>
<p>有性质：当一个节点开始时固定作为左括号，则后面一定没有固定作为右括号的，所以不会有两个固定的括号匹配。</p>
<p>贪心即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,len,x[N],t[N],l[N],r[N],ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;len);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x[i]);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t[i]);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		ans+=t[i]/(<span class="number">2</span>*len); t[i]%=<span class="number">2</span>*len;</span><br><span class="line">		<span class="keyword">if</span>(!t[i])&#123; --ans; <span class="keyword">continue</span>;&#125;</span><br><span class="line">		l[i]=(t[i]&lt;=x[i]*<span class="number">2</span>);</span><br><span class="line">		r[i]=(t[i]&lt;=(len-x[i])*<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	rei lim=n,L=<span class="number">0</span>,R=<span class="number">0</span>;</span><br><span class="line">    ans+=n+<span class="number">1</span>-r[n];</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!l[i] &amp;&amp; !r[i]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(!r[i])&#123; lim=i; <span class="keyword">break</span>;&#125;</span><br><span class="line">		<span class="keyword">if</span>(!l[i] &amp;&amp; L) --L,--ans;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(l[i]) ++L;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(rei i=n<span class="number">-1</span>;i&gt;=lim;--i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!l[i] &amp;&amp; !r[i]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(!l[i]) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span>(!r[i] &amp;&amp; R) --R,--ans;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(r[i]) ++R;</span><br><span class="line">	&#125;</span><br><span class="line">	ans-=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="number">2ll</span>*ans*len);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>一个奇数长度的 $01$ 串 $s$ ，其中若干位置是符号 $?$ ，每次将 $3$ 个连续的字符替换成着三个数的中位数，有多少种方案将 $?$ 替换成 $0/1$ 后再进行 $\frac{n-1}{2}$ 次操作后字符串为 $1$</p>
</blockquote>
<p>首先考虑没有 $?$ 的情况，考虑其是否合法</p>
<p>维护一个栈，其中包括一段连续的 $0$ 和一段连续的 $1$</p>
<ul>
<li>加入 $0$<ul>
<li>栈顶 $0$ ：若栈内 $2$ 个 $0$ ，则替换成一个 $0$ ，否则入栈</li>
<li>栈顶 $1$ ：直接入栈</li>
</ul>
</li>
<li>加入 $1$<ul>
<li>栈顶 $0$ ：弹出栈顶的 $0$ ，相当于抵消</li>
<li>栈顶 $1$ ：若栈内只有一个 $1$ 则入栈，否则不管</li>
</ul>
</li>
</ul>
<p>那么最后只要 $num_1&gt;num_0$ 则合法</p>
<p>简化一下栈内部：发现 $0,1$ 的个数只可能是 $0\sim 2$ ，设 $f_{i,a,b}$ 表示第 $i$ 位时，栈内有 $a$ 个 $1$ ，$b$ 个 $0$ 的方案数</p>
<p>有转移：</p>
<script type="math/tex; mode=display">
s[i+1]=0时 \quad
\begin{cases}
    f_{i+1,a,1}+=f_{i,a,2}+f_{i,a,0} \\
    f_{i+1,a,2}+=f_{i,a,1} \\
\end{cases}</script><script type="math/tex; mode=display">
s[i+1]=1时 \quad
\begin{cases}
    f_{i+1,a,b-1}+=f_{i,a,b} \\
    f_{i+1,1,0}+=f_{i,0,0} \\
    f_{i+1,2,0}+=f_{i,1,0}+f_{i,2,0} \\
\end{cases}</script><script type="math/tex; mode=display">
s[i+1]=?时 \quad
\begin{cases}
    s[i+1]=1时 \\
    s[i+1]=0时 \\
\end{cases}</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,ans;</span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fix</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123; x&gt;=mod ? x-=mod : <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>); n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i+<span class="number">1</span>]!=<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span>(rei a=<span class="number">0</span>;a&lt;=<span class="number">2</span>;++a)&#123;</span><br><span class="line">                <span class="built_in">fix</span>(f[i+<span class="number">1</span>][a][<span class="number">1</span>]+=f[i][a][<span class="number">2</span>]);</span><br><span class="line">                <span class="built_in">fix</span>(f[i+<span class="number">1</span>][a][<span class="number">1</span>]+=f[i][a][<span class="number">0</span>]);</span><br><span class="line">                <span class="built_in">fix</span>(f[i+<span class="number">1</span>][a][<span class="number">2</span>]+=f[i][a][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i+<span class="number">1</span>] != <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(rei a=<span class="number">0</span>;a&lt;=<span class="number">2</span>;++a)&#123;</span><br><span class="line">                <span class="built_in">fix</span>(f[i+<span class="number">1</span>][a][<span class="number">0</span>]+=f[i][a][<span class="number">1</span>]);</span><br><span class="line">                <span class="built_in">fix</span>(f[i+<span class="number">1</span>][a][<span class="number">1</span>]+=f[i][a][<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">fix</span>(f[i+<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]+=f[i][<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">fix</span>(f[i+<span class="number">1</span>][<span class="number">2</span>][<span class="number">0</span>]+=f[i][<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">fix</span>(f[i+<span class="number">1</span>][<span class="number">2</span>][<span class="number">0</span>]+=f[i][<span class="number">2</span>][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei a=<span class="number">0</span>;a&lt;=<span class="number">2</span>;++a) <span class="keyword">for</span>(rei b=<span class="number">0</span>;b&lt;=a;++b) <span class="built_in">fix</span>(ans+=f[n][a][b]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>$x=10^{100}$ ，数轴上有 $n$ 个点，点 $i$ 的坐标为 $x_i$ ，$n-1$ 次操作，每次选择两点 $A,B$ ，将 $A$ 移动到 $B$ 的对称点并删去 $B$ ，求最后剩的数取值的方案数</p>
</blockquote>
<p>当 $关于B对称的A$ 变成 $2B-A$ 时，即 $B被消掉$ 时，将 $A$ 视作 $B$ 的父亲，最终形成一颗具有儿子相对顺序的树，如此最终剩下来的点就是根节点</p>
<p>将一个点 $A$ 的贡献视作 $2^{d_A} \times c_A \times x_A$ ，其中 $x_A$ 视作未知数， $d_A$ 为节点 $A$ 深度 ，$c_A$ 为正负号</p>
<p>考虑到 $x_i$ 极大且 $x_{i+1}-x_i$ 也极大，那么不会出现点贡献相互抵消，那么只需要考虑前面的系数即可</p>
<p>深度显然易得，考虑如何求 $c_i$</p>
<p>这里采取<strong>间接确定每一项的符号</strong>，即，对于点 $i$ 的字节点 $son_1,son_2,…son_k$ ，已知点 $i$ 的符号，观察 $k$ 个子节点符号与 $i$ 的关系</p>
<p>当 $i$ 再向上与 $fa_i$ 连边时，相当于有 $2\times val_i-val_{fa}$ ，而 $son_i$ 又有贡献 $2\times val_{son}-2\times val_i$ ，所以连边后 $i$ 与 $son_i$ 的正负号会同时取反</p>
<p>而当 $son_i$ 连向 $i$ 时，对于 $son_i$ ，其实质相当于 $\times 2$ ，而对于 $i$ ，其实质为 $\times -1$</p>
<p>那么有结论：当且仅当节点 $v$ 有奇数个字节点时，其符号与父节点不一样</p>
<p>考虑 $dp$ 解决：</p>
<p>设 $f_{i,j}$ 表示放了 $i$ 个节点，最后一层有 $j$ 个节点的儿子数量为奇数时的方案数</p>
<p>为了方便将 $c_i$ 差分，与 $fa$ 相同记作 $1$ ，不同记作 $-1$ ，转移时仅关心下一层与 $fa$ 相同/不同的数量</p>
<p>对于点 $v$ 有 $k$ 个儿子，若不考虑儿子的儿子的影响，应该有 $\left\lfloor \frac{k}{2} \right\rfloor$ 个儿子的 $c$ 与 $v$ 不同</p>
<p>设下一层长出 $k$ 个节点，其中 $\frac{k-j}{2}$ 个点正负与父亲不同(此时kj奇偶性不同则跳过)</p>
<p>设考虑儿子的儿子的影响后，点 $v$ 有 $x$ 个儿子与之正负不同，那么就有 $|x-\frac{k-j}{2}|$ 个节点( $son_v$ )的正负性需要修正，即，下一层中的点的儿子个数为奇数的节点数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">55</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll c[N][N],f[N][N]; <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        c[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=i;++j) c[i][j]=(c[i<span class="number">-1</span>][j<span class="number">-1</span>]+c[i<span class="number">-1</span>][j])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>]=f[<span class="number">1</span>][<span class="number">1</span>]=n;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;n;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;=i;++j) <span class="keyword">for</span>(rei k=(!j ? <span class="number">2</span> : j);i+k&lt;=n;k+=<span class="number">2</span>)&#123;</span><br><span class="line">        rei t=(k-j)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(rei x=<span class="number">0</span>;x&lt;=k;++x) (f[i+k][<span class="built_in">abs</span>(x-t)]+=f[i][j]*c[n-i][k]%mod*c[k][x]%mod)%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[n][<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>思维</tag>
        <tag>贪心</tag>
        <tag>dp</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>13801202-AGC023</title>
    <url>/2021/08/31/AGC023/</url>
    <content><![CDATA[<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>一条数轴上有 $n$ 个公寓，第 $i$ 个位于 $x_i$ ，共有 $P_i$ 个人居住。 现在这 $\sum P_i$ 个人聚集在点 $S$ 处。只有一辆公交车，每次只能向前或向后，每个人会投票沿正/负方向，票数多的胜，相同时向负方向开。每个人用自私的投票方向，而有长期利益时也会做，到家必须下车。在这种策略下，求让所有人都到家的时间</p>
</blockquote>
<p>原问题与绝对坐标无关，仅与相对位置有关，不妨设 $S=0$</p>
<p>若所有 $X_i$ 同号，则顺着开过去显然对所有人有利</p>
<p>考虑不同号：若 $P_1\leq P_N$ 有结论：<strong>此时对于 $1,N$ 号公寓，车一定先到达 $1$</strong> ，这不难证明</p>
<p>由此，将 $P_1$ 视作 $P_1+P_N$ ，然后删去 $N$ 点，对<strong>结果的策略</strong>显然不产生影响</p>
<p>由此往复，直至所有人的公寓都位于 $S$ 同侧</p>
<p>对于计算总时间，考虑倒着记录公交车的轨迹，即，删去 $N$ 后将轨迹最后一个点设为 $X_N$ ，最后让公交车沿轨迹行驶+同侧的最远距离即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,cnt,x[N],a[N];</span><br><span class="line">ll p[N],ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	rei i,j,s=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;x[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>,&amp;x[i],&amp;p[i]),(x[i]-=*x)&lt;<span class="number">0</span> &amp;&amp; (s=i);</span><br><span class="line">    *x=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>,j=n;i&lt;=s &amp;&amp; j&gt;s;a[cnt++]=p[i]&gt;=p[j] ? (p[i]+=p[j],j--) : (p[j]+=p[i],i++));</span><br><span class="line">	<span class="keyword">for</span>(a[cnt++]=(i&lt;=s ? i : j);cnt;ans+=<span class="built_in">abs</span>(x[ a[--cnt] ]-x[v]),v=a[cnt]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>给定一个长度为 $N$ 的序列 $A$ ，求 $\forall i, P_i\leq A_i$ 的 $1\sim n$ 的排列的逆序数的和</p>
</blockquote>
<p>将 $A$ 升序后的数组为 $a$ ，则总方案数为 $f(n)=\prod_{i=1}^n (a_i-i+1)$</p>
<p>设 $A_i$ 排名为 $rnk_i$ ，有 $a_i=A_{rnk_i}$ </p>
<p>对于位置 $i,j$ 考虑其对逆序对的贡献：</p>
<script type="math/tex; mode=display">f(i,j)=\frac{f(n)\times \frac{a_j-rnk_j}{a_i-rnk_i+1}\times (\prod_{k=b_j+1}^{b_i-1}) \frac{c_k-k}{c_k-k+1}}{2}</script><p>即，$p_j&gt;p_i$ 的方案数为 $a_i,a_j$ 相同时的总方案数 $\div 2$</p>
<p>而对于 $a_i&gt;a_j$ 的部分，求出顺序对，并用总合减去</p>
<script type="math/tex; mode=display">f(i,j)=f(n)-\frac{f(n)\times \frac{a_j-rnk_j}{a_i-rnk_i+1}\times (\prod_{k=b_j+1}^{b_i-1}) \frac{c_k-k}{c_k-k+1}}{2}</script><p>对于相同的部分：</p>
<script type="math/tex; mode=display">\frac{f(n)\times \frac{a_j-rnk_j}{a_i-rnk_i+1}\times (\prod_{k=b_j+1}^{b_i-1}) \frac{c_k-k}{c_k-k+1}}{2}=\frac{f(n)}{2(a_i-b_i+1)}\times (a_j-b_j) \times \prod_{k=b_j+1}^{b_i-1} \frac{c_k-k}{c_k-k+1}</script><p>后半部分用线段树维护即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,res,tot=<span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span>&#123;</span> <span class="keyword">int</span> data,pos;&#125;a[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Data a,<span class="keyword">const</span> Data b)</span></span>&#123; <span class="keyword">return</span> a.data&lt;b.data;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fix</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123; x&gt;=mod ? x%=mod : <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span>&#123; <span class="keyword">int</span> res=<span class="number">1</span>; <span class="keyword">for</span>(;k;k&gt;&gt;=<span class="number">1</span>,x=x*x%mod) <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=res*x%mod; <span class="keyword">return</span> res;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Seg_Tree</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> <span class="keyword">int</span> data,tag;&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123; tr[u].data=(tr[u&lt;&lt;<span class="number">1</span>].data+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].data)%mod;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">		tr[u].data*=z,tr[u].data%=mod,tr[u].tag*=z,tr[u].tag%=mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">		<span class="built_in">updata</span>(u&lt;&lt;<span class="number">1</span>,tr[u].tag),<span class="built_in">updata</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,tr[u].tag);</span><br><span class="line">		tr[u].tag=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		tr[u].tag=<span class="number">1</span>; <span class="keyword">if</span>(l==r) <span class="keyword">return</span> ;</span><br><span class="line">		rei mid=l+r&gt;&gt;<span class="number">1</span>; <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(x&gt;y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(x&lt;=l &amp;&amp; r&lt;=y) <span class="keyword">return</span> tr[u].data;</span><br><span class="line">		rei mid=l+r&gt;&gt;<span class="number">1</span>,res=<span class="number">0</span>; <span class="built_in">down</span>(u);</span><br><span class="line">		<span class="keyword">if</span>(x&lt;=mid) res+=<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>,l,mid,x,y);</span><br><span class="line">		<span class="keyword">if</span>(y&gt;mid) res+=<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,x,y);</span><br><span class="line">		<span class="keyword">return</span> res%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l==r) <span class="keyword">return</span> tr[u].data=z,<span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">        rei mid=l+r&gt;&gt;<span class="number">1</span>; <span class="built_in">down</span>(u);</span><br><span class="line">		x&lt;=mid ? <span class="built_in">change</span>(u&lt;&lt;<span class="number">1</span>,l,mid,x,z) : <span class="built_in">change</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,x,z);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">up</span>(u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;seg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TA</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> tr[N];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x&amp;(-x);&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">for</span>(;k&lt;=n;k+=<span class="built_in">lowbit</span>(k))tr[k]+=x;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123; rei res=<span class="number">0</span>; <span class="keyword">for</span>(;k;k-=<span class="built_in">lowbit</span>(k))res+=tr[k]; <span class="keyword">return</span> res;&#125;</span><br><span class="line">&#125;ta;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i].data),a[i].pos=i;</span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">fix</span>(tot*=a[i].data-i+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		rei tmp=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fix</span>(tmp+=seg.<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">1</span>,a[i].pos<span class="number">-1</span>));</span><br><span class="line">		<span class="built_in">fix</span>(tmp+=mod-seg.<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,a[i].pos+<span class="number">1</span>,n));</span><br><span class="line">		<span class="built_in">fix</span>(tmp*=tot*<span class="built_in">qpow</span>(<span class="number">2</span>*(a[i].data-i+<span class="number">1</span>),mod<span class="number">-2</span>)%mod);</span><br><span class="line">		<span class="built_in">fix</span>(tmp+=(ta.<span class="built_in">query</span>(n)-ta.<span class="built_in">query</span>(a[i].pos))*tot%mod);</span><br><span class="line">		<span class="built_in">fix</span>(res+=tmp);</span><br><span class="line">		seg.<span class="built_in">updata</span>(<span class="number">1</span>,(a[i].data-i)*<span class="built_in">qpow</span>(a[i].data-i+<span class="number">1</span>,mod<span class="number">-2</span>)%mod);</span><br><span class="line">		seg.<span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,a[i].pos,a[i].data-i),ta.<span class="built_in">add</span>(a[i].pos,<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>一颗 $n$ 节点的数和一个空序列，每个节点上有 $0/1$ ，每次选择一个没有父节点的点删除并将点上面的数字放到当前数列末尾，求这个数列能得到的最小逆序对数</p>
</blockquote>
<p>有一个很好的贪心：将每个节点视作一个连通块，每次选择一个节点将其与其父节点的连通块合并，且排在父节点的后面</p>
<p>如此，根据子节点在连通块内的顺序不同，可以构成所有可能的序列</p>
<p>考虑如何安排顺序使<strong>跨越子树的逆序对最少</strong></p>
<p>设 $cnt_{x,0/1}$ 表示连通块 $x$ 内的 $0/1$ 数量，对于连通块 $xy$ 的顺序，$x$ 在 $y$ 前当且仅当 $cnt_{x,1}\times cnt_{y,0} \leq cnt_{y,1}\times cnt_{x,0}$</p>
<p>那么按照 $\frac{cnt_{x,1}}{cnt_{x,0}}$ 从小到大选即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,f[N],fa[N],cnt[N][<span class="number">2</span>];</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,cnt_0,cnt_1;</span><br><span class="line">	<span class="built_in">node</span>(<span class="keyword">int</span> xx=<span class="number">0</span>)&#123;x=xx;cnt_0=cnt[xx][<span class="number">0</span>];cnt_1=cnt[xx][<span class="number">1</span>];<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node &amp;x,<span class="keyword">const</span> node &amp;y)&#123; <span class="keyword">return</span> (ll) x.cnt_1*y.cnt_0&gt;(ll) x.cnt_0*y.cnt_1;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_fa</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> fa[x]==x ? x : fa[x]=<span class="built_in">get_fa</span>(fa[x]);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;f[i]);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		rei x; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">		++cnt[i][x]; fa[i]=i; <span class="keyword">if</span>(i&gt;<span class="number">1</span>)q.<span class="built_in">push</span>(<span class="built_in">node</span>(i));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">		node w=q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">		rei x=<span class="built_in">get_fa</span>(w.x);</span><br><span class="line">		<span class="keyword">if</span>(fa[x]!=x || cnt[x][<span class="number">1</span>]!=w.cnt_1 || cnt[x][<span class="number">0</span>]!=w.cnt_0) <span class="keyword">continue</span>;</span><br><span class="line">		rei y=<span class="built_in">get_fa</span>(f[x]); fa[x]=y;</span><br><span class="line">		ans+=(ll) cnt[y][<span class="number">1</span>]*cnt[x][<span class="number">0</span>];</span><br><span class="line">		cnt[y][<span class="number">0</span>]+=cnt[x][<span class="number">0</span>],cnt[y][<span class="number">1</span>]+=cnt[x][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(y) q.<span class="built_in">push</span>(<span class="built_in">node</span>(y));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>思维</tag>
        <tag>贪心</tag>
        <tag>博弈论</tag>
        <tag>数数</tag>
      </tags>
  </entry>
  <entry>
    <title>72801202-AGC020</title>
    <url>/2021/08/27/AGC020/</url>
    <content><![CDATA[<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>多组询问，对于每组询问给出 $ABCD$ ，求出字符串满足：长度为 $AA+B$ ，由 $A$ 个 字符 $\text{A}$ 和 $B$ 个字符 $\text{B}$ 构成，且连续相同字符个数的最大值最小，且字典序最小。输出第 $C$ 位到第 $D$ 位</p>
</blockquote>
<p>神仙题用<strong>二分构造</strong></p>
<p>贪心得最小连续长度 $\displaystyle{k=\max\left\{\left\lceil\frac{A}{B+1} \right\rceil , \left\lceil\frac{B}{A+1} \right\rceil \right\}}$</p>
<p>那么这个串可以分成两部分：前一部分在 $k$ 限制下贪心填 $A$ ，后一部分不得已填 $B$</p>
<p>二分边界 $p$ 使 $p$ 的右半部分满足 $B&gt;A\times k$ ，确保左边是 $A$ ，右边是 $B$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> T,A,B,C,D,k;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    a=A-pos/(k+<span class="number">1</span>)*k-pos%(k+<span class="number">1</span>);</span><br><span class="line">    b=B-pos/(k+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;A,&amp;B,&amp;C,&amp;D);</span><br><span class="line">        k=(A+B)/(<span class="built_in">min</span>(A,B)+<span class="number">1</span>);</span><br><span class="line">        rei l=<span class="number">0</span>,r=A+B;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            rei mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">get</span>(mid);</span><br><span class="line">            b&lt;=(ll) a*k ? l=mid+<span class="number">1</span> : r=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">get</span>(l);</span><br><span class="line">        r=l+<span class="number">1</span>+b-a*k;</span><br><span class="line">        <span class="keyword">for</span>(rei i=C;i&lt;=D;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;=l) i%(k+<span class="number">1</span>)!=<span class="number">0</span> ? <span class="built_in">printf</span>(<span class="string">&quot;A&quot;</span>) : <span class="built_in">printf</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> (i-r)%(k+<span class="number">1</span>)!=<span class="number">0</span> ? <span class="built_in">printf</span>(<span class="string">&quot;B&quot;</span>) : <span class="built_in">printf</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>定义一个 $01$ 串的压缩是如下的字符串变化过程：$0\rightarrow 0,1\rightarrow 1$ ；如果 $A\rightarrow P,B\rightarrow Q$ 合法，那么 $A+B\rightarrow P+QA+B→P+Q$ 也合法（其中 $+$ 代表字符串拼接）；如果 $S=\underbrace{A+A+\cdots+A}_{n\text{个}(n\ge 2)}$ ，那么 $S\rightarrow(A\times n)$ 也合法（其中 $\text{(, ), ×  }$ 为字符，$n$ 为数字，算作一个字符，即使其中有 $0/1$</p>
<p>定义 $01$ 串 $B$ 是 $A$ 的子集当且仅当：$|A|=|B|$ ； $\forall B_i=1,A_i=1$</p>
<p>现在给 $01$ 串 $S$ ，问它所有的子集的合法变化结果数的总和为多少。</p>
</blockquote>
<p>不容易对子集直接求和，考虑解码时是 $S$ 子集的数量，设 $f(S)$ 表示字符串为 $S$ 时的答案</p>
<p>对于字符串的第一个字符：</p>
<ul>
<li><p>$0/1$</p>
<p>与其他部分编码无关，$S_1=1$ 时，编码字符串第一个可能是 $0/1$ , $\therefore f(S_{1\sim |S|})=2\times f(S_{2\sim |S|})$ ；$S_1=0$ 时，编码第一个只能是 $0$ , $\therefore f(S_{1\sim |S|})=f(S_{2\sim |S|})$</p>
</li>
<li><p>左括号</p>
<p>编码字符串开头为 $P\times k$ ，其中 $P$ 是字符串 $A$ 的代码，满足 $k\times |A|\leq |S|$ ，且 $\underbrace{A+A+…+A}_{k个}$ 是 $S_{1\sim k\times |A|}$ 的子集，即 $A$ 是 $S_{1\sim |A|},S_{|A|+1\sim 2\times |A|},…,S_{(k-1)\times |A|+1\sim k\times |A|}$ 的子集</p>
</li>
</ul>
<script type="math/tex; mode=display">\therefore f(S)=(1+S_1)\times f\left(S_{2\sim |S|}\right) + \sum_{|A|=1}^{|S|} \sum_{k=1}^{\left\lfloor\frac{|S|}{|A|} \right\rfloor} f\left( g\left(S,k,|A| \right)\right)\times f\left(S_{k\times |A|+1\sim |S|} \right)</script><p>其中 $g(S,k,|A|)$ 表示 $S_{1\sim |A|}\land S_{|A|+1\sim 2\times |A|}\land …\land S_{(k-1)\times |A|+1\sim k\times |A|}$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int __int128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll __int128</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line">map&lt; pair&lt;ll,<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; f;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">111</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(pair&lt;ll,<span class="keyword">int</span>&gt; now)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!now.second) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(f.<span class="built_in">count</span>(now)) <span class="keyword">return</span> f[now];</span><br><span class="line">	rei ans=(ll) <span class="built_in">dfs</span>( <span class="built_in">mk</span>(now.first&gt;&gt;<span class="number">1</span>,now.second<span class="number">-1</span>))*((now.first&amp;<span class="number">1</span>)+<span class="number">1</span>)%mod;</span><br><span class="line">	<span class="keyword">for</span>(rei A=<span class="number">1</span>;A&lt;=(now.second&gt;&gt;<span class="number">1</span>);++A)&#123;</span><br><span class="line">		ll S=((ll)<span class="number">1</span>&lt;&lt;A)<span class="number">-1</span>,tmp=now.first,sum=tmp&amp;S;</span><br><span class="line">		tmp&gt;&gt;=A; sum&amp;=tmp&amp;S; tmp&gt;&gt;=A;</span><br><span class="line">		<span class="keyword">for</span>(rei k=now.second-A-A;k&gt;=<span class="number">0</span>;k-=A,sum&amp;=tmp&amp;S,tmp&gt;&gt;=A) ans=(ans+(ll) <span class="built_in">dfs</span>(<span class="built_in">mk</span>(sum,A))*<span class="built_in">dfs</span>(<span class="built_in">mk</span>(tmp,k))%mod)%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f[now]=ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s); n=<span class="built_in">strlen</span>(s);</span><br><span class="line">	ll S=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;=n<span class="number">-1</span>;++i) S=S&lt;&lt;<span class="number">1</span>|(s[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">dfs</span>(<span class="built_in">mk</span>(S,n)));</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>给定一个周长为 $C$ 的圆周，和 $N$ 段 (半径与圆相同的) 圆弧，第 $i$ 段圆弧的长度为 $L_i$ ，现在，每段弧的位置在圆周上均匀分布：具体地，在圆周上等概率随机一个点，作为弧 $L_i$ 的终点。不同的弧的位置是互相独立的，即它们有相应的概率相交。求有多大的概率，使得这 $N$ 段圆弧的并覆盖整个圆周？</p>
</blockquote>
<p><strong>环上的问题并不是容易处理，因此首先固定一个点作为起点</strong></p>
<p>一条弧的端点是一个比较好的选择，因为<strong>这样一条弧覆盖的就是整条链的前缀</strong></p>
<p>考虑除了弧 $i$ 外剩下的弧，它们需要覆盖 $[L_i,N)$ 这段区间，不过，有可能存在一些弧包含了 $i$ ，从而它们覆盖了一个前缀和一个后缀</p>
<p>对于这种情况，可以通过指定 $i$ 是最长的弧 (即 $L_i=\max\{L_1,L_2,…,L_N\}$ ) 来避免</p>
<p>然后问题就转化为了一个<strong>连续型的线段覆盖问题</strong></p>
<p>如果整个问题是离散的，那么容易通过 $DP$ 来解决，那现在是连续的，就要考虑化连续为离散</p>
<p>设弧 $i$ 的起点为 $P_i$ ，终点为 $P_i+L_i$ ，由于 $L_i\in \Z$ ，因此将 $P_i$ 拆成 $[P_i]+\{P_i\}$ ，$[P_i]$ 是一个 $[0,N)$ 上等概率分布的整型 (离散型) 随机变量，$\{P_i\}$ 是一个在 $[0,1)$ 上均匀分布的实随机变量</p>
<p>考察整个问题，整个圆弧能否被覆盖，更进一步地，某两条弧是否相交，可以发现，只和它们 $[P)i]$ 的值以及 $\{P_i\}$ 的大小关系” 有关</p>
<p>设 $P_i\leq P_j$ ，于是 $i,j$ 相交等价于 $[P_i]+\{P_i\}+L_i\geq [P_j]+\{P_j\}$ 若 $[P_i]+L_i\not ={P_j}$ ，则小数部分不影响不等号；否则 ，则 $[P_i]+\{P_i\}+L_i\geq [P_j]+\{P_j\} \Leftrightarrow \{P_i\}\geq \{P_j\}$</p>
<p>由于 $\{P_i\}$ 是独立同分布随机变量，因此它们的大小关系均匀分布的，由<strong>随机变量的连续性</strong>知，可以不妨假设 $\{P_i\}$ 两两不同，这不影响最终结果</p>
<p>那么，对每种可能的 $\{P_i\}$ 的大小关系，求出对应的答案 (概率)，然后最后再除以 $(N-1)!$ 就可以了</p>
<p>考虑对于一种特定的大小关系，如何计算概率</p>
<p>由于整个问题只和 $\{P_i\}$ 相对大小有关，设这 $N-1$ 个 $\{P_i\}$ 构成的集合恰为 $\left\{\frac{1}{N},\frac{2}{N},…,\frac{N-1}{N}\right\}$</p>
<p>每个 $P_i$ 的分布变成离散的：$0+\frac{i}{N},1+\frac{i}{N},…,(C-1)+\frac{i}{N}$</p>
<p>变得离散后，考虑计算方案数了，即，每段弧有 $C$ 种选择方案，求它们覆盖整个圆周的方案数</p>
<p>经典的状态压缩 $DP$ : 设 $f_{S,r}$ 表示用 $S$ 中的弧，最远覆盖到 $r$ (即 $[0,r]$ 被完全覆盖，$r$ 为右端点) 的方案数</p>
<p>边界是 $f_{0,L_N}=1$ (不妨设 $L_N=\max\{L_1,L_2,…,L_N\}$ ，注意最长的弧是预先放置好的)</p>
<p>考虑转移，枚举每个位置 ( $\frac{1}{N}$ 的倍数)，找到这个位置所能插入的弧 $i$ ，对于 $i\notin S$ ，将 $i$ 插入 $S$</p>
<p>同时，$r$ 需要在当前的起点后面，设这个弧能覆盖的右端点为 $to=\min\{P_i+L_i,C\}$ ，则转移为 $\displaystyle{f_{S\cup {i},\max\{r,to\}}+=f_{S,r}}$</p>
<p>$f_{U,C}$ 为总方案数，乘上 $\frac{1}{C^{N-1}}$ 即得概率</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,L,ALL,a[N],f[<span class="number">32</span>][<span class="number">324</span>];</span><br><span class="line">ld ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> x,<span class="keyword">const</span> <span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">return</span> x&lt;y ? x : y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> x,<span class="keyword">const</span> <span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">return</span> x&lt;y ? y : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ld <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,len=n*L+L;</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">	f[<span class="number">0</span>][ (n+<span class="number">1</span>)*a[n] ]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;len;++i)</span><br><span class="line">		<span class="keyword">if</span>(i%(n+<span class="number">1</span>))&#123;</span><br><span class="line">			rei c=i%(n+<span class="number">1</span>)<span class="number">-1</span>,to=<span class="built_in">min</span>(i+(n+<span class="number">1</span>)*a[c],len);</span><br><span class="line">			<span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;=ALL;++j) <span class="keyword">if</span>(!(j&gt;&gt;c&amp;<span class="number">1</span>)) <span class="keyword">for</span>(rei k=i;k&lt;=len;++k) f[j|<span class="number">1</span>&lt;&lt;c][ <span class="built_in">max</span>(k,to) ]+=f[j][k];</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> f[ALL][i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> C=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;L);</span><br><span class="line">	ALL=~(<span class="number">-1</span> &lt;&lt; --n);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">	<span class="built_in">sort</span>(a,a+n+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">do</span> ans+=<span class="built_in">solve</span>(),++C;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">next_permutation</span>(a,a+n));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.12Lg\n&quot;</span>,ans / (C*<span class="built_in">powl</span>(L,n)));</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>思维</tag>
        <tag>贪心</tag>
        <tag>dp</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title>10901202-AGC024</title>
    <url>/2021/09/01/AGC024/</url>
    <content><![CDATA[<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>给定一颗点数为 $N$ 的无根树，对于点 $u,v$ 若以 $u$为根的树与以 $v$ 为根的树同构，则 $uv$ 染上同一种颜色 ，可以给这个树加若干点，求加完点后树最少有多少颜色，以及此时最少有多少叶子节点</p>
</blockquote>
<p>考虑当深度相同时树同构，那么最终树比绑定时某个点或边为根，深度相同的所有点的子树同构，颜色数为深度</p>
<p>那么枚举每个点为根，找最小深度即可</p>
<p>对于最小叶节点树，深度相同的所有点子树同构相当于深度相同的点度数相同，对每一层连向下一层数取最大值相乘即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line"><span class="keyword">int</span> deg[N],mxdeg[N],dep[N];</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">PIL res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t)</span></span>&#123; G[f].<span class="built_in">push_back</span>(t),G[t].<span class="built_in">push_back</span>(f),++deg[f],++deg[t];&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">chmax</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> y)</span></span>&#123; x&lt;y ? x=y : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) dep[i]=<span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(u),dep[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v) q.<span class="built_in">push</span>(v),dep[v]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        rei u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">chmax</span>(mxdeg[dep[u]],deg[u]),<span class="built_in">chmax</span>(rt,dep[u]);</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">0</span>,v;i&lt;G[u].<span class="built_in">size</span>();++i) <span class="keyword">if</span> (!dep[ v=G[u][i] ]) dep[v]=dep[u]+<span class="number">1</span>,q.<span class="built_in">push</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PIL <span class="title">work</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    PIL rt;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) mxdeg[i]=<span class="number">0</span>;</span><br><span class="line">    rt=(PIL)&#123; <span class="built_in">bfs</span>(u,v),mxdeg[<span class="number">1</span>]-(v!=<span class="number">0</span>)&#125;;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (mxdeg[i]==<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        rt.second*=(mxdeg[i]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(v) rt.second*=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;1 2&quot;</span>),<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,u,v;i&lt;n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v),<span class="built_in">add</span>(u,v);</span><br><span class="line">    res.first=<span class="number">200000</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        res=<span class="built_in">min</span>(res,<span class="built_in">work</span>(i,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;G[i].<span class="built_in">size</span>();++j) res=<span class="built_in">min</span>(res,<span class="built_in">work</span>(i,G[i][j]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,res.first,res.second);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>给定 $n,m,k$ ，求满足条件的 $(n+1)$ 元序列组 $A_0,A_1,…A_n)$ 的数量，其中满足： $\forall i$ , $A_i$ 由 $1\sim k$ 组成且长度为 $i$ ； $\forall i,i&gt;1$ ，序列 $A_{i-1}$ 是 $A_i$ 的子序列 ； $\forall i,i&gt;1$ ，序列 $A_{i-1}$ 在字典序意义下严格小于 $A_i$</p>
</blockquote>
<p>在 $aaab$ 中插入 $a$ 形成 $aaaab$ 时，字典序变小</p>
<p>那么每次将 $a$ 放在 $A_i$ 最后则不会算重</p>
<p>那么在 $A_i\rightarrow A_{i+1}$ 的过程中，满足加入的 $a$ 大于其后面的数（包括在末尾的情况）</p>
<p>设 $dp_{i,j,k}$ 表示第 $i$ 个操作，放到了数字 $j$ ，前面有 $k+1$ 个位置可以放</p>
<p>有转移：</p>
<script type="math/tex; mode=display">\begin{cases}
    dp_{i,j,k-1}+=dp_{i,j,k} &\text{当前不放 , $k>0$} \\
    dp_{i,j+1,k}+=dp_{i,j,k} &\text{当前不放 , $k=0$} \\
    dp_{i+1,j,k}+=dp_{i,j,k}\times (k+1) &\text{当前放 ，进行的操作有 $k+1$ 种选择} \\
\end{cases}</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">310</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,mod,dp[N][N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;mod);</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(rei k=i;k&gt;=<span class="number">0</span>;--k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!dp[i][j][k]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(!k) dp[i][j+<span class="number">1</span>][i]=(dp[i][j+<span class="number">1</span>][i]+dp[i][j][k])%mod;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j][k<span class="number">-1</span>]=(dp[i][j][k<span class="number">-1</span>]+dp[i][j][k])%mod;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;=n<span class="number">-1</span>) dp[i+<span class="number">1</span>][j][k]=(dp[i+<span class="number">1</span>][j][k]+(ll) (k+<span class="number">1</span>)*dp[i][j][k]%mod)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dp[n][m][<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>一个 $0/1$ 串集合 $S$ ，其中每个串的长度不超过 $N$ ，求出 $S$ 中至少是 $K$ 个串的子序列的最长串，输出字典序最小的解。由于 $S$ 很大，这样描述 $S$ ：给出 $N+1$ 个 $01$ 串，第 $i$ 个长度为 $2^{i-1}$ ；第 $i$ 个字符串的第 $j$ 个字符代表数字为 $j-1$，长度为 $i-1$ 的二进制表示是否出现在 $S$ 中</p>
</blockquote>
<p>这个才应该是子序列自动机的模板题吧qwq</p>
<p>直接考虑所有 $2^{n+1}-1$ 个长度 $0\sim n$ 的 $01$ 串，计算其中有多少是 $S$ 子串的子序列</p>
<p>考虑如何判断串 $A=\{0101110\}$ 是串 $B={1010111001}$ 的子序列：</p>
<p>用 $A$ 的第一位 $0$ 去匹配 $B$ 中的第一个 $0$ ，转化为 $A=\{101110\},b=\{10111001\}$</p>
<p>对于 $01$ 串 $x\in S$ ,希望 $x$ 的所有子序列 $y$ 的 $val$ 值加 $1$ ，即，用 $dp$ 维护路径数</p>
<p>对于匹配的两个字符串 $A,B 有 |A|+|B|\leq n=20$ 只记录 $A+B$ ，长度，分界点，状压出路径即可</p>
<p>对于每次转移：</p>
<script type="math/tex; mode=display">\begin{cases}
    B=\empty &\text{直接结束} \\
    删除B的第一个1及前面的所有，A加上1 \\
    删除B的第一个0及前面的所有，A加上0 \\
\end{cases}</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1</span>&lt;&lt;<span class="number">22</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> Data[N][<span class="number">21</span>],n,k,mem[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> mx=INF,mxl=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> sta,<span class="keyword">int</span> nums,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    mem[ sta|(<span class="number">1</span>&lt;&lt;len) ]+=nums;</span><br><span class="line">    <span class="keyword">if</span>(mem[ sta|(<span class="number">1</span>&lt;&lt;len) ]&gt;=k)</span><br><span class="line">        <span class="keyword">if</span>(mxl&lt;len) mxl=len,mx=sta;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(mxl==len) mx=<span class="built_in">min</span>(mx,sta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">        <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;i);++j)&#123;</span><br><span class="line">            rei tmp=j; tmp|=<span class="number">1</span>&lt;&lt;i;</span><br><span class="line">            Data[tmp][<span class="number">0</span>]+=(s[j]==<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;=n;++i)&#123;<span class="comment">//拿了i个</span></span><br><span class="line">        <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;(n+<span class="number">1</span>));++j)&#123;<span class="comment">//一共有n+1位</span></span><br><span class="line">            <span class="keyword">if</span>(!Data[j][i]) <span class="keyword">continue</span>;<span class="comment">//t-s</span></span><br><span class="line">            ull s=j&amp;((<span class="number">1</span>&lt;&lt;i)<span class="number">-1</span>),t=j&gt;&gt;i;</span><br><span class="line">            rei l=(<span class="number">32</span>-__builtin_clz(t))<span class="number">-1</span>;<span class="comment">//有t多少位</span></span><br><span class="line">            <span class="keyword">if</span>(i) <span class="built_in">update</span>(s,Data[j][i],i);</span><br><span class="line">            <span class="keyword">if</span>(!l) <span class="keyword">continue</span>;</span><br><span class="line">            t^=(<span class="number">1</span>&lt;&lt;l);</span><br><span class="line">            rei first1=(<span class="number">32</span>-(t?__builtin_clz(t):<span class="number">32</span>));<span class="comment">//第一个1的位置</span></span><br><span class="line">            ull num=t&lt;&lt;(<span class="number">32</span>-l);</span><br><span class="line">            rei first0=l ? (l-((~num) ? __builtin_clz(~num) : l)) : <span class="number">0</span>,newt,news;</span><br><span class="line">            <span class="keyword">if</span>(first1&gt;<span class="number">0</span>)&#123;<span class="comment">//删去1</span></span><br><span class="line">                newt=t&amp;((<span class="number">1</span>&lt;&lt;first1)<span class="number">-1</span>);</span><br><span class="line">                newt|=(<span class="number">1</span>&lt;&lt;first1<span class="number">-1</span>);</span><br><span class="line">                news=(s&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>;</span><br><span class="line">                Data[ (newt&lt;&lt;(i+<span class="number">1</span>))|news ][i+<span class="number">1</span>]+=Data[j][i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(first0&gt;<span class="number">0</span>)&#123;<span class="comment">//删去0</span></span><br><span class="line">                newt=t&amp;((<span class="number">1</span>&lt;&lt;first0)<span class="number">-1</span>);</span><br><span class="line">                newt|=(<span class="number">1</span>&lt;&lt;first0<span class="number">-1</span>);</span><br><span class="line">                news=(s&lt;&lt;<span class="number">1</span>);</span><br><span class="line">                Data[ (newt&lt;&lt;(i+<span class="number">1</span>))|news ][i+<span class="number">1</span>]+=Data[j][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mx==INF) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>),<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=mxl;i;--i) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,(mx&amp;(<span class="number">1</span>&lt;&lt;i<span class="number">-1</span>)) ? <span class="number">1</span> : <span class="number">0</span>); <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>思维</tag>
        <tag>dp</tag>
        <tag>子序列自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>20901202-AGC025</title>
    <url>/2021/09/02/AGC025/</url>
    <content><![CDATA[<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>给定 $n,D_1,D_2$ ,要求构造一个在 $2n\times 2n$ 的网格中选出 $n^2$ 个点的方案，是任意两点间距离不为 $\sqrt{D_1}$ 或 $\sqrt{D_2}$</p>
</blockquote>
<p>由题有 $|X|=4\times N^2$ ，要求 $|S|=N^2$ ，即，需要找到 $\frac{1}{4}$ 的点</p>
<p>容易想到当需要 $\frac{1}{2}$ 的点时，(即只有一个禁止距离时，$|S|=2\times N^2$) ，此时用<strong>二分图</strong>恰好达到目的</p>
<p>即：<strong>对于 $A,B\in X$ ，若 $|AB|=\sqrt{D}$ 则连接 $AB$ ，最后得到图 $G$ ，要求 $G$ 独立集且包含至少一半的节点，显然这是二分图</strong></p>
<p>考虑图 $G$ 是否为二分图(考虑到欧几里得距离涉及到平方和，从数论角度)：</p>
<p>设 $|AB|^2=4^k\times D$ ，只考虑 $\mod 2^k$:</p>
<ul>
<li><p>$D\equiv 1\pmod{2}$</p>
<p>此时 $|AB|^2\equiv (A_x+A_y)+(B_x+B_y)\pmod{2}$ ，则 $A_x+A_y\not\equiv B_x+B_y\pmod{2}$ ，则，按照 $x+y$ 的奇偶性分为两组，有边相连的二点必定在不同组中，满足二分图</p>
</li>
<li><p>$D\equiv 2\pmod{4}$</p>
<p>同上易得 $A_x-B_x\equiv 1\pmod{2} \wedge A_y-B_y\equiv \pmod{2}$ ，即 $A_x\not\equiv B_x\pmod{2}$ ，则，按照 $x$ 的奇偶性分组也满足二分图</p>
</li>
<li><p>$D\equiv 0\pmod{4}$</p>
<p>同时易得 $A_x\equiv B_x\pmod{2}\wedge A_y\equiv B_y\pmod{2}$ ，此时按照 $(x\mod 2,y\mod 2)$ 分为四个等价类，有边相连的点一定在同一个里面，对一个等价类，缩放为 $\frac{x}{2},\frac{y}{2},\frac{D}{4}$ ，归纳结论成立</p>
</li>
</ul>
<p>再考虑两个距离：自由组合即可，即，独立考虑两种颜色，进行不同染色方式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">610</span>;</span><br><span class="line"><span class="keyword">int</span> n,D1,D2,d;</span><br><span class="line"><span class="keyword">int</span> a[N][N],col[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">color</span><span class="params">(<span class="keyword">int</span> dist,<span class="keyword">int</span> bit)</span></span>&#123;</span><br><span class="line">    rei len=<span class="built_in">ctz</span>(dist)/<span class="number">2</span>; dist&gt;&gt;=<span class="number">2</span>*len;</span><br><span class="line">    <span class="keyword">if</span>((dist&amp;<span class="number">3</span>)==<span class="number">1</span>) <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;n;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;n;++j) a[i][j]|=((i^j)&gt;&gt;len&amp;<span class="number">1</span>)&lt;&lt;bit;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((dist&amp;<span class="number">3</span>)==<span class="number">2</span>) <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;n;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;n;++j) a[i][j]|=(i&gt;&gt;len&amp;<span class="number">1</span>)&lt;&lt;bit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;D1,&amp;D2); d=n*n,n*=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">color</span>(D1,<span class="number">0</span>),<span class="built_in">color</span>(D2,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;n;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;n;++j) ++col[ a[i][j] ];</span><br><span class="line">    rei c=<span class="built_in">max_element</span>(col,col+<span class="number">4</span>)-col;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;n &amp;&amp; d;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;n &amp;&amp; d;++j) <span class="keyword">if</span>(a[i][j]==c) --d,<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,i,j);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>给出 $n$ 节点的树和 $m$ 条树上路径，为每一路径定向，第 $i$ 条边 $(a_i,b_i)$ 的权值为：同时被某两条路径沿 $a_i\rightarrow b_i,b_i\rightarrow a_i$ 经过的条数，求最大权值和及定向方案</p>
</blockquote>
<p>这是一个阴间构造题：</p>
<p>设经过每条边的路径数 $c_e$ ，则答案上界 $\sum_{\min\{2,c_e\}}$</p>
<p>归纳法证明：</p>
<ul>
<li>$n=1$ 显然成立</li>
<li>$n&gt;1$ ，设与叶子 $v$ 相连的边 $e$ ,点为 $w$<ul>
<li>$c_e=0$ 直接删去 $v$</li>
<li>$c_e=1$ 将路径 $(v,x)$ 替换为 $(w,x)$</li>
<li>$c_e&gt;1$ 任意选择两条路径 $(v,a),(v,b)$ ，设两路径的交 $(v,c)$ ,那么 $v\rightarrow c$ 的所有边贡献都为 $2$ ，剩下的路径等价表示为 $(a,b)$</li>
</ul>
</li>
</ul>
<p>执行到最后一个点即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e3</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> A[N],B[N],ans,a[N&lt;&lt;<span class="number">1</span>],b[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> q[N],anc[N],deg[N],dep[N];</span><br><span class="line"><span class="keyword">int</span> dir[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> ch[N&lt;&lt;<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">bool</span> rev[N&lt;&lt;<span class="number">1</span>],vis[N],mark[N&lt;&lt;<span class="number">1</span>],used[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span> <span class="keyword">int</span> ver,Next; <span class="built_in">edge</span>(<span class="keyword">int</span> ver=<span class="number">0</span>,<span class="keyword">int</span> Next=<span class="number">0</span>):<span class="built_in">ver</span>(ver),<span class="built_in">Next</span>(Next)&#123;&#125;&#125;;</span><br><span class="line">vector&lt;edge&gt; G;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123; G.<span class="built_in">push_back</span>(<span class="built_in">edge</span>(v,head[u])),head[u]=G.<span class="built_in">size</span>()<span class="number">-1</span>; G.<span class="built_in">push_back</span>(<span class="built_in">edge</span>(u,head[v])),head[v]=G.<span class="built_in">size</span>()<span class="number">-1</span>; ++deg[u],++deg[v];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!u) <span class="keyword">return</span>;</span><br><span class="line">    c^=rev[u]; dir[u]=c;</span><br><span class="line">    <span class="built_in">dfs</span>(ch[u][<span class="number">0</span>],c);</span><br><span class="line">    <span class="built_in">dfs</span>(ch[u][<span class="number">1</span>],c^<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getdep</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(rei i=head[u];~i;i=G[i].Next)&#123;</span><br><span class="line">        rei v=G[i].ver; <span class="keyword">if</span>(v==anc[u]) <span class="keyword">continue</span>;</span><br><span class="line">        dep[v]=dep[u]+<span class="number">1</span>,anc[v]=u;</span><br><span class="line">        <span class="built_in">getdep</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> c)</span></span>&#123; used[x][c] ? <span class="number">0</span> : (used[x][c]=<span class="number">1</span>,++ans);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,a,b;i&lt;n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b),<span class="built_in">addedge</span>(a,b);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=m;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;A[i],&amp;B[i]),a[i]=A[i],b[i]=B[i];</span><br><span class="line">    rei hd=<span class="number">0</span>,tl=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>(deg[i]==<span class="number">1</span>) q[tl++]=i;</span><br><span class="line">    rei T=n,cnt=m;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        rei u=q[hd++]; vis[u]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(rei i=head[u],y;~i;i=G[i].Next)&#123; y=G[i].ver; <span class="keyword">if</span>(--deg[y]==<span class="number">1</span>) q[tl++]=y;&#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; E;</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=cnt;++i) <span class="keyword">if</span>(!mark[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==u &amp;&amp; b[i]==u)&#123; <span class="built_in">dfs</span>(i,<span class="number">0</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span>(b[i]==u) <span class="built_in">swap</span>(a[i],b[i]),rev[i]^=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==u) E.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        rei w=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(rei i=head[u],y;~i;i=G[i].Next)&#123;</span><br><span class="line">            y=G[i].ver; <span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">            w=y; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(E.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(E.<span class="built_in">size</span>()==<span class="number">1</span>)&#123; rei e=E[<span class="number">0</span>]; a[e]=w; <span class="keyword">break</span>;&#125;</span><br><span class="line">            rei x=E.<span class="built_in">back</span>(); E.<span class="built_in">pop_back</span>();</span><br><span class="line">            rei y=E.<span class="built_in">back</span>(); E.<span class="built_in">pop_back</span>();</span><br><span class="line">            ++cnt; ch[cnt][<span class="number">0</span>]=x,ch[cnt][<span class="number">1</span>]=y;</span><br><span class="line">            a[cnt]=b[y],b[cnt]=b[x];</span><br><span class="line">            mark[x]=mark[y]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getdep</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dir[i]) <span class="built_in">swap</span>(A[i],B[i]);</span><br><span class="line">        rei u=A[i],v=B[i];</span><br><span class="line">        <span class="keyword">while</span>(dep[u]&gt;dep[v]) <span class="built_in">upd</span>(u,<span class="number">0</span>),u=anc[u];</span><br><span class="line">        <span class="keyword">while</span>(dep[u]&lt;dep[v]) <span class="built_in">upd</span>(v,<span class="number">1</span>),v=anc[v];</span><br><span class="line">        <span class="keyword">while</span>(u!=v)&#123;</span><br><span class="line">            <span class="built_in">upd</span>(u,<span class="number">0</span>),u=anc[u];</span><br><span class="line">            <span class="built_in">upd</span>(v,<span class="number">1</span>),v=anc[v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=m;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,A[i],B[i]);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>给出长度为 $n$ 的二进制数 $x$ 和长度 $m$ 的 $y$ ，进行 $k$ 次操作：设 $z=x\And y，x+=z,y+=z$ ，求出操作后的 $x,y$</p>
</blockquote>
<p>暴力模拟啊嗯</p>
<p>从高位到低位每位重复模拟 $k$ 遍处理：</p>
<p>考虑 $(1,1)$ 进位时：</p>
<p>遇到两个数同一位不相同的情况 $(0,1),(1,0)$ 则暴力进位</p>
<p>而遇到连续的一段 $(0,0)$ 可以直接移过去，</p>
<p>栈维护下标从大到小(当前位置)的 $(0,1),(1,0)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id,par;</span><br><span class="line">&#125;sta[N],tmp[N];</span><br><span class="line"><span class="keyword">int</span> n,m,k,top,cnt,ns[N],nt[N],as[N],at[N];</span><br><span class="line"><span class="keyword">char</span> s[N],t[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,t+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">reverse</span>(s+<span class="number">1</span>,s+n+<span class="number">1</span>);<span class="built_in">reverse</span>(t+<span class="number">1</span>,t+m+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) ns[i]=s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=m;++i) nt[i]=t[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    rei T=<span class="built_in">max</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(rei i=T;i;--i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ns[i]==<span class="number">1</span> &amp;&amp; nt[i]==<span class="number">1</span>)&#123;</span><br><span class="line">            rei op=k,pos=i,x=<span class="number">3</span>;cnt=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(top)&#123;</span><br><span class="line">                <span class="keyword">if</span>(x==<span class="number">3</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(op&gt;=sta[top].id-pos)&#123;</span><br><span class="line">                        op-=sta[top].id-pos; pos=sta[top].id;</span><br><span class="line">                        tmp[++cnt]=(node)&#123; pos,x^sta[top].par&#125;;</span><br><span class="line">                        x=x&amp;sta[top].par;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(sta[top].id==pos+<span class="number">1</span>)&#123;</span><br><span class="line">                        pos=sta[top].id;</span><br><span class="line">                        x^sta[top].par ? x=<span class="number">3</span> : x=x&amp;sta[top].par;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                --top;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(x!=<span class="number">0</span> &amp;&amp; x!=<span class="number">3</span>)&#123; ++pos; tmp[++cnt]=(node)&#123;pos,x&#125;;&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(x)&#123; pos+=op; as[pos]=at[pos]=<span class="number">1</span>;&#125;</span><br><span class="line">            <span class="keyword">for</span>(rei j=cnt;j;--j) sta[++top]=tmp[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ns[i] || nt[i]) sta[++top]=(node)&#123; i,ns[i]&lt;&lt;<span class="number">1</span>|nt[i]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=top;++i) as[ sta[i].id ]=(sta[i].par&gt;&gt;<span class="number">1</span>)&amp;<span class="number">1</span>,at[ sta[i].id ]=sta[i].par&amp;<span class="number">1</span>;</span><br><span class="line">    rei c=T+k; <span class="keyword">while</span>(!as[c]) --c; <span class="keyword">for</span>(rei i=c;i&gt;=<span class="number">1</span>;--i) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,as[i]); <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    c=T+k; <span class="keyword">while</span>(at[c]==<span class="number">0</span>) --c; <span class="keyword">for</span>(rei i=c;i;--i) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,at[i]); <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>思维</tag>
        <tag>数论</tag>
        <tag>模拟</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>30901202-AGC026</title>
    <url>/2021/09/03/AGC026/</url>
    <content><![CDATA[<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>一张无限行，$N$ 列的直方图，$(i,j)$ 表示左数第 $i$ 列，下数第 $j$ 行的方格，第 $i$ 列高度 $h_i$ ，将每个的小方格染上红蓝色，使对于整个方格表的任意一个 $2\times 2$ 的子矩形，若四个小方格均存在，则颜色为 二红二蓝</p>
</blockquote>
<p><del>这个好像有 $O(n)$ 的笛卡尔树做法，但我没看懂qwq</del></p>
<p>设 $h=\min\{h_i\}$ ，将直方图分成 $h\times N$ 的完全网格图以及若干子直方图</p>
<p>容易想到分治做法</p>
<p>先考虑完全网格图：对于最底层，有 $2^N$ 种方案，其中：</p>
<ul>
<li><p>存在相邻同色格子</p>
<p>那么上面一行的对应格子就应该反色，向两边推导得<strong>这一行即为最底层的反色</strong>，此时方案唯一</p>
</li>
<li><p>不存在</p>
<p>则此时，下一行为 $RBRB…/BRBR…$ ，即，有 $2^h$ 种方案数</p>
</li>
</ul>
<p>综上，对于完全网格图有 $2^N+2^h-2$ 种</p>
<p>在考虑存在子直方图的情况：</p>
<p>由上面可以得到，最底层是否有相邻同色格是一个关键信息</p>
<p>分治的最终要统计两个信息：$f_A$ 表示最底层任意两个格子不同色的方案数，$f_C$ 表示染色方案总数</p>
<p>设子直方图的结果为 $(u_A,u_C),(v_A,v_C)…$</p>
<p>则所有子直方图有 $u_A\times v_A\times …$ 种选择，则 $f_A=2^h\times u_A\times v_A$</p>
<p>再考虑 $f_C$ ：</p>
<p>设 $R_0$ 为完全网格图最上面一行中存在相邻两个方格同色的方案数，对于该方案，完全网格图的染色方法唯一，则 $f_C=R_0+2\times f_A$</p>
<p>此时只考虑这最上面一行的情况</p>
<p>设子直方图 $u$ 范围 $[l,r]$ ，考虑其所在的方格如何填充</p>
<p>对于 $u_A-u_C$ 种方案(存在相邻同色格)，只有一种填法；而对于 $u_C$ 种方案(任意相邻不同色)，下面有 $2$ 种，则，$r-l+1$ 个小方块共有 $u_A-u_C+2\times u_C=u_A+u_C$ 种填法</p>
<p>再考虑 $h_i=h$ 的方格，显然填法任意，方案数 $2^W$ ，其中 $W$ 是满足 $h_i=h$ 的方格数</p>
<p>最后再减去 $2\times u_A\times v_A…$ 种相邻方格不同色的方案</p>
<script type="math/tex; mode=display">f_C=2^W\times (u_A+u_C)\times (v_A+v_C)...-2\times u_A\times v_A...+2\times f_A</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">const</span> <span class="keyword">int</span> y)</span></span>&#123; x+=y-mod,x+=x&gt;&gt;<span class="number">31</span>&amp;mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">const</span> <span class="keyword">int</span> y)</span></span>&#123; x-=y,x+=x&gt;&gt;<span class="number">31</span>&amp;mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">qpow</span><span class="params">(ll a,<span class="keyword">int</span> n,ll c=<span class="number">1</span>)</span></span>&#123; <span class="keyword">for</span>(;n;n&gt;&gt;=<span class="number">1</span>,a=a*a%mod) <span class="keyword">if</span>(n&amp;<span class="number">1</span>) c=c*a%mod;<span class="keyword">return</span> c;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PII <span class="title">solve</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt; &amp;h)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j=<span class="number">-1</span>;</span><br><span class="line">    rei n=h.<span class="built_in">size</span>(),x,y=<span class="number">0</span>,P1=<span class="number">1</span>,P2=<span class="number">1</span>,C1,C2,W=n;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; S; x=*std::<span class="built_in">min_element</span>(h.<span class="built_in">begin</span>(),h.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line">		<span class="keyword">if</span>(i==n || h[i]==x)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j+<span class="number">1</span>==i) ++j;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(j+<span class="number">2</span>==i) ++j,P1=<span class="built_in">qpow</span>(<span class="number">2</span>,h[j]-x,P1),P2=<span class="built_in">qpow</span>(<span class="number">2</span>,h[j]-x,P2),++j;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				W-=i-j<span class="number">-1</span>,S.<span class="built_in">clear</span>(),S.<span class="built_in">reserve</span>(i-j<span class="number">-1</span>);</span><br><span class="line">				<span class="keyword">for</span>(++y;++j&lt;i;S.<span class="built_in">emplace_back</span>(h[j]-x));</span><br><span class="line">				std::<span class="built_in">tie</span>(C1,C2)=<span class="built_in">solve</span>(S),P1=(ll)P1*(C1+C2)%mod,P2=(ll)P2*C2%mod;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	C2=<span class="built_in">qpow</span>(<span class="number">2</span>,x,P2),C1=<span class="built_in">qpow</span>(<span class="number">2</span>,W,P1),<span class="built_in">sub</span>(C1,P2),<span class="built_in">sub</span>(C1,P2);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">add</span>(C1,C2),<span class="built_in">PII</span>(C1,C2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,x;vector&lt;<span class="keyword">int</span>&gt; h;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n),h.<span class="built_in">reserve</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x),h.<span class="built_in">emplace_back</span>(x);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">solve</span>(h).first);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>长度为 $2\times n$ 的字符串 $S$ 由 $n$ 个 $a$ 和 $n$ 个 $b$ 构成，选择一个 $S$ 的子序列满足 $\forall 1\leq i\leq n$ ，$S$ 中第 $i$ 个出现的 $a$ 和 $S$ 中第 $i$ 个出现的 $b$ 要么都选，要么都不选，按照原顺序连接字符，求出字典序最大的一个</p>
</blockquote>
<p>设 $a_i$ 为 $a$ 第 $i$ 次出现，$b_i$ 同理</p>
<p>设法将字符串分为尽可能多的部分是每一部分 $ab$ 出现次数相同</p>
<p>对于每一部分：</p>
<ul>
<li><p>$\forall i,a_i&lt;b_i$</p>
<p>考虑原串中两个相邻的 $a$ ：$a_ia_j…b_i…b_j$ ，发现去掉 $a_j,b_j$ 会更优，贪心计算能得到的 $ab$ ，即，先选择 $a_1,b_1$ ，再找第一个满足 $a_i&gt;b_1$ 的 $i$ ，如此迭代</p>
</li>
<li><p>$\forall i,a_i&gt;b_i$</p>
<p>假设选择 $a_i,b_i$ 那么总可以选择 $a_{i+1},b_{i+1}$ 使答案更优，枚举 $i$ 即可</p>
</li>
</ul>
<p>考虑对于多个部分：</p>
<p>先对每一部分求出最优解，对于每一部分，要么选择最优解，要么为空串，($a_i&gt;b_i$ 时) 所有可得到的串(baba..)都不是最优串的前缀</p>
<p>选择一个串的条件时其大于等于之后所有串拼起来时长度与其相同的前缀</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3e3</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],b[N],bel[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">char</span> s[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line">string ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sol</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    string res;</span><br><span class="line">    rei l=<span class="number">1</span>; <span class="keyword">while</span>(a[l]&lt;L) ++l;</span><br><span class="line">    rei r=n; <span class="keyword">while</span>(a[r]&gt;R) --r;</span><br><span class="line">    <span class="keyword">if</span>(s[L]==<span class="string">&#x27;a&#x27;</span>)&#123;</span><br><span class="line">        rei cnt=<span class="number">1</span>,k=l;</span><br><span class="line">        <span class="keyword">for</span>(rei i=l;i&lt;=r;++i) <span class="keyword">if</span>(a[i]&gt;b[k]) ++cnt,k=i;</span><br><span class="line">        <span class="keyword">while</span>(cnt--) res.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span>),res.<span class="built_in">push_back</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(rei i=l;i&lt;=r;++i)&#123;</span><br><span class="line">            string now;</span><br><span class="line">            <span class="keyword">for</span>(rei j=b[i];j&lt;=R;++j) <span class="keyword">if</span>(bel[j]&gt;=i) now.<span class="built_in">push_back</span>(s[j]);</span><br><span class="line">            res=<span class="built_in">max</span>(res,now);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	ans=<span class="built_in">max</span>(ans,res+ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n); <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,x=<span class="number">0</span>,y=<span class="number">0</span>;i&lt;=(n&lt;&lt;<span class="number">1</span>);++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;a&#x27;</span>) a[++x]=i,bel[i]=x;</span><br><span class="line">        <span class="keyword">else</span> b[++y]=i,bel[i]=y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=(n&lt;&lt;<span class="number">1</span>),cnt=<span class="number">0</span>,last=(n&lt;&lt;<span class="number">1</span>);i;--i)&#123;</span><br><span class="line">        s[i]==<span class="string">&#x27;a&#x27;</span> ? ++cnt : --cnt;</span><br><span class="line">        <span class="keyword">if</span>(!cnt) <span class="built_in">sol</span>(i,last),last=i<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>$n$ 个物品 ，每个价值 $a_i$ ，$AB$ 轮流取，先手任意取(设 $x$)，后手可以取任意一个相邻的物品，设取 $x+1$ ，则两人将轮流往右取直到取至尽头，此时的先手重新选取一个点继续，直至所有都被取走，每取完一个物品后重新标号，两人均想让自己的物品价值最大，求最优策略下两人各获得的价值</p>
</blockquote>
<p>这里有一个神奇的贪心/博弈：即，<strong>在任意时刻，先手始终会最优</strong></p>
<p>从这个结论出发，考虑先手的选择：</p>
<ul>
<li><p>$n$ 为偶数</p>
<p>显然当且仅当先手选取开头或结尾时最优。因为若先手选取中间的一个，总会有一边使 $A$ 丧失先手权，那么显然不优</p>
</li>
<li><p>$n$ 为奇数</p>
<ul>
<li><p>$A$ 选择奇数位</p>
<p>类似上面的那个，$A$ 一定选择头</p>
</li>
<li><p>$A$ 选择偶数位</p>
<p>此时先手权始终在 $A$ ，直到 $B$ 将局面引导某一时候剩下奇数区间使 $A$ 直接走奇数位-头/尾</p>
<p>考虑 $A$ 此时如何选择，显然 $A$ 要使 $B$ 能引导的最小值最大</p>
<p>转化为选择若干偶数位置使每个相邻区间 $对 A 的贡献-对 B 的贡献$ 的最小值最大</p>
<p>二分贪心</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span></span>&#123;</span><br><span class="line">	rei MIN=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span>+<span class="number">1</span>;++i)</span><br><span class="line">		<span class="keyword">if</span>(s[i]+a[i*<span class="number">2</span>]-MIN&gt;=mid) MIN=<span class="built_in">min</span>(MIN,s[i]);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(i==n/<span class="number">2</span>+<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">	<span class="keyword">if</span>(n&amp;<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span>+<span class="number">1</span>;++i) s[i]=s[i<span class="number">-1</span>]+a[<span class="number">2</span>*i<span class="number">-1</span>]-a[<span class="number">2</span>*i];</span><br><span class="line">		rei l=<span class="number">-1e9</span>,r=<span class="number">1e9</span>,ans=<span class="number">-1e9</span>;</span><br><span class="line">		<span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">			rei mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			<span class="built_in">check</span>(mid) ? (ans=mid,l=mid+<span class="number">1</span>) : r=mid<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		rei sum=-s[n/<span class="number">2</span>+<span class="number">1</span>]+ans*<span class="number">2</span>,s0=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) s0+=a[i];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,(sum+s0)/<span class="number">2</span>,(s0-sum)/<span class="number">2</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		rei s1=<span class="number">0</span>,s2=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;i+=<span class="number">2</span>) s1+=a[i],s2+=a[i+<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(s1&lt;s2) <span class="built_in">swap</span>(s1,s2);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,s1,s2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>思维</tag>
        <tag>贪心</tag>
        <tag>博弈论</tag>
        <tag>分治</tag>
        <tag>笛卡尔树</tag>
      </tags>
  </entry>
  <entry>
    <title>70901202-AGC028</title>
    <url>/2021/09/07/AGC028/</url>
    <content><![CDATA[<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><blockquote>
<p>$N$ 个砖块，每个重量 $A_i$ ，进行以下操作：选择一个还未被移除的砖块并移除，代价是其和与其相邻的砖块的重量之和，定义两块砖 $x,y$ 相邻当且仅当 $\forall z(x\leq z\leq y)$ ，$z$ 没有被移除。共有 $N!$ 种移除的顺序，对于所有顺序计算移除所有 $N$ 块砖块的代价并计算和</p>
</blockquote>
<p>这个可以用草率的方法，这里记录以下笛卡尔树做法</p>
<p>针对这种所有方案之和的有 $\text{trick}$ : 均匀随机一个删除顺序，求代价的期望，最后乘 $n!$</p>
<p>每次删除一个位置并两边分开做，与笛卡尔树的建树方法类似。计算每个点的删除时间，删除一个点就在使其做根，然后两边接过来，发现形成一个笛卡尔树，其中<strong>下标满足 $\text{BST}$ 性质，删除时间满足小根堆性质</strong></p>
<p>一个位置的贡献就是其在笛卡尔树上的点深度，即，到根路径上点的个数， $\sum 期望深度*权值=代价的期望$</p>
<p>转化为如何求随机排列构成的笛卡尔树的期望深度：$E(depth_i)=\sum_j p(j\in anc(i))$ ，即， $j$ 是 $i$ 祖先的概率，不妨设 $j&lt;i$</p>
<p>考虑到笛卡尔树的结构，若 $j$ 是 $i$ 的祖先，则 $[j,i]$ 段中， $j$ 是最小值</p>
<p>也就是求：对于随机排列，区间 $[l,r]$ 中 $l$ 位置是最小值的概率：</p>
<p>先选择 $r-l+1$ 个位置放在区间里，剩余 $n-(r-l+1)$ 个位置随便排， $l$ 位置为最小值， $(r-l+1)-1$ 个位置再随便排，最后除以 $n!$ ，得概率 $\frac{1}{r-l+1}$</p>
<p>$j&gt;i$ 同理，则有 $E(depth_i)=H(i)+H(n-i+1)-1$ ，其中调和级数 $H(n)=\sum_{i=1}^n \frac{1}{i}$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> fac[N],fac_inv[N],inv[N],si[N];</span><br><span class="line"><span class="keyword">int</span> n,a[N];</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lim=<span class="number">1e5</span>;</span><br><span class="line">    fac[<span class="number">0</span>]=fac[<span class="number">1</span>]=fac_inv[<span class="number">0</span>]=fac_inv[<span class="number">1</span>]=inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;=lim;++i)&#123;</span><br><span class="line">        fac[i]=(ll) fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">        inv[i]=(ll) inv[ mod%i ]*(mod-mod/i)%mod;</span><br><span class="line">        fac_inv[i]=(ll) fac_inv[i<span class="number">-1</span>]*inv[i]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=lim;++i) si[i]=(ll) (si[i<span class="number">-1</span>]+inv[i])%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) ans=(ans+(ll) (si[i]+si[n-i+<span class="number">1</span>]<span class="number">-1</span>)*a[i])%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans*fac[n]%mod);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><blockquote>
<p>给出 $n$ 边的有向完全图，每个点右两个点权 $a,b$ ，一条边的边权值为 $\min(u_a,v_b)$ ，求边权和最小的哈密顿回路的边权和</p>
</blockquote>
<p>一个合法的解一定是有 $n$ 条路径的一个环，环上的边权值为 $n$ 个 $a_i,b_i$ 中的 $n$ 个数</p>
<p>考虑所有能形成环的方式中可能是最优解的情况：</p>
<ul>
<li><p>对所有点都选 $a_i/b_i$</p>
</li>
<li><p>对某些点 $u$ ，同时使用了 $a_u,b_u$</p>
<p>此时，贪心选择权值小的边</p>
<p>先将所有 $ab$ 混在一起排序，对前 $n$ 个求前缀和，考虑每个点 $u$ ，当 $a_u,b_u$ 都选时最小权值和( $a_u+b_u+pre[n-2]$ )是否更优</p>
</li>
</ul>
<p>如此更新答案即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll pre[N&lt;&lt;<span class="number">1</span>],c[N&lt;&lt;<span class="number">1</span>],ans,a[N],b[N],suma,sumb;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;a[i],&amp;b[i]),c[i]=a[i],c[i+n]=b[i],suma+=a[i],sumb+=b[i];</span><br><span class="line">	ans=<span class="built_in">min</span>(suma,sumb);</span><br><span class="line">	<span class="built_in">sort</span>(c+<span class="number">1</span>,c+<span class="number">1</span>+n*<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) pre[i]=pre[i<span class="number">-1</span>]+c[i];</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		ll x=a[i],y=b[i]; <span class="keyword">if</span>(x&gt;y) <span class="built_in">swap</span>(x,y);</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">lower_bound</span>(c+<span class="number">1</span>,c+<span class="number">1</span>+n*<span class="number">2</span>,x)-c&lt;=n<span class="number">-2</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">lower_bound</span>(c+<span class="number">1</span>,c+<span class="number">1</span>+n*<span class="number">2</span>,y)-c&lt;=n<span class="number">-1</span>) ans=<span class="built_in">min</span>(ans,pre[n]);</span><br><span class="line">			<span class="keyword">else</span> ans=<span class="built_in">min</span>(ans,pre[n<span class="number">-1</span>]+y);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> ans=<span class="built_in">min</span>(ans,x+y+pre[n<span class="number">-2</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>圆周上均匀分布 $2N$ 个点，将这些点两两配对成 $N$ 个无序对，对于每个无序对 $AB$ ，做连接 $A,B$ 的弦。 对于一种配对方式，定义其连通性为 $N$ 条弦构成的等价连通块数，两条线属于一个等价连通块当且仅当它们相交或存在另一条弦与它们都连通。现在已有 $2K$ 个点完成配对，求剩下的点构成的所有配对方式的连通性之和</p>
</blockquote>
<p>这里有一个很好玩的转化：把圆的半径视作 $0$ ，$2N$ 个点将慢慢靠近，问题可以转化到数轴上，即：数轴上排列着 $2N$ 个点，配对的 $A,B$ 视作 $[A,B]$ ，连通性为这些区间相交形成的连通块个数</p>
<p>考虑一类连通块 $[l,r]$ ，计算其贡献</p>
<p>枚举 $i,j$ ，设 $f_{i,j}$ 表示左右端点分别为 $i,j$ 的连通块个数</p>
<p>首先，连通块 $[i,j]$ 存在当且仅当 $j-i+1\equiv 0\pmod{2}$ (即，需要两两连边)，且不存在一条边 $(u,v)$ 满足 $i\leq u\leq j 且 v&gt;j或v&lt;i$ (即，一条边不能横跨该连通块)</p>
<p>设 $c_{i,j}$ 表示连通块内尚未确定边的点数 ， $g_x$ 表示 $x$ 个点之间两两连边的方案数</p>
<p>易知 $g_x=g_{x-2}\times (x-1)$ (即，考虑第一个点与 $x-1$ 中的哪个点连边)</p>
<p>由于 $i,j$ 不一定连通，则无法简单的得到 $f_{i,j}=g_{c_{i,j}}$</p>
<p>考虑连通块问题的经典容斥，枚举 $i$ 所在的连通块:</p>
<script type="math/tex; mode=display">f_{i,j}=g_{c_{i,j}}-\sum_{p=i}^{j-1}f_{i,p}\times g_{c_{p+1,j}}</script><p>而最终答案就是统计每个连通块，其余点任意连边:</p>
<script type="math/tex; mode=display">\sum f_{i,j}\times g_{n-2k-c_{i,j}}</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">310</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,k,x[N],y[N],c[N&lt;&lt;<span class="number">1</span>][N&lt;&lt;<span class="number">1</span>],s[N&lt;&lt;<span class="number">1</span>],f[N&lt;&lt;<span class="number">1</span>][N&lt;&lt;<span class="number">1</span>],g[N&lt;&lt;<span class="number">1</span>],ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">IN</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123; <span class="keyword">return</span> i&lt;=x &amp;&amp; x&lt;=j;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k); n&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=k;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x[i],&amp;y[i]);</span><br><span class="line">	g[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;=n;++i) g[i]=(ll) g[i<span class="number">-2</span>]*(i<span class="number">-1</span>)%mod;</span><br><span class="line">	<span class="keyword">for</span>(rei l=<span class="number">2</span>;l&lt;=n;l+=<span class="number">2</span>) <span class="keyword">for</span>(rei i=<span class="number">1</span>,j=l;j&lt;=n;++i,++j)&#123;</span><br><span class="line">		c[i][j]=j-i+<span class="number">1</span>; rei p;</span><br><span class="line">		<span class="keyword">for</span>(p=<span class="number">1</span>;p&lt;=k;++p) <span class="keyword">if</span>( (c[i][j]-=<span class="built_in">IN</span>(x[p],i,j)+<span class="built_in">IN</span>(y[p],i,j)) &amp;<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span>(p&lt;=k) <span class="keyword">continue</span>;</span><br><span class="line">		f[i][j]=g[ c[i][j] ];</span><br><span class="line">		<span class="keyword">for</span>(p=i+<span class="number">1</span>;p^j;p+=<span class="number">2</span>) f[i][j]=(f[i][j]-(ll) f[i][p]*g[ c[p+<span class="number">1</span>][j] ]%mod+mod)%mod;</span><br><span class="line">		ans=(ans+(ll) f[i][j]*g[ n<span class="number">-2</span>*k-c[i][j]]%mod )%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>给定一个 $1\sim n$ 的排列 $P$ ，以长度为 $n$ 的 $01$ 串 $S$ 表示划分方案，$S_i=0$ 时分入序列 $A$ ，$S_i=1$ 时分入序列 $B$ ，使 $AB$ 的前缀最大值个数相等，求 $S$ 使字典序最小</p>
</blockquote>
<p>先贪心，从前往后对于每一位尽量填 $0$ ，再检验如此放后是否能使接下来的操作合法，那么检验操作只能在 $O(\log n)$ 时间内解决</p>
<p>有性质：<strong>对于序列 $P$ 中的前缀最大值，划分到新序列 $A,B$ 中后仍是前缀中最大的</strong></p>
<p>由此有结论：<strong>对于一个时刻的序列 $A,B$ ，设前缀最大值数量为 $c_A,c_B$ ，不改变 $c_A,c_B$ 的值的情况下，一定能重新分配序列使其中一个序列的所有前缀最大值均为原序列 $P$ 的前缀最大值</strong></p>
<p>由此，考虑如何检验：</p>
<p>假设 $B$ 中添加的全部是 $P$ 中的前缀最大值，对于第 $i$ 位，$P_i$ 之后的前缀最大值有 $c$ 个，设在第 $i$ 位后 $A$ 中会添加 $p$ 个原序列 $P$ 的前缀最大值以及 $q$ 个新的前缀最大值，$B$ 中会有 $c-p$ 个原序列的前缀最大值</p>
<p>合法情况当且仅当 $c_A+p+q=c_B+c-p \Leftrightarrow 2p+q=c_B-c_A+c$</p>
<p>右边显然是一个定值，考虑 $2p+q$ 的意义：</p>
<p>给 $A$ 添加值时，设添加原序列的前缀最大值时权值为 $2$ ，新前缀最大值时权值为 $1$ ，那么会有一种取法使总权值为 $2p+q$</p>
<p>将检验转化为，对于 $i+1\sim n$ ，能否找到一个<strong>递增</strong>序列，其中原序列 $P$ 中的数权值为 $2$ ，其余权值为 $1$ ，使该序列的权值和为 $c_A-c_B+c$</p>
<p>假设能得到权值为 $x$ 的序列，则一定有 $x-2$ 的序列，但不一定有 $x-1$ 的序列</p>
<p>所以分别求出奇偶情况的最大值并与右式比大小即可</p>
<p>如此，转化为求每个点向后的带权 $LIS$ ，值域线段树优化一下即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],p[N];<span class="comment">//原序列所有的前缀最大值</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> now)</span></span>&#123; v[now]=<span class="built_in">max</span>(v[now&lt;&lt;<span class="number">1</span>],v[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> l=<span class="number">1</span>,<span class="keyword">const</span> <span class="keyword">int</span> r=n+<span class="number">1</span>,<span class="keyword">const</span> <span class="keyword">int</span> now=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">        v[now]=-INF;<span class="comment">//奇数全部赋成-INF</span></span><br><span class="line">        <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">        rei mid=l+r&gt;&gt;<span class="number">1</span>; <span class="built_in">build</span>(l,mid,now&lt;&lt;<span class="number">1</span>),<span class="built_in">build</span>(mid+<span class="number">1</span>,r,now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> pos,<span class="keyword">const</span> <span class="keyword">int</span> val,<span class="keyword">const</span> <span class="keyword">int</span> l=<span class="number">1</span>,<span class="keyword">const</span> <span class="keyword">int</span> r=n+<span class="number">1</span>,<span class="keyword">const</span> <span class="keyword">int</span> now=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r) <span class="keyword">return</span> v[now]=val,<span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">        rei mid=l+r&gt;&gt;<span class="number">1</span>; pos&lt;=mid ? <span class="built_in">change</span>(pos,val,l,mid,now&lt;&lt;<span class="number">1</span>):<span class="built_in">change</span>(pos,val,mid+<span class="number">1</span>,r,now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">pushup</span>(now);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> x,<span class="keyword">const</span> <span class="keyword">int</span> l=<span class="number">1</span>,<span class="keyword">const</span> <span class="keyword">int</span> r=n+<span class="number">1</span>,<span class="keyword">const</span> <span class="keyword">int</span> now=<span class="number">1</span>)</span></span>&#123;<span class="comment">//下标比x大的最大值</span></span><br><span class="line">        <span class="keyword">if</span>(x&lt;l) <span class="keyword">return</span> v[now];</span><br><span class="line">        rei mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(x&lt;mid ? <span class="built_in">query</span>(x,l,mid,now&lt;&lt;<span class="number">1</span>) : -INF,<span class="built_in">query</span>(x,mid+<span class="number">1</span>,r,now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;S[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i,<span class="keyword">const</span> <span class="keyword">int</span> t1,<span class="keyword">const</span> <span class="keyword">int</span> t2,<span class="keyword">const</span> <span class="keyword">int</span> cA,<span class="keyword">const</span> <span class="keyword">int</span> cB,<span class="keyword">const</span> <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(cB-cA+c&gt;=<span class="number">0</span> &amp;&amp; S[ (cB-cA+c)&amp;<span class="number">1</span> ].<span class="built_in">query</span>(t1)&gt;=cB-cA+c) <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//假设B中全是原序列的前缀最大值</span></span><br><span class="line">	<span class="keyword">if</span>(cA-cB+c&gt;=<span class="number">0</span> &amp;&amp; S[ (cA-cB+c)&amp;<span class="number">1</span> ].<span class="built_in">query</span>(t2)&gt;=cA-cB+c) <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//假设A中全是原序列的前缀最大值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	rei t=<span class="number">0</span>,c=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]),t&lt;a[i] ? (p[i]=<span class="number">1</span>,t=a[i],++c) : <span class="number">0</span>;</span><br><span class="line">	S[<span class="number">1</span>].<span class="built_in">build</span>();</span><br><span class="line">    <span class="keyword">for</span>(rei i=n;i;--i) S[ p[i]^<span class="number">1</span> ].<span class="built_in">change</span>(a[i],S[<span class="number">0</span>].<span class="built_in">query</span>(a[i])+(p[i]+<span class="number">1</span>)),S[ p[i] ].<span class="built_in">change</span>(a[i],S[<span class="number">1</span>].<span class="built_in">query</span>(a[i])+(p[i]+<span class="number">1</span>));<span class="comment">//线段树优化DP</span></span><br><span class="line">	rei t1=<span class="number">0</span>,cA=<span class="number">0</span>,t2=<span class="number">0</span>,cB=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">check</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,c)) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>),<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        S[<span class="number">0</span>].<span class="built_in">change</span>(a[i],-INF),S[<span class="number">1</span>].<span class="built_in">change</span>(a[i],-INF);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="number">48</span>|<span class="comment">/*从线段树上删去当前位置贡献*/</span>( <span class="built_in">check</span>(i+<span class="number">1</span>,<span class="built_in">max</span>(t1,a[i]),t2,cA+(t1&lt;a[i]),cB,c-=p[i]) ? (t1&lt;a[i] &amp;&amp; (t1=a[i],++cA),<span class="number">0</span>) : (t2&lt;a[i]&amp;&amp;(t2=a[i],++cB),<span class="number">1</span>)));<span class="comment">//尽可能插入序列A</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>给定 $n\times n$ 的网格图，每个图有权值 $w_{i,j}$ ，定义格子 $X$ 可以到达 $Y$ 当且仅当存在路径 $X\leftarrow Y$ ，且对于路线上任意点权值 $\not ={0}$ ，且 $Y$ 在 $X$ 的右下方，求对于所有合法的 $(X,Y)$ ，$\sum w_X\times w_Y$</p>
</blockquote>
<p>$n=1500$ <del>显然是 $O(n^2\log n)$ 的复杂度，考虑分治，然后发现看不懂官方题解</del> 考虑暴力：</p>
<p>以 $下\rightarrow 上，右\rightarrow 左$ 的顺序求出 $(i,j)$ 能到的所有点的权值和</p>
<p>预处理 $\min/\max(i,j,k)$ 表示 $(i,j)$ 在第 $k$ 行能到的点 $(k,l)$ 中 $l$ 的最小/大值</p>
<p>若 $\min(i,j,k)\sim \max(i,j,k)$ 中间不是障碍格，则由前缀和即可计算答案</p>
<p>那么，当遇到格子 $(i,j)$ 左上均为障碍时，将该格子改为障碍并更新当前行前缀和，并 $\text{dfs}$ 其右边及下面的格子 $(i+1,j),(i,j+1)$</p>
<p>每个格子至多被 $\text{dfs}$ 一次，而每次 $\text{dfs}$ 后会把整行前缀和更新，所以复杂度 $O(n^3)$</p>
<p><del>然后en卡常</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1500</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">char</span> a[N];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="keyword">int</span> w[N][N],mn[<span class="number">2</span>][N][N],mx[<span class="number">2</span>][N][N],sum[N][N],n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(w[x][y<span class="number">-1</span>] || w[x<span class="number">-1</span>][y] || !w[x][y]) <span class="keyword">return</span> ;</span><br><span class="line">	w[x][y]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=y;i&lt;=n;++i) sum[x][i]=sum[x][i<span class="number">-1</span>]+w[x][i];</span><br><span class="line">	<span class="built_in">dfs</span>(x+<span class="number">1</span>,y),<span class="built_in">dfs</span>(x,y+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=n;++j) w[i][j]=a[j]==<span class="string">&#x27;#&#x27;</span> ? <span class="number">0</span> : a[j]-<span class="string">&#x27;0&#x27;</span>,sum[j][i]=sum[j<span class="number">-1</span>][i]+w[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(rei i=n+<span class="number">1</span>;i&gt;=<span class="number">1</span>;--i)&#123;</span><br><span class="line">		<span class="built_in">memcpy</span>(mx[<span class="number">1</span>],mx[<span class="number">0</span>],<span class="keyword">sizeof</span> mx[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">memset</span>(mx[<span class="number">0</span>],<span class="number">0</span>,<span class="keyword">sizeof</span> mx[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">memcpy</span>(mn[<span class="number">1</span>],mn[<span class="number">0</span>],<span class="keyword">sizeof</span> mn[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">memset</span>(mn[<span class="number">0</span>],<span class="number">0</span>,<span class="keyword">sizeof</span> mn[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">for</span>(rei j=n+<span class="number">1</span>;j&gt;=<span class="number">0</span>;--j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!w[i][j])&#123;</span><br><span class="line">				<span class="keyword">for</span>(rei k=i;k&lt;=n;++k) mn[<span class="number">0</span>][j][k]=n+<span class="number">1</span>,mx[<span class="number">0</span>][j][k]=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			mn[<span class="number">0</span>][j][i]=j,mx[<span class="number">0</span>][j][i]=<span class="built_in">max</span>(j,mx[<span class="number">0</span>][j+<span class="number">1</span>][i]),ans-=w[i][j]*w[i][j];</span><br><span class="line">			<span class="keyword">for</span>(rei k=i+<span class="number">1</span>;k&lt;=n;++k)</span><br><span class="line">                mn[<span class="number">0</span>][j][k]=<span class="built_in">min</span>(mn[<span class="number">1</span>][j][k],mn[<span class="number">0</span>][j+<span class="number">1</span>][k]),mx[<span class="number">0</span>][j][k]=<span class="built_in">max</span>(mx[<span class="number">1</span>][j][k],mx[<span class="number">0</span>][j+<span class="number">1</span>][k]);</span><br><span class="line">			<span class="keyword">for</span>(rei k=i;k&lt;=n;++k)</span><br><span class="line">                <span class="keyword">if</span>(mx[<span class="number">0</span>][j][k]&gt;=mn[<span class="number">0</span>][j][k])ans+=(sum[k][mx[<span class="number">0</span>][j][k]]-sum[k][mn[<span class="number">0</span>][j][k]<span class="number">-1</span>])*w[i][j];</span><br><span class="line">			<span class="built_in">dfs</span>(i,j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1500</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">char</span> a[N];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="keyword">int</span> w[N][N],mn[<span class="number">2</span>][N][N],mx[<span class="number">2</span>][N][N],sum[N][N],n,sx[N*N],sy[N*N],top,is[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a+<span class="number">1</span>),is[i]=n+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=n;++j) w[i][j]=a[j]==<span class="string">&#x27;#&#x27;</span> ? <span class="number">0</span> : a[j]-<span class="string">&#x27;0&#x27;</span>,sum[j][i]=sum[j<span class="number">-1</span>][i]+w[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(rei i=n+<span class="number">1</span>,cur=<span class="number">0</span>;i&gt;=<span class="number">1</span>;--i,cur^=<span class="number">1</span>)&#123;</span><br><span class="line">		rei u=cur,v=cur^<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(rei j=n+<span class="number">1</span>;j&gt;=<span class="number">0</span>;--j)&#123;</span><br><span class="line">			rei *m1=mn[u][j],*m2=mn[v][j],*m3=mx[u][j],*m4=mx[v][j],*m5=mn[u][j+<span class="number">1</span>],*m6=mx[u][j+<span class="number">1</span>],o=w[i][j];</span><br><span class="line">			<span class="keyword">if</span>(!w[i][j])&#123;</span><br><span class="line">				<span class="keyword">for</span>(rei k=i;k&lt;=n;++k) m1[k]=n+<span class="number">1</span>,m3[k]=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			m1[i]=j,m3[i]=<span class="built_in">max</span>(j,m6[i]),ans-=o*o,ans+=(sum[m3[i]][i]-sum[m1[i]<span class="number">-1</span>][i])*o;</span><br><span class="line">			<span class="keyword">for</span>(rei k=i+<span class="number">1</span>;k&lt;=n;++k)&#123;</span><br><span class="line">				m1[k]=<span class="built_in">min</span>(m2[k],m5[k]),m3[k]=<span class="built_in">max</span>(m4[k],m6[k]);</span><br><span class="line">				<span class="keyword">if</span>(m3[k]&gt;=m1[k]) ans+=(sum[ m3[k] ][k]-sum[m1[k]<span class="number">-1</span>][k])*o;</span><br><span class="line">				<span class="keyword">else</span>&#123;</span><br><span class="line">					<span class="keyword">while</span>(k&lt;=n) m3[k]=<span class="number">0</span>,m1[k]=n+<span class="number">1</span>,++k;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			sx[top=<span class="number">1</span>]=i,sy[<span class="number">1</span>]=j;</span><br><span class="line">			<span class="keyword">while</span>(top)&#123;</span><br><span class="line">				rei x=sx[top],y=sy[top];</span><br><span class="line">				--top;</span><br><span class="line">				<span class="keyword">if</span>(w[x][y<span class="number">-1</span>] || w[x<span class="number">-1</span>][y] || !w[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">				w[x][y]=<span class="number">0</span>,is[x]=<span class="built_in">min</span>(is[x],y),sx[++top]=x+<span class="number">1</span>,sy[top]=y,sx[++top]=x,sy[top]=y+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(rei j=i;j&lt;=n;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(is[j]==n+<span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">for</span>(rei k=is[j],*v=w[j];k&lt;=n;++k) sum[k][j]=sum[k<span class="number">-1</span>][j]+v[k];</span><br><span class="line">				is[j]=n+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>思维</tag>
        <tag>贪心</tag>
        <tag>字符串</tag>
        <tag>笛卡尔树</tag>
        <tag>线段树</tag>
        <tag>卡常</tag>
      </tags>
  </entry>
  <entry>
    <title>80901202-AGC029</title>
    <url>/2021/09/08/AGC029/</url>
    <content><![CDATA[<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>给洛谷的题解先放到这里</p>
<p>首先能想到一个结论：<strong>尽可能消去更大的数时最优</strong>。</p>
<p>形式化的表达是：对于数 $a_j$ ，显然至多有一个 $i$ 满足 $i&lt;j$ 且 $a_i+a_j=2^k$ ，如果不消去数对 $(a_i,a_j)$ ，则 $a_j$ 不可能被消去，最终答案不会更优。</p>
<p>再考虑题目中的 $2^t$ 以及 $A_i\leq 10^9$ ，则有 $a_i+a_j\leq 2^{30}$ 。</p>
<p>那么枚举范围内的所有 $2^t$ ，尺取法取当前符合条件的数对出来即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],n,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(rei k=<span class="number">1</span>&lt;&lt;<span class="number">30</span>;k;k&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        rei l=<span class="number">1</span>,r=n;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[l]==<span class="number">-1</span> || (~a[r] &amp;&amp; a[l]+a[r]&lt;k)) ++l;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a[r]==<span class="number">-1</span> || a[l]+a[r]&gt;k) --r;</span><br><span class="line">            <span class="keyword">else</span> ++ans,a[l]=a[r]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><blockquote>
<p>$N$ 个字符串排成一排，对于 $1\leq i\leq N$ ，$S_i$ 的字典序应小于 $S_{i+1}$ ， $S_i$ 的长度为 $A_i$ ，求满足上述条件的的最小字符集的大小</p>
</blockquote>
<p>答案显然能被二分出来，设字符集大小 $\sum_0$ ，判断是否能用 $\sum_0$ 使这些串的字典序递增</p>
<p>注意：判断有局部贪心，即，对于 $1\leq i\leq N$ ， $S_i=\Xi$ 使后面的串可以被构造，那么对于 $\forall \Xi’&lt;\Xi$ ，若 $S_i=\Xi’$ 后面的构造仍可以被完成</p>
<p>$S_i$ 即为大于 $S_{i-1}$ ，长度为 $A_i$ 的最小字符串即可</p>
<p>考虑如何构造 $S_i$:</p>
<p>若 $A_{i-1}&lt;A_i$ ，在后面补 $A_i-A_{i-1}$ 个 $a$ 即可，即 $S_i=S_{i-1}+a^{A_i-A_{i-1}}$</p>
<p>否则，取 $S_{i-1}$ 的一个长度 $A_i$ 的前缀，将最后一个字符向后移，即，$eg:a\rightarrow b$</p>
<p>这里要考虑溢出的问题，即 $z\rightarrow ?$ 此时考虑进位，即 $az\rightarrow ba$</p>
<p>构造每个字符串的时候，新增的非 $0$ 位置最多增加一个，$O(n\log n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N];</span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> B)</span></span>&#123;</span><br><span class="line">	rei L=a[<span class="number">1</span>]; <span class="keyword">bool</span> result;</span><br><span class="line">	map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">	mp.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">		<span class="keyword">if</span>(a[i]&lt;=L)&#123;</span><br><span class="line">			<span class="keyword">for</span>(L=a[i];mp.<span class="built_in">size</span>();)&#123;</span><br><span class="line">				it=--mp.<span class="built_in">end</span>();</span><br><span class="line">				<span class="keyword">if</span>(it-&gt;first&gt;=L) mp.<span class="built_in">erase</span>(it);</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(it-&gt;first==L<span class="number">-1</span> &amp;&amp; it-&gt;second==B<span class="number">-1</span>) mp.<span class="built_in">erase</span>(it),--L;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(!L) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			<span class="built_in">tie</span>(it,result)=mp.<span class="built_in">emplace</span>(L<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(!result) ++it-&gt;second;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> L=a[i];</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">bool</span> flag=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]); <span class="keyword">if</span>(a[i]&lt;=a[i<span class="number">-1</span>]) flag=<span class="number">0</span>;&#125;</span><br><span class="line">	<span class="keyword">if</span>(flag) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>),<span class="number">0</span>;</span><br><span class="line">	rei l,r,mid;</span><br><span class="line">	<span class="keyword">for</span>(l=<span class="number">2</span>,r=n;l&lt;r;) <span class="built_in">check</span>(mid=l+r&gt;&gt;<span class="number">1</span>) ? r=mid : l=mid+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,l);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>给定一个 $n$ 顶点的树，在点 $v$ 需要回到点 $1$ ，过程中会选择并访问一个当前没有访问，但与访问过所有点相邻的点中编号最小的点，求回到点 $1$ 时经过了多少跳不同的边</p>
</blockquote>
<p>首先显然有 $边数=点数-1$</p>
<p>设集合 $S_v$ 为 $v\rightarrow 1$ 所经过点的集合，那么显然有 $S_{fa_v}\in S_v$ ，可以考虑这两者之间的关系</p>
<p>设 $pmax_v$ 表示路径 $v\rightarrow 1$ 中点标号最大的点，而当 $pmax_v=v$ 时，点 $v$ 被称为极大点</p>
<p>考虑点 $v,fa_v$ 是否为极大点：</p>
<ul>
<li><p>$v,fa_v$ 均不是极大点：</p>
<p>显然此时有 $S_v=S_{fa_v}$</p>
</li>
<li><p>$v$ 是极大点：</p>
<p>此时，显然路径 $fa_v\rightarrow 1$ 中不会经过 $subtree(v)$</p>
<p>但对于路径 $v\rightarrow 1$ 来说，会经过 $v$ 的子树中那些编号小于路径中点编号的点，形式化的，会经过集合 $B_v=\{u\mid u\in subtree(v) \wedge \max(u,fa_u,fa_{fa_u},…)&lt;pmax_{fa_v} \}$ 中所有的点</p>
<p>此时有 $S_v=S_{fa_v}\cup B_v$</p>
</li>
<li><p>$fa_v$ 是极大点</p>
<p>此时，$v$ 子树中所有 $pmax_u=fa_v$ 的顶点 $u$ 都会被访问，有集合 $A_v=\{u\mid u\in subtree(v) \wedge pmax_u=v\}$ ，而对于极大点，有 $B_v\in A_v$</p>
<p>那么有 $S_v=S_{fa_v}\cup \left(A_{fa_u}\cap subtree(v)\right)$</p>
<p>可证明：$S_{fa_v}$ 与 $A_{fa_v}\cap subtree(v)$ 不相交，则可以直接加</p>
</li>
</ul>
<p>直接搜就可以</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],Next[N&lt;&lt;<span class="number">1</span>],ver[N&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line"><span class="keyword">int</span> n,fa[N],A[N],B[N],pmax[N]<span class="comment">/*极大点*/</span>,S[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">const</span> <span class="keyword">int</span> y)</span></span>&#123; x&lt;y ? x=y : <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> u,<span class="keyword">const</span> <span class="keyword">int</span> v)</span></span>&#123; ver[++tot]=v,Next[tot]=head[u],head[u]=tot;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	rei z=pmax[x]; A[x]=B[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=head[x],y;i;i=Next[i])&#123;</span><br><span class="line">		y=ver[i]; <span class="keyword">if</span>(y==fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">		fa[y]=x; <span class="built_in">up</span>(pmax[y],z); <span class="built_in">dfs</span>(y);</span><br><span class="line">		<span class="keyword">if</span>(y&lt;z) A[x]+=A[y];</span><br><span class="line">		<span class="keyword">if</span>(y&lt;pmax[ fa[z] ]) B[x]+=B[y];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x!=z &amp;&amp; x&gt;=pmax[ fa[z] ]) B[x]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(pmax[x]==x) S[x]+=B[x];<span class="comment">//x是极大点,\cup集合B</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pmax[ fa[x] ]==fa[x]) S[x]+=A[x]-B[x];<span class="comment">//fa_x是极大点,\cup 集合A \cap集合B</span></span><br><span class="line">	<span class="keyword">for</span>(rei i=head[x],y;i;i=Next[i])&#123;<span class="comment">//对于普通的x，fa_x，S_x=S_fa_x</span></span><br><span class="line">		y=ver[i]; <span class="keyword">if</span>(y==fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">		S[y]=S[x]; <span class="built_in">solve</span>(y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>,u,v;i&lt;n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v),<span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">	<span class="built_in">iota</span>(pmax,pmax+<span class="number">1</span>+n,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">	B[<span class="number">1</span>]=<span class="number">0</span>; <span class="built_in">solve</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,S[i]);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>给定 $n-1$ 个点集，从每个集合内选两个点连边，使最后形成一棵树，输出方案</p>
</blockquote>
<p>考虑如何构成树：固定点 $rt$ 为根，整张图除去 $rt$ 之外的所有点和点集存在完美匹配，即：一张二分图，左边是除 $rt$ 以外的所有点，右边是点集 $E_{1\sim n-1}$ ，点 $v$ 与 $E_i$ 连边当且仅当 $u\in E_i$ ，该图存在完美匹配</p>
<p>但如此固定后的完美匹配不一定有解，且 $N\leq 10^5$ 无法维护 $\text{Hall}$ 定理<br>，故有以下构造方案：</p>
<p>首先固定根，得到一个匹配，设 $E_i$ 的匹配对象为 $e_i$ ，然后从所得的根 $\text{bfs}$ ，具体的，对于当前树上的点 $v$ ，寻找所有满足 $v\in E_i$ 的集合并将其对应的 $e_i$ 作为 $v$ 的子节点，如果所有顶点均被加入树种，则答案显然正确</p>
<p>那么，找图的完美匹配即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,que[N],match[N],matup[N],top=<span class="number">1</span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; nb[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> network_flow&#123;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> ad(x) ((x-1^1)+1)</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> N=::N*<span class="number">2</span>,M=::N*<span class="number">8</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">		<span class="keyword">int</span> u,v,f;</span><br><span class="line">		<span class="built_in">edge</span>(<span class="keyword">int</span> uu=<span class="number">0</span>,<span class="keyword">int</span> vv=<span class="number">0</span>,<span class="keyword">int</span> ff=<span class="number">0</span>):<span class="built_in">u</span>(uu),<span class="built_in">v</span>(vv),<span class="built_in">f</span>(ff)&#123;&#125;</span><br><span class="line">	&#125;e[M];</span><br><span class="line">	<span class="keyword">int</span> si=<span class="number">1</span>,ti=<span class="number">2</span>,flow;</span><br><span class="line">	<span class="keyword">int</span> head[N],Next[M],tot;</span><br><span class="line">	<span class="keyword">int</span> depth[N],cur[N],que[N];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> f)</span></span>&#123; e[++tot]=<span class="built_in">edge</span>(u,v,f),Next[tot]=head[u],head[u]=tot; e[++tot]=<span class="built_in">edge</span>(v,u),Next[tot]=head[v],head[v]=tot;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">		rei top=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">memset</span>(depth,<span class="number">-1</span>,<span class="keyword">sizeof</span> depth);</span><br><span class="line">		que[<span class="number">0</span>]=si,depth[si]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(rei h=<span class="number">0</span>,x,y;h&lt;top;++h)&#123;</span><br><span class="line">			x=que[h]; <span class="keyword">if</span>(x==ti) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">for</span>(rei i=head[x],y;i;i=Next[i])&#123;</span><br><span class="line">				y=e[i].v; <span class="keyword">if</span>(depth[y]==<span class="number">-1</span> &amp;&amp; e[i].f) que[top++]=y,depth[y]=depth[x]+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> lim)</span></span>&#123;</span><br><span class="line">		rei f=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(x==ti || !lim) <span class="keyword">return</span> lim;</span><br><span class="line">		<span class="keyword">for</span>(rei &amp;i=cur[x];i;i=Next[i])&#123;</span><br><span class="line">			<span class="keyword">if</span>(depth[ e[i].v ]==depth[x]+<span class="number">1</span> &amp;&amp; e[i].f)&#123;</span><br><span class="line">				rei a=<span class="built_in">min</span>(lim-f,e[i].f);</span><br><span class="line">				rei c=<span class="built_in">dfs</span>(e[i].v,a);</span><br><span class="line">				e[i].f-=c; e[ <span class="built_in">ad</span>(i) ].f+=c;</span><br><span class="line">				<span class="keyword">if</span>((f+=c)==lim) <span class="keyword">return</span> f;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> f;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(flow=<span class="number">0</span>;<span class="built_in">bfs</span>();flow+=<span class="built_in">dfs</span>(si,INT_MAX)) <span class="built_in">memcpy</span>(cur,head,<span class="keyword">sizeof</span> cur);</span><br><span class="line">		<span class="keyword">return</span> flow;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(rei i=head[x];i;i=Next[i]) <span class="keyword">if</span>(i&amp;<span class="number">1</span> &amp;&amp; !e[i].f) <span class="keyword">return</span> e[i].v;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">		network_flow::<span class="built_in">add</span>(i+<span class="number">1</span>+n,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">		rei m,v; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">		<span class="keyword">while</span>(m--) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;v),nb[v].<span class="built_in">emplace_back</span>(i),network_flow::<span class="built_in">add</span>(v+<span class="number">1</span>,i+<span class="number">1</span>+n,<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;=n;++i) network_flow::<span class="built_in">add</span>(<span class="number">1</span>,i+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(network_flow::<span class="built_in">dinic</span>()!=n<span class="number">-1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>),<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;=n;++i) match[ network_flow::<span class="built_in">get</span>(i+<span class="number">1</span>)-n<span class="number">-1</span> ]=i;</span><br><span class="line">	que[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei h=<span class="number">0</span>;h&lt;top;++h)&#123;</span><br><span class="line">		rei y=que[h];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> s:nb[y]) <span class="keyword">if</span>(!matup[s]) matup[s]=y,que[top++]=match[s];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(top!=n) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>),<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;n;++i) <span class="built_in">printf</span>(matup[i]&lt;match[i] ? <span class="string">&quot;%d %d\n&quot;</span> : <span class="string">&quot;%2$d %1$d\n&quot;</span>,matup[i],match[i]);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>思维</tag>
        <tag>贪心</tag>
        <tag>二分图</tag>
        <tag>网络流</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>CF933D A Creative Cutout 题解</title>
    <url>/2021/10/08/CF933D%20A%20Creative%20Cutout/</url>
    <content><![CDATA[<p>$\text{SYT}$ 学长在模拟赛中出了这道题，并把数据范围加到了 $n\leq 10^{14}$</p>
<p>与<a href="https://www.luogu.com.cn/problem/solution/CF933D">学长的式子</a>相似，仍记 $a=x^2+y^2$ ，点 $(x,y)$ 最早被半径为 $\sqrt a$ 的第 $a$ 个圆包含</p>
<p>枚举每个点被包含圆的编号 $\times$ 在 $n$ 个圆中的出现次数，即能推出上面的式子</p>
<script type="math/tex; mode=display">\frac{1}{2}(1+n)(n+a)(n-a+1)-\frac{1}{6}n(n+1)(2n+1)+\frac{1}{6}a(a-1)(2a-1)</script><p>但由于插值法常数过大，考虑继续将式子化简</p>
<p>将 $a=x^2+y^2$ 代入并以 $y$ 为主元，能得到：</p>
<script type="math/tex; mode=display">\begin{aligned}
原式&=\frac{1+n}{2}(x^2+y^2+n)(n-x^2-y^2+1) \\
&\qquad+\frac{1}{6}n(n+1)(2n+1) \\
&\qquad+(\frac{1}{6}x^4+\frac{1}{6}x^2y^2+\frac{1}{6}x^2y^2+\frac{1}{6}y^4-\frac{1}{6}x^2-\frac{1}{6}y^2)\times(2x^2-2y^2-1) \\
&=\frac{1}{3} y^6 \\
&\qquad+(x^2-1-\frac{1}{2}n) y^4 \\
&\qquad+\left(\frac{1}{2}(1+n)(-2x^2+1)+x^4-x^2+\frac{1}{6} \right) y^2 \\
&\qquad+\left(\frac{1}{2}(1+n)(n+x^2)(n-xx^2+1)-\frac{1}{6}(n)(n+1)(n+2)+\frac{1}{6}x^2(x^2-1)(2x^2-1) \right) \\
\end{aligned}</script><p>该式的结果是点 $(x,y)$ 对答案的贡献，但还可以更加简化：在 $O(\sqrt n)$ 的时间内枚举正半轴上的每个 $x$ ，有 $max_y=\sqrt{n-x^2}$</p>
<p>对于每个 $x$ ，预处理所有的 $y$ 的六次方，四次方，二次方之和，$O(1)$ 求满足 $x^2+y^2\leq n$ 的所有 $y$ ，即，所有满足条件的 $(x,*)$ 点对答案的贡献和</p>
<p><img src="https://pic.imgdb.cn/item/616d1e312ab3f51d91a716cc.png" alt="看个图理解一下" style="zoom:50%;" /></p>
<p>以 $x=1$ 为例，红线部分就是所求的和</p>
<p>为了运算方便，实际上代码中求的是：</p>
<script type="math/tex; mode=display">\begin{aligned}
&2\times \frac{1}{3} y^6 \\
&+2\times (x^2-1-\frac{1}{2}n) y^4 \\
&+2\times \left(\frac{1}{2}(1+n)(-2x^2+1)+x^4-x^2+\frac{1}{6} \right) y^2 \\
&+(2\times max_y+1)\times \left(\frac{1}{2}(1+n)(n+x^2)(n-xx^2+1)-\frac{1}{6}(n)(n+1)(n+2)+\frac{1}{6}x^2(x^2-1)(2x^2-1) \right) \\
\end{aligned}</script><p>也就是</p>
<p><img src="https://pic.imgdb.cn/item/616d1e342ab3f51d91a71a21.png" style="zoom:50%;" /></p>
<p>$y$ 的部分 $\times 2$ 是为了加上负半轴的贡献，常数项 $\times (2\times max_y+1)$ 中，$+1$ 是绿色点的部分，即在 $x$ 轴上时的情况</p>
<p>最终统计答案时，再用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ans+=(!x) ? added : <span class="number">2</span>*added;</span><br></pre></td></tr></table></figure>
<p>来处理 $x$ 的正负半轴情况以计算整个圆的情况</p>
<p>代码复杂度为 $O(\sqrt{n})$ ，其瓶颈在于取模(确信)，若取模过于频繁就会从 $900ms$ 掉到 $4s$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rei register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inv2=<span class="number">500000004</span>,inv3=<span class="number">333333336</span>,inv6=<span class="number">166666668</span>;</span><br><span class="line">ll n,mod_n,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">	mod_n=n%mod;</span><br><span class="line">	<span class="keyword">for</span>(ll x=(ll) <span class="built_in">sqrt</span>(n+<span class="number">0.1</span>),i=<span class="number">1</span>,sum2=<span class="number">0</span>,sum4=<span class="number">0</span>,sum6=<span class="number">0</span>;~x;--x) &#123;</span><br><span class="line">		ll t=<span class="built_in">sqrt</span>(n-x*x),x2=x*x%mod;</span><br><span class="line">		<span class="keyword">for</span>(;i&lt;=t;++i)&#123;</span><br><span class="line">			ll pow_2=i*i%mod;</span><br><span class="line">			ll pow_4=pow_2*pow_2%mod;</span><br><span class="line">			sum2=(sum2+pow_2)%mod;</span><br><span class="line">			sum4=(sum4+pow_4)%mod;</span><br><span class="line">			sum6=(sum6+pow_2*pow_4)%mod;</span><br><span class="line">		&#125;</span><br><span class="line">		ll added=((ll)<span class="number">2</span>*inv3*sum6%mod</span><br><span class="line">                    +(<span class="number">2</span>*x2<span class="number">-2</span>-mod_n+<span class="number">2</span>*mod)%mod *sum4%mod</span><br><span class="line">                    +( (<span class="number">1</span>+mod_n)*((mod<span class="number">-2</span>)*x%mod*x%mod+<span class="number">1</span>)%mod + <span class="number">2</span>*x2*x2%mod<span class="number">-2</span>*x2+inv3+<span class="number">2</span>*mod )%mod *sum2%mod</span><br><span class="line">                    +   (inv2*(<span class="number">1</span>+mod_n)%mod*(mod_n+x2)%mod*(mod_n-x2+mod+<span class="number">1</span>)%mod</span><br><span class="line">                        -inv6*mod_n%mod*(mod_n+<span class="number">1</span>)%mod*(<span class="number">2</span>*mod_n+<span class="number">1</span>)%mod</span><br><span class="line">                        +inv6*(x2<span class="number">-1</span>)%mod*x2%mod*(<span class="number">2</span>*x2<span class="number">-1</span>)%mod</span><br><span class="line">                        +mod</span><br><span class="line">                        )%mod*(<span class="number">2</span>*t+<span class="number">1</span>)%mod</span><br><span class="line">                )%mod;</span><br><span class="line">        ans+=(!x) ? added : <span class="number">2</span>*added;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans%mod);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>60901202-AGC027</title>
    <url>/2021/09/06/AGC027/</url>
    <content><![CDATA[<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>需要构造一个 $N\times N$ 的矩阵 $A$ ，满足：$1\leq a_{i,j}\leq 10^{15}$ ； $a_{i,j}$ 互不相同；存在正整数 $m$ 满足对于任意矩阵中任意两个相邻的数字 $x,y$ 有 $\max(x,y)\mod \min(x,y)=m$</p>
</blockquote>
<p>假设 $m=1$ ，考虑一个格子 $v$ ，如果它去模 $a,b,…$ 得到 $1$ ，则有 $\text{lcm}(a,b,…)|v-1$</p>
<p>假设格子 $v$ 单调，，则右边 &gt; 左边，下面 &gt; 上面，$\because a_{i,j} 模 a_{i-1,j},a_{i,j-1}$ 均为 $1$ ，$\therefore$ $\text{lcm}(a_{i,j-1},a_{i-1,j})|a_{i,j}-1$</p>
<p>可以固定第一行及第一列来得到整张表，但这种方法通常会超过 $10^{15}$</p>
<p>考虑题中：<strong>网格图中相邻的两个格子</strong>，那么建立二分图：黑白染色后相邻两点间连边</p>
<p>取出二分图中的一半 $A$ ，在其中任意填数并保证互不相同，对于另一部分 $B$ 的每个点，权值为<strong>与其相邻的点（$A$ 中的点）上的数的 $\text{lcm}$ $+1$</strong></p>
<p>但此时，二分图中有 $\frac{N^2}{2}=1.25\times 10^5$ 个点，最终的 $\text{lcm}$ 可达到 $(\frac{1.25\times 10^5}{2})^4$ ，即 $10^{19}$ ，超出范围</p>
<p>从数论的角度：考虑一个数相邻的四个位置，平均填数下每个数 $N^2$ 级别，若能使对角线上的两个格子的 $\gcd$ 是 $N$ 级别的，那么四个数的 $\text{lcm}$ 就是 $N^4=6.25\times 10^{10}$ ，能接受该级别</p>
<p>考虑令一条对角线上的元素有一个共同的 $\gcd$ 即可使对角线上相邻的两数有一个 $N$ 级别的 $\gcd$</p>
<p>那么进行以下操作：</p>
<ul>
<li>对每一条对角线，标记一个数 $w$</li>
<li>对每一个格子 $a_{i,j}$ ，设经过他的两条对角线为 $d_1,d_2$ ，令 $a_{i,j}=w_{d_1}\times w_{d_2}$</li>
</ul>
<p>为了保证所有数互不相同，取 $w$ 为最小的若干个素数</p>
<p>而二分图另一部分就是相邻 $4$ 个素数的乘积 $+1$</p>
<p>显然对角线条数 $&lt;2\times N$ ，第 $500$ 个素数为 $3571$ ，第 $1000$ 个素数为 $7919$ ，其 $\text{lcm}=3571^2\times 7919^2&lt;10^{15}$ ，则正确性得证</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> pn,c[<span class="number">7930</span>],p[<span class="number">1054</span>];</span><br><span class="line">ll a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(c,<span class="number">-1</span>,<span class="keyword">sizeof</span> c);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!~c[i]) p[pn]=i,c[i]=pn++;</span><br><span class="line">		<span class="keyword">for</span>(rei j=<span class="number">0</span>,v;(v=i*p[j])&lt;=n &amp;&amp; j&lt;=c[i];++j) c[v]=j;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *q;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n),<span class="built_in">sieve</span>(<span class="number">7929</span>);</span><br><span class="line">	q=p+(n<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;n;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;n;++j) <span class="keyword">if</span>((i^j)&amp;<span class="number">1</span>) a[i][j]=p[ (i+j<span class="number">-1</span>)/<span class="number">2</span> ]*q[ (j-i+n<span class="number">-1</span>)/<span class="number">2</span> ];</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;n;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;n;++j) <span class="keyword">if</span>(!((i^j)&amp;<span class="number">1</span>))&#123;</span><br><span class="line">		ll &amp;s=a[i][j]; s=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (i || j) s*=p[ (i+j<span class="number">-2</span>)/<span class="number">2</span> ];</span><br><span class="line">		<span class="keyword">if</span> (i!=n<span class="number">-1</span> || j!=n<span class="number">-1</span>) s*=p[ (i+j)/<span class="number">2</span> ];</span><br><span class="line">		<span class="keyword">if</span> (i || j!=n<span class="number">-1</span>) s*=q[ (j-i+n)/<span class="number">2</span> ];</span><br><span class="line">		<span class="keyword">if</span> (i!=n<span class="number">-1</span> || j) s*=q[ (j-i+n<span class="number">-2</span>)/<span class="number">2</span> ];</span><br><span class="line">		++s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">2</span>) a[<span class="number">1</span>][<span class="number">1</span>]=a[<span class="number">1</span>][<span class="number">1</span>]*<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;n;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;n;++j) <span class="built_in">printf</span>(<span class="string">&quot;%lld%c&quot;</span>,a[i][j],j==n<span class="number">-1</span> ? <span class="number">10</span> : <span class="number">32</span>);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>给一个由 $a,b$ 组成的字符串，进行 $0$ 或若干次任意一种以下操作：将 $aa$ 转化为 $b$ ，将 $bb$ 转化为 $a$ ，求能得到多少种不同的串</p>
</blockquote>
<p>这里有一个 $\text{trick}$ ：将 $a$ 赋值为 $1$ ，$b$ 赋值为 $2$ ，那么<strong>所有字符对应的数之和模 $3$ 的结果不变</strong>，记该结果为 $K$</p>
<p>那么显然能得到一个结论：<strong>串 $s$ 转化为字符 $c$ 的充要条件是 $K(s)=K(c)$ 且 $s$ 不是长度大于 $1$ 的 $ab$ 交错的串</strong></p>
<p>枚举 $t$ 的第一个字符，根据贪心，指定 $s$ 尽可能短的前缀</p>
<p>用 $f_i$ 表示 $s[1,…,i]$ 变成本质不同的串数量，允许 $3\mid K(s)$ 的串可以是空串</p>
<p>如此可以保证合法结果不漏：以 $s=abb$ 为例，$ab$ 变为空串，$b$ 仍是 $b$ ，合起来的结果 $b$ 恰好合法</p>
<p>考虑转移：</p>
<ul>
<li><p>$K(s[1,…,i])=0$ 则 $s[1,…,i]$ 是空串</p>
</li>
<li><p>$t$ 的最后一个字符是 $s_i$ ，贪心的，分配一个 $s_i$ ，则有 $f_{i-1}$ 个以 $s_i$ 结尾的串</p>
</li>
<li><p>$t$ 的最后一个字符不是 $s_i$ ，找一个最短的后缀分配：</p>
<p>设该后缀为 $s[j+1,…,i]$ ，那么有 $f_j$ 个以 $s_i$ 的“互补”结尾的串</p>
</li>
</ul>
<p>那么有转移：$f_i=[\ 3\mid K(s[1,…,i]) \ ]+f_{i-1}+f_j$ ，其中 $j=\max\{p\mid K(s[p+1,…,i])+K(s_i)=3\}$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,f[N],S[N],B[<span class="number">3</span>]=&#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fix</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123; x&gt;=mod ? x-=mod : <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s),n=<span class="built_in">strlen</span>(s);</span><br><span class="line">    rei i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n &amp;&amp; s[i]!=s[i<span class="number">-1</span>];++i);</span><br><span class="line">    <span class="keyword">if</span>(i==n) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>),<span class="number">0</span>; <span class="comment">//特判ab交错的串</span></span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        S[i]=(S[i<span class="number">-1</span>]+s[i<span class="number">-1</span>])%<span class="number">3</span>;<span class="comment">// = 3|K(s[1,...,i])</span></span><br><span class="line">        f[i]=f[i<span class="number">-1</span>]+!S[i];</span><br><span class="line">        <span class="built_in">fix</span>(f[i]+=B[ S[i]^S[i<span class="number">-1</span>]^<span class="number">3</span> ]);<span class="comment">//j的寻找：对每个前缀的 K(s[1,...,i] 记录dp值)</span></span><br><span class="line">        B[ S[i] ]=f[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!S[n]) <span class="built_in">fix</span>(f[n]+=mod<span class="number">-1</span>);<span class="comment">//最后的空串造不出来</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[n]);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>给定两个 $N$ 节点的树 $A,B$ ，对 $A$ 执行若干次操作，每次选择一个叶节点，删除其边并连向任意一个另外的点，<strong>每个点只能被选择一次</strong> ，求使 $AB$ 相同的最小操作次数</p>
</blockquote>
<p>由 <strong>一个点只能操作一次</strong>的性质 ：规定一个点作为根，并规定不能操作它，问题则转化为有根树上的问题</p>
<p>此时，一个点被操作当且仅当它在两棵树中父亲不同</p>
<p>有约束条件：</p>
<ul>
<li>若点 $u$ 不需操作，则 $fa_u$ 不能被操作</li>
<li>$u$ 必须在 $faA_u$ 前被操作，$faB_u$ 后被操作</li>
</ul>
<p>利用第一个，枚举 $u$ 判断是否满足</p>
<p>第二个用拓扑排序得到合法方案</p>
<p>枚举第一个被操作的点 $u$ 后，以 $u$ 作为根重读上述步骤即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">57</span>;</span><br><span class="line"><span class="keyword">int</span> fa[N],ndeg[N],deg[N],vis[N],mp[N][N],n,ans;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; A[N],B[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fath)</span></span>&#123;</span><br><span class="line">    fa[u]=fath; <span class="keyword">if</span>(vis[fath] &amp;&amp; mp[u][fath]) vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v:B[u]) <span class="keyword">if</span>(v!=fath) <span class="built_in">dfs</span>(v,u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(mp,<span class="number">0</span>,<span class="keyword">sizeof</span> mp);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) A[i].<span class="built_in">clear</span>(),B[i].<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rei T; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n); ans=n+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">1</span>,u,v;i&lt;n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v),mp[u][v]=mp[v][u]=<span class="number">1</span>,A[u].<span class="built_in">push_back</span>(v),A[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">1</span>,u,v;i&lt;n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v),B[u].<span class="built_in">push_back</span>(v),B[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) ndeg[i]=A[i].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            rei cost=<span class="number">0</span>,u;</span><br><span class="line">            <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="number">4</span>*n+<span class="number">4</span>);</span><br><span class="line">            vis[i]=<span class="number">1</span>; <span class="built_in">dfs</span>(i,<span class="number">0</span>); <span class="built_in">memcpy</span>(deg+<span class="number">1</span>,ndeg+<span class="number">1</span>,<span class="number">4</span>*n);</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(u=<span class="number">1</span>;u&lt;=n;++u) <span class="keyword">if</span>(!vis[u] &amp;&amp; deg[u]==<span class="number">1</span> &amp;&amp; vis[ fa[u] ]) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>(u&gt;n) <span class="keyword">break</span>; vis[u]=<span class="number">1</span>,++cost;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> v:A[u]) --deg[v];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(u=<span class="number">1</span>;u&lt;=n;++u) <span class="keyword">if</span>(!vis[u]) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(u&gt;n) ans=<span class="built_in">min</span>(ans,cost);</span><br><span class="line">            <span class="keyword">if</span>(A[i].<span class="built_in">size</span>()&gt;<span class="number">1</span> || u&gt;n || ans&lt;=n) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="number">4</span>*n+<span class="number">1</span>);</span><br><span class="line">            vis[<span class="number">0</span>]=<span class="number">1</span>,<span class="built_in">memcpy</span>(deg+<span class="number">1</span>,ndeg+<span class="number">1</span>,<span class="number">4</span>*n);</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(u=<span class="number">1</span>;u&lt;=n;++u) <span class="keyword">if</span>(!vis[u] &amp;&amp; deg[u]&lt;=<span class="number">1</span> &amp;&amp; vis[ fa[u] ]) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>(u&gt;n) <span class="keyword">break</span>; vis[u]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> v:A[u]) --deg[v];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(u=<span class="number">1</span>;u&lt;=n;++u) <span class="keyword">if</span>(!vis[u]) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(u&gt;n) ans=n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans&gt;n ? <span class="number">-1</span> : ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>思维</tag>
        <tag>贪心</tag>
        <tag>染色</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>90901202-AGC030</title>
    <url>/2021/09/09/AGC030/</url>
    <content><![CDATA[<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><blockquote>
<p>给定颜色数 $k$ ，对于 $n\times n$ 的网格图，每个格子被染成 $1\sim n$ 的颜色，且所有颜色至少有一个格子染上，对于 $1\leq i,j\leq k\ , i \ \not ={j}$ ，任意一个颜色 $i$ 的格子<strong>相邻</strong>的格子中，颜色为 $j$ 的格子数量均相同，其中相邻指下标差为 $1$ 或 $n-1$</p>
<p>给定 $k$ 构造满足条件的 $n$ 以及网格图具体方案</p>
</blockquote>
<p><del>玄学解析</del></p>
<p>首先对于 $k\leq 500$ 的情况，显然能用 $n=k$ ，使一种颜色一列(一行)即可</p>
<p><del>没有任何原因的</del> 注意到 $k$ 是 $n$ 的两倍，尝试对于 $n\times n$ 是否能构造出 $2n$ 种颜色的方案</p>
<p>为方便讨论，先强制使 $n$ 为偶数，<del>下文会讨论其余情况</del></p>
<p>那么一个自然的想法是考虑对于 $n\times n$ 的方格，将每 $n\times 2$ 看成一组，其中第一行是 $1\sim n$ 的排列，第二行是 $n+1\sim 2n$ 的排列</p>
<p>考虑到颜色数 $2n$ ，且 $n$ 为偶数的特殊性，自然的想到以 $2\times 2$ 为一块</p>
<p>再考虑到题面中对于<strong>相邻</strong>的定义，构造形式大概率类似于重复块的循环排列<del>我在写什么</del>，即，类似于</p>
<script type="math/tex; mode=display">\begin{array}{c|lcr}
n & \text{1} & \text{2} & \text{3} \\
\hline
行1 & 块1 & 块2 & 块3 \\
行3 & 块2 & 块3 & 块1 \\
行5 & 块3 & 块1 & 块2 \\
\end{array}</script><p><del>我在写什么？</del></p>
<p>以 $n=6$ 为例，能构造出：</p>
<script type="math/tex; mode=display">\begin{array}{c|lcr}
n=6 & \text{1} & \text{2} & \text{3} \\
\hline
行1 & {1\ 2\brace 8\ 9}&{3\ 4\brace 10\ 11}&{5\ 6\brace 12\ 7} \\
行3 & {3\ 4\brace 10\ 11}&{5\ 6\brace 12\ 7}&{1\ 2\brace 8\ 9} \\
行5 & {5\ 6\brace 12\ 7}&{1\ 2\brace 8\ 9}&{3\ 4\brace 10\ 11} \\
\end{array}</script><p>即，</p>
<script type="math/tex; mode=display">\begin{array}{c|lcr}
n=6 & \text{1} & \text{2} & \text{3} & \text{4} & \text{5} & \text{6}\\
\hline
行1 & 1&2&3&4&5&6 \\
行2 & 8&9&10&11&12&7 \\
行3 & 3&4&5&6&1&2 \\
行4 & 10&11&12&7&8&9 \\
行5 & 5&6&1&2&3&4 \\
行6 & 12&7&8&9&10&11 \\
\end{array}</script><p>不难发现这是合法的，<del>而通过手推更大的n也能发现这样合法，但latex太难打了</del></p>
<p>也就是，当 $k\equiv 0 \pmod 4$ 时，令 $n=\frac{k}{2}$ 即可</p>
<p>而对于 $k\equiv a \pmod 4\ ,\ a\in \{1,2,3\}$ ，将那些 $&gt;k$ 的数 $-n$ 即可</p>
<p>以 $k=5$ 为例</p>
<script type="math/tex; mode=display">\begin{array}{c|lcr}
n=6 & \text{1} & \text{2} & \text{3} & \text{4} & \text{5} & \text{6}\\
\hline
行1 & 1&2&3&4&5&6 \\
行2 & 8&9&10&11&\color{red}{6}&7 \\
行3 & 3&4&5&6&1&2 \\
行4 & 10&11&\color{red}{6}&7&8&9 \\
行5 & 5&6&1&2&3&4 \\
行6 & \color{red}{6}&7&8&9&10&11 \\
\end{array}</script><p><del>然后通过手模发现这样也是对的</del></p>
<p><del>但我并不会证正确性，这跟官方题解好像也不一样</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,K;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;K); <span class="keyword">if</span>(K==<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;1\n1&quot;</span>),<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n=(K+<span class="number">3</span>)/<span class="number">4</span>*<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;n;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>,r;j&lt;n;++j) r=(i+j)%n+(i&amp;<span class="number">1</span> ? n : <span class="number">0</span>),<span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>,r-(r&gt;=K ? n : <span class="number">0</span>)+<span class="number">1</span>,j==n<span class="number">-1</span> ? <span class="number">10</span> : <span class="number">32</span>);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>给定长度为 $n$ 的数列，给 $q$ 个交换操作，可选择是否操作，能得到 $2^Q$ 个(可能相同的)序列，求所有情况的逆序数总和</p>
</blockquote>
<p>直接算总和过于繁琐，对于每一项计算其期望贡献，最后乘 $2^Q$ ，即 $E(N(A))=\sum_{1\leq i<j\leq n} p(A_i>A_j)$ ，对于每一对 $(i,j) \ i<j$ ，计算 $A_i>A_j$ 的概率</p>
<p>考虑第 $q$ 次操作 $(A_X,A_Y)$ ，显然若 $\{i,j\}\cap \{X,Y\}=\varnothing$ ，$p(A_i&gt;A_j)$ 的值不变</p>
<p>而对于 $(A’_X,A’_Y)$ ，操作 $q$ 交换两者的概率可以看作 $\frac{1}{2}$ 。。。。。吗？</p>
<p>考虑到 $A_X=A_Y$ ，此时需要除去它们相等的概率，即 $1-p(A_X&gt;A_Y)-p(A_Y&gt;A_X)$ ，转移即为：</p>
<script type="math/tex; mode=display">p(A'_X>A'_Y)=p(A'_Y>A'_X)=\frac{1}{2}\left(p(A_X>A_Y)+p(A_Y>A_X)\right)</script><p>对于 $p(A’_X,A’_i) , i\not \in \{X,Y\}$ ，此时 $A’_X$ 有 $\frac{1}{2}$ 的概率为 $A_X$ , $\frac{1}{2}$ 的概率为 $A_Y$ ，有转移：</p>
<script type="math/tex; mode=display">p(A'_X>A'_i)=\frac{1}{2}(p(A_X>A_i)+p(A_Y>A_i))</script><p>其余情况类似不再说明</p>
<p>对于操作 $(X,Y)$ ，能使 $p(A’_i&gt;A’_j)$ 变化的 $(i,j)$ 对需要满足 $\{i,j\}\cap \{X,Y\}\not ={\varnothing}$ ，故只有 $O(n)$ 对</p>
<p>总复杂度为 $O(n^2)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inv2=<span class="number">5e8</span>+<span class="number">4</span>;</span><br><span class="line">ll E;</span><br><span class="line"><span class="keyword">int</span> n,q,a[N],f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">qpow</span><span class="params">(ll a,<span class="keyword">int</span> n,ll ans=<span class="number">1</span>)</span></span>&#123; <span class="keyword">for</span>(;n;n&gt;&gt;=<span class="number">1</span>,a=a*a%mod) <span class="keyword">if</span>(n&amp;<span class="number">1</span>) ans=ans*a%mod; <span class="keyword">return</span> ans;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">half</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> (ll) x*inv2%mod;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;q);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=n;++j) f[i][j]=a[i]&gt;a[j];</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>,u,v;i&lt;q;++i)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v); f[u][v]=f[v][u]=<span class="built_in">half</span>(f[u][v]+f[v][u]);</span><br><span class="line">		<span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=n;++j) <span class="keyword">if</span>(j!=u &amp;&amp; j!=v)&#123;</span><br><span class="line">			f[u][j]=f[v][j]=<span class="built_in">half</span>(f[u][j]+f[v][j]);</span><br><span class="line">			f[j][u]=f[j][v]=<span class="built_in">half</span>(f[j][u]+f[j][v]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) E+=<span class="built_in">accumulate</span>(f[i]+i,f[i]+<span class="number">1</span>+n,<span class="number">0ll</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(<span class="keyword">int</span>) <span class="built_in">qpow</span>(<span class="number">2</span>,q,E%mod));<span class="comment">//期望值*2^Q</span></span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>给定两个长度 $n$ 的 $01$ 串 $s,t$ ，进行若干次操作，每次可以使 $s$ 中某一个位置上的值取反，且保证不存在 $3$ 个及以上连续的相同字符，求把 $s$ 变为 $t$ 所需要的最小操作次数</p>
</blockquote>
<p>在 $0 \ 1$ 之间画一条红线， $1 \ 0$ 之间画一条蓝线，默认字符串开头结尾处均有无限多的红蓝线</p>
<p>此时，两个字符串相等等价于两个字符串的红蓝线相等，而更改一个位置上的数相当于将一条红/蓝线左/右移</p>
<p>那么直接枚举红蓝线之间的位置关系，暴力 $O(n^2)$ 即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e4</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],b[N];</span><br><span class="line"><span class="keyword">char</span> s[N],t[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">()</span></span>&#123;</span><br><span class="line">	rei t1=<span class="number">0</span>,t2=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;++i) <span class="keyword">if</span> (s[i]==<span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i+<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span>) a[++t1]=i;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) b[++t2]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;++i) <span class="keyword">if</span> (t[i]==<span class="string">&#x27;0&#x27;</span> &amp;&amp; t[i+<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span>) b[++t2]=i;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) b[++t2]=n;</span><br><span class="line">	rei ret=n*n;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=t2-t1+<span class="number">1</span>;++i)&#123;</span><br><span class="line">		rei now=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=i<span class="number">-1</span>;++j) now+=b[j];</span><br><span class="line">		<span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=t1;++j) now+=<span class="built_in">abs</span>(a[j]-b[i+j<span class="number">-1</span>]);</span><br><span class="line">		<span class="keyword">for</span>(rei j=i+t1;j&lt;=t2;++j) now+=n-b[j];</span><br><span class="line">		ret=<span class="built_in">min</span>(ret,now);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%s%s&quot;</span>,&amp;n,s+<span class="number">1</span>,t+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(n&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">		rei ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) ans+=s[i]!=t[i];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	rei tmp=<span class="built_in">calc</span>();</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) s[i]=<span class="string">&#x27;0&#x27;</span>+<span class="string">&#x27;1&#x27;</span>-s[i],t[i]=<span class="string">&#x27;0&#x27;</span>+<span class="string">&#x27;1&#x27;</span>-t[i];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tmp+<span class="built_in">calc</span>());</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>长度 $2\times n$ 的序列 $A$ 中为 $1\sim 2\times n$ ，要将其填入形成一个排列，其中某些位置已经强制有特定的数，有长度为 $n$ 的序列 $B$ ，其中 $B_i=\min\{A_{2i-1},A_{2i}\}$ ，求所有方案中能得到不同的 $B$ 的数量</p>
</blockquote>
<p>考虑 $B$ 的取值方法，对于序列 $A$ 两两考虑每一对数：</p>
<ul>
<li><p>对于已经确认的数对，可以直接丢掉不管</p>
</li>
<li><p>对于形如 $(-1,-1)$ ，即，两个都没有填的对</p>
<p>显然数对内的顺序对 $B_i$ 的值无影响，仅需要记录其个数 $cnt1$ ，最后给答案累加阶乘 $cnt1!$ 即可</p>
</li>
<li><p>对于 $(x,-1)$ 的</p>
<p>这种形式有两种，一个是题目指定了一个值且尚未被匹配的数对 $(x,-1)$，或一个数填入到了 $(-1,-1)$ 中</p>
<p>由于 $B_i$ 要取 $\min$ ,所以对所有数从大到小处理</p>
<p>设 $f_{i,j,k}$ 表示当前在第 $i$ 个数，其中有 $j$ 种填过一个数的 $(-1,-1)$ ，$k$ 种题中所给的未匹配的数对 $(d,-1)$</p>
<p>对于新加的第 $i$ 个数 $x$：可以和填了一半进行配对，也可以自己产生一个填了一半的数对</p>
<p>分类，考虑其是否是 $(x,-1)$ 数对中的一个：</p>
<ul>
<li>是：<ul>
<li>产生新的数对: $\rightarrow f_{i,j,k+1}$</li>
<li>填到一个填了一半的 $(-1,-1)$ 中: $\rightarrow f_{i,j-1,k}$</li>
</ul>
</li>
<li>不是：<ul>
<li>填到一个空的 $(-1,-1)$ : $\rightarrow f_{i,j+1,k}$</li>
<li>填到一个填了一半的 $(-1,-1)$ 中: $\rightarrow f_{i,j-1,k}$</li>
<li>匹配掉一个 $(x,-1)$ 对，其中有 $k$ 种方法: $\times k \rightarrow f_{i,j,k-1}$</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">310</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,ans,a[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> cnt1,cnt2,f[N&lt;&lt;<span class="number">1</span>][N][N],S[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[N&lt;&lt;<span class="number">1</span>],book[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fix</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123; x&gt;=mod ? x-=mod : <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=(n&lt;&lt;<span class="number">1</span>);++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=(n&lt;&lt;<span class="number">1</span>);i+=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]==<span class="number">-1</span> &amp;&amp; a[i+<span class="number">1</span>]==<span class="number">-1</span>) ++cnt1;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(a[i]&gt;<span class="number">0</span> &amp;&amp; a[i+<span class="number">1</span>]&gt;<span class="number">0</span>) vis[ a[i] ]=vis[ a[i+<span class="number">1</span>] ]=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span> ++cnt2,book[ (~a[i]) ? a[i] : a[i+<span class="number">1</span>] ]=<span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(rei i=(n&lt;&lt;<span class="number">1</span>);i;--i) <span class="keyword">if</span>(!vis[i]) S[++m]=i;</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=m;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;=cnt1+cnt2;++j) <span class="keyword">for</span>(rei k=<span class="number">0</span>;k&lt;=cnt2;++k)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!f[i<span class="number">-1</span>][j][k]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(!book[ S[i] ])&#123;</span><br><span class="line">			<span class="built_in">fix</span>(f[i][j+<span class="number">1</span>][k]+=f[i<span class="number">-1</span>][j][k]);</span><br><span class="line">			<span class="keyword">if</span>(j) <span class="built_in">fix</span>(f[i][j<span class="number">-1</span>][k]+=f[i<span class="number">-1</span>][j][k]);</span><br><span class="line">			<span class="keyword">if</span>(k) <span class="built_in">fix</span>(f[i][j][k<span class="number">-1</span>]+=(ll) k*f[i<span class="number">-1</span>][j][k]%mod);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">fix</span>(f[i][j][k+<span class="number">1</span>]+=f[i<span class="number">-1</span>][j][k]);</span><br><span class="line">			<span class="keyword">if</span>(j) <span class="built_in">fix</span>(f[i][j<span class="number">-1</span>][k]+=f[i<span class="number">-1</span>][j][k]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ans=f[m][<span class="number">0</span>][<span class="number">0</span>]; <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=cnt1;++i) ans=(ll) ans*i%mod;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>思维</tag>
        <tag>贪心</tag>
        <tag>dp</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title>CF的dp题</title>
    <url>/2021/07/01/CF%E7%9A%84dp%E9%A2%98/</url>
    <content><![CDATA[<h2 id="CF1515E-Phoenix-and-Computers"><a href="#CF1515E-Phoenix-and-Computers" class="headerlink" title="CF1515E Phoenix and Computers"></a>CF1515E Phoenix and Computers</h2><p><details><br>    <summary>我们始终不知道EI是怎么写的</summary><br>        <pre><code></p>
<pre><code>    #include&lt;bits/stdc++.h&gt;
    #define R(X,Y) X=(X+Y)%P;
    int64_t g[410],n,P,k,a,f;int main()&#123;std::cin&gt;&gt;n&gt;&gt;P;g[0]=f=k=1;for(--n;n&gt;=0;n-=2,++k)&#123;for(int i=1;i&lt;=n;++i)R(g[i],g[i-1]*k*2)f=f*k%P;R(a,g[n]*f)&#125;printf(&quot;%d\n&quot;,a);&#125;
    &lt;/code&gt;&lt;/pre&gt;
</code></pre><p>&lt;/details&gt;</p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>要开启 $n$ 台电脑，若第 $i-1,i+1$ 台被开启，第 $i$ 台自动开，询问打开所有电脑的方案数</p>
</blockquote>
<h3 id="解"><a href="#解" class="headerlink" title="解"></a>解</h3><p>题解里有一个吊打标算的 $O(n^2)$ 做法</p>
<p><del>上面EI的代码好像也是 $O(n^2)$</del></p>
<p>设 $dp_{i,j}$ 表示已开机 $i$ 台，形成 $j$ 个连续段，每段距离 $&gt;1$ 且不确定</p>
<p>考虑转移：</p>
<ul>
<li><p>新建段</p>
<ul>
<li>$dp_{i+1,j+1}=\sum dp_{i,j}*(j+1)$ ，即在 $j+1$ 个间隔中选择一个打开</li>
</ul>
</li>
<li><p>扩展段</p>
<ul>
<li>$dp_{i+1,j}=\sum dp_{i,j}\cdot j\cdot2$ ，即在一段的边界+1处开</li>
<li>$dp_{i+2,j}=\sum dp_{i,j}\cdot j\cdot2$ ，即在一段的边界+2处开</li>
</ul>
</li>
<li><p>合并段（仅当 $j\geq 2$ 时）</p>
<ul>
<li>$dp_{i+2,j-1}=\sum dp_{i,j}\cdot(j-1)\cdot2$ ，即当两边距离为 $2$ 时有两种开法</li>
<li>$dp_{i+3,j-1}=\sum dp_{i,j}\cdot (j-1)$ ，即两边距离为 $3$ 时开中间</li>
</ul>
</li>
</ul>
<h2 id="CF1516D-Cut"><a href="#CF1516D-Cut" class="headerlink" title="CF1516D Cut"></a>CF1516D Cut</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p> 给定长度为 $n$ 的序列，$q$ 次询问，对于 $[l,r]$ 区间最少能分成多少个子序列满足，子序列中数的乘积等于它们的 $\text{lcm}$</p>
</blockquote>
<h3 id="解-1"><a href="#解-1" class="headerlink" title="解"></a>解</h3><p>很显然子序列中所有数互质，有贪心：从左往右尽可能多的选取直至会加入与原区间不互质的数</p>
<p>设 $Next_i$ 代表从 $i$ 开始的序列停止的位置，即向以 $i$ 开始的子序列中加入 $Next_i$ 会使序列中的数不再互质</p>
<p>$dp_{i,l}$ 表示从 $l$ 开始，跳 $Next_i$ $2^i$ 次到达的位置</p>
<h2 id="CF1516E-Baby-Ehab-Plays-with-Permutations"><a href="#CF1516E-Baby-Ehab-Plays-with-Permutations" class="headerlink" title="CF1516E Baby Ehab Plays with Permutations"></a>CF1516E Baby Ehab Plays with Permutations</h2><h3 id="前置芝士"><a href="#前置芝士" class="headerlink" title="前置芝士"></a>前置芝士</h3><ul>
<li><p>置换</p>
<p>简单来说是对一个序列进行重排列，</p>
<script type="math/tex; mode=display">\begin{pmatrix}
1 & 2 & 3 & \dotsb & i & \dotsb & n \\
a_1 & a_2 & a_3 & \dotsb & a_i & \dotsb & a_n\\
\end{pmatrix}</script><p>即 $[1,n]$ 到 $[1,n]$ 的一一映射</p>
<ul>
<li><p>$1.$</p>
<p>置换可以分解为若干循环，具体为连边：$1\rightarrow a_1 \ ,\ 2\rightarrow a_2 \ ,\ \dotsb \ ,\ i\rightarrow a_i \ ,\ \dotsb \ ,\ n\rightarrow a_n$</p>
<p>形成的图中会有若干个环，即，置换可以被分解成不相交循环的积</p>
<p>一个循环可以被拆成 $环长-1$ 个对换，所以通过 $环长-1$ 步可以还原该循环</p>
</li>
</ul>
</li>
<li><p>关于第一类斯特林数的计算</p>
<p><a href="https://mathworld.wolfram.com/StirlingNumberoftheFirstKind.html">$\displaystyle{s(n,m)=\sum_{k=0}^NaN \  (-1)^ k\ \binom{k+n-1}{k+n-m} \binom{2n-m}{n-k-m} S(k-m+n,k)}$</a></p>
<p>变形得</p>
<script type="math/tex; mode=display">(-1)^{n-m} s(n,m)=\sum_{k=0}^{n-m} (-1)^k \binom{n-1+k}{m-1} \binom{(n-m)+n}{(n-m)-k} S((n-m+k),k)</script><p>即</p>
<script type="math/tex; mode=display">(-1)^{n-m} \begin{bmatrix} n \\ m \end{bmatrix}=\sum_{k=0}^{n-m} (-1)^k \binom{n-1+k}{m-1} \binom{(n-m)+n}{(n-m)-k} \begin{Bmatrix} (n-m)+k \\ k \end{Bmatrix}</script></li>
</ul>
<h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p> 给出长为 $n$ 的序列 $p$ 满足 $p_i=i$，进行 $k$ 次操作，每次可以选取序列中两个位置并交换，对于 $1\sim k$ 的每个值，输出最终可能有几个序列</p>
</blockquote>
<h3 id="解-2"><a href="#解-2" class="headerlink" title="解"></a>解</h3><p>$dp$ 方程难以表达，不能直接求出总排列数</p>
<p>反向思考，求经过 $k$ 次交换后恰好能排好序的排列数</p>
<p>由置换与群可知，若该排列 $p$ 中有 $c$ 个循环，需要 $n-c$ 步来还原</p>
<p>$\therefore$ 需要 $k$ 来还原的排列中存在 $n-k$ 个循环</p>
<p>由第一类斯特林数定义可知，满足条件的排列数就是 $\begin{bmatrix}n \\ n-k\end{bmatrix}$</p>
<p>$\therefore$ 对于 $1\sim k$ 的询问，答案依次为</p>
<script type="math/tex; mode=display">\begin{bmatrix}n\\n-1\end{bmatrix} ,\begin{bmatrix}n\\n\end{bmatrix}+\begin{bmatrix}n\\n-2\end{bmatrix} , \begin{bmatrix}n\\n-1\end{bmatrix}+\begin{bmatrix}n\\n-3\end{bmatrix}\dotsb</script><p>然而由于递推求斯特林数 $O(n^2)$，由于 $k\leq 200$，当 $n-m$ 较小时，利用上方的求值公式 $O(k^2)$ 求第二类斯特林数，再 $O(n^3)$ 求第一类</p>
<h2 id="CF1521D-Nastia-Plays-with-a-Tree"><a href="#CF1521D-Nastia-Plays-with-a-Tree" class="headerlink" title="CF1521D Nastia Plays with a Tree"></a>CF1521D Nastia Plays with a Tree</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>给定一颗树，每次操作删去任意一条边并加上任意一条边，求多少次操作后会形成一条链，输出次数及任一方案</p>
</blockquote>
<h3 id="解-3"><a href="#解-3" class="headerlink" title="解"></a>解</h3><p>设答案为 $x$</p>
<p>则删去树上的 $x$ 条边并加上新的 $x$ 条边会构成链</p>
<p>把删去与添加分开看，在删去 $x$ 条边后会形成一个 $x+1$ 棵树的森林，若添加 $x$ 条边能合并为链，则森林由 $x+1$ 条链构成</p>
<p>转化为找到最少分割次数使这棵树形成全为链的森林</p>
<p>设当前在处理点 $i$ ，其有 $c_i$ 个儿子，父节点为 $fa_i$</p>
<ul>
<li>若 $c_i\leq 1$ ，不需任何操作</li>
<li>若 $1\leq c_i \leq2$ ，断开 $i$ 与 $fa_i$ 的关系</li>
<li>若 $c_i &gt;2$ ，不仅断开 $i$ 与 $fa_i$ ，且断开 $i$ 的任意儿子直至 $c_i\leq 2$</li>
</ul>
<p>实现的时候注意边的存储</p>
<h2 id="CF1523D-Love-Hate"><a href="#CF1523D-Love-Hate" class="headerlink" title="CF1523D Love-Hate"></a>CF1523D Love-Hate</h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p> 有 $n$ 个人，$m$ 种货币，每个人只喜欢其中不超过 $p$ 种货币，求一种选货币的方案，使选的每一种货币都喜欢的人数不小于 $\lceil\frac{n}{2}\rceil$</p>
</blockquote>
<h3 id="解-4"><a href="#解-4" class="headerlink" title="解"></a>解</h3><p>先去除喜欢人数 $&lt;\lceil\frac{n}{2}\rceil$ 的货币，将枚举的货币状态降至 $2^30$，用 $\text{bitset}$ 存喜欢每一种货币的人的状态，暴力搜索并减去不合法的即可</p>
<h2 id="CF1525E-Assimilation-IV"><a href="#CF1525E-Assimilation-IV" class="headerlink" title="CF1525E Assimilation IV"></a>CF1525E Assimilation IV</h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>给定一些城市与点两两之间距离</p>
<p>每回合随机选择一个城市设立纪念碑，辐射范围随回合数增加而增加，即第 $1$ 回合设立的，在第 $2$ 回合可以辐射到与之距离 $\leq 2$ 的所有点</p>
<p>求所有城市设立纪念碑后所有被辐射到的点的期望值</p>
</blockquote>
<h3 id="解-5"><a href="#解-5" class="headerlink" title="解"></a>解</h3><p>分开算每个点的期望值</p>
<p>若直接求能辐射到该点的城市则情况不易讨论，考虑求补集</p>
<p>对于每个点，不被辐射到需要满足：对于第 $1$ 回合选择距离在 $n+1$ 以外的点，其余回合同理</p>
<p>那么把城市选择顺序视为一个排列，求出不能到达的方案数，最后 $1-$ 并 $\div n!$ 求期望即可</p>
<h2 id="CF1527E-Partition-Game"><a href="#CF1527E-Partition-Game" class="headerlink" title="CF1527E Partition Game"></a>CF1527E Partition Game</h2><h3 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>定义连续子序列 $t$ 的代价是</p>
<script type="math/tex; mode=display">cost(t)=\sum_{t\in set(t)} last(x)-first(x)</script><p>$set$ 表示子序列的元素集合，$last,first$ 表示 $x$ 在子序列中最后/第一次出现的位置</p>
<p> 给定长度 $n$ 的序列，分成 $k$ 个<strong>连续的</strong>子序列，求 $\min cost$</p>
</blockquote>
<h3 id="解-6"><a href="#解-6" class="headerlink" title="解"></a>解</h3><p>显然有 $O(kn^2\log n)$ 的朴素转移：</p>
<script type="math/tex; mode=display">dp_{i,j}=\min \limits_{k<j}(dp_{i-1,k}+c_{k+1,j})</script><p>含义明显</p>
<p>考虑优化 $cost$ 的计算过程</p>
<p>首先，$cost$ 具有决策单调性，即 $cost(i,j)+cost(i+1,j+1) \leq cost(i+1,j)+cost(i,j+1)$</p>
<p>证明不是太会，可以枚举一下最优情况分别位于 $(i,j),(i,j+1),(i+1,j),(i+1,j+1)$ 时，能得出结论：右边的总会优于左边</p>
<p>得到决策单调性后考虑分治，枚举 $dp_{mid}$ 的最优决策点</p>
<p>即用 $\text{solve}(l,r,x,y)$ 计算区间 $[l,r]$ ，最优决策点在 $[x,y]$ 间的所有 $dp_i$</p>
<p>对于 $\text{calc}$ 每次调用的时候左端点单增 $\Rightarrow$ 考虑移动双指针指向队首队尾，每次 $O(1)$ 暴力转移</p>
<p><del>也可以用deque当懒狗</del></p>
<h2 id="CF1535E-Gold-Transfer"><a href="#CF1535E-Gold-Transfer" class="headerlink" title="CF1535E Gold Transfer"></a>CF1535E Gold Transfer</h2><p>十分显然的题</p>
<p>题面中 $It’s \ guaranteed \ that \ p_i \ exists \ and \ c_i&gt;c_{p_i}.$ 表明从越靠近根节点开始买值越小</p>
<p>倍增跳 $anc$ 时检查是否有值即可</p>
<h2 id="CF1539E-Game-with-Cards"><a href="#CF1539E-Game-with-Cards" class="headerlink" title="CF1539E Game with Cards"></a>CF1539E Game with Cards</h2><h3 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>两个数 $a,b$ 初始为 $0$ ,进行 $n$ 次操作，每次用 $k$ 去替换 $a,b$ 中任意一个，要求操作后满足 $a_{l,i} \leq a \leq b_{l,i} , a_{r,i} \leq b \leq b_{r,i}$</p>
<p> 输出是否可以完成所以操作，若可以，输出任一方案</p>
</blockquote>
<h3 id="解-7"><a href="#解-7" class="headerlink" title="解"></a>解</h3><p>先考虑朴素做法</p>
<p>设 $dp_{L,i,j}=1$ 表示第 $i$ 张牌替换左手，第 $j$ 张是上一张用来替换右手的牌</p>
<p>$dp{R,i,j}=1$表示第 $i$ 张牌替换右手，第 $j$ 张是上一张用来替换左手的牌</p>
<p>由于只判断可行性，所以不需要存下所有的 $dp$ 状态，用 $集合f_0 = \left\langle k[j],j\right\rangle$存下 $dp_{L,i,j}=1$ 的情况，$f_1$ 同理</p>
<p>考虑 $f_0 [i]$ 与 $f_1 [i]$ 的计算 $\Rightarrow$ 先考虑 $f_0 [i+1]$ , $f_1 [i+1]$ 同理</p>
<p>先假设第 $i+1$ 张卡可以给左手（确保 $f_0 [i+1]$ 不空） ，且第 $i+1$ 回合右手可以替换为任意卡（稍后再处理）</p>
<p>若 $f_1 [i]$ 不空，可以将 $\langle k[i],i\rangle$ 添加到 $f_0 [i+1]$ 中，即左手拿第 $i+1$ 张使状态 $(j(上一次改变的),i) \Rightarrow (i+1,i)$</p>
<p>同时 $f_0 [i+1]$ 会继承 $f_0 [i]$ 的状态，即 $(i,j) \Rightarrow (i+1,j)$</p>
<p>转移后处理那些无法被成功转移的，由于 $set$ 结构，分别从 $\min$ 和 $\max$ 来 $erase$ 那些 $\leq l$ 或 $\geq r$ 的 $pair$</p>
<h2 id="CF1540B-Tree-Array"><a href="#CF1540B-Tree-Array" class="headerlink" title="CF1540B Tree Array"></a>CF1540B Tree Array</h2><h3 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h3><blockquote>
<p> 一颗树，开始时从中等概率选择一点，随后每次等概率选择一点不与选择过的点重复且与任一选择的点相连。</p>
<p>点编号按选择的先后顺序排序，求期望逆序对数</p>
</blockquote>
<hr>
<h3 id="解-8"><a href="#解-8" class="headerlink" title="解"></a>解</h3><p>考虑开始时随机选点，显然可以枚举每一点作为根，求出期望值后 $\div n$ 得到</p>
<p>求每个序列中的期望逆序对数，并不需要知道每个序列，即考虑每一对逆序对</p>
<p>设逆序点对为 $(x,y)$ ，其中 $y&gt;x$，当沿树向下进行时，直到 $x,y$ 的 $lca$ 之前概率相等，所以只需要考虑从 $lca$ 到 $x,y$ 两点的概率，即从 $lca$ 先到 $x$ 的概率</p>
<p>参照官方题解，转化成以下模型</p>
<p>存在两个栈，每次有 $p$ 概率弹出 $栈1$ 中的一个，$p$ 的概率弹出 $栈2$ 中的一个，还有 $1-2*p$ 的概率不做任何操作</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/tozqrh74.png" alt=""></p>
<p>既然满足到 $x,y$ 的概率相等，则可以由上方的值 $\div 2$ 推出</p>
<p>所以可以写出式子</p>
<script type="math/tex; mode=display">dp_{i,j}=\frac{dp_{i-1,j}+dp_{i,j-1}}{2}</script><p>其中 $i,j$ 表示逆序点对与 $lca$ 的距离</p>
<p>$dp_{0,j}=1$ ，即 $i$ 位置代表的点先被到达时会形成逆序点对</p>
<p>至此，流程为：预处理 $dp_{i,j}$ $\Rightarrow$ 枚举根 $\Rightarrow$ 枚举逆序点对并统计 $dp$ 值 $\Rightarrow$ 总值 $\div n$ 得到概率（期望，这里说不清了）</p>
<h2 id="CF1510D-Digits"><a href="#CF1510D-Digits" class="headerlink" title="CF1510D Digits"></a>CF1510D Digits</h2><h3 id="题意-8"><a href="#题意-8" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p> 给定 $n$ 个数，求能使其中一些数使其乘积最大且最后一位以 $d$ 结尾. 输出具体方案</p>
</blockquote>
<hr>
<h3 id="解-9"><a href="#解-9" class="headerlink" title="解"></a>解</h3><p>一个显然的想法是令 $d_{i,j}$ 表示前 $i$ 个数,末位为 $j$ 的最大乘积, $dp$ 转移的时候记录路径即可,可惜会爆 $ll$</p>
<p>一个在模拟赛里见过的 $trick$ 是使用对数</p>
<p>如果 $a&gt;b$ , 那么 $\log(a)&gt;\log(b)$ ,且 $\log(a\times b)=\log(a)+\log(b)$ ,转换成了加法</p>
<p>$\therefore$ 只需记录最大的和</p>
<p>令 $d_{i,j}$ 表示前 $i$ 个数,末位为 $j$ 的最大乘积的 $\log$ 值, $dp$ 转移的时候记录路径即可.</p>
<h2 id="CF372C-Watching-Fireworks-is-Fun"><a href="#CF372C-Watching-Fireworks-is-Fun" class="headerlink" title="CF372C Watching Fireworks is Fun"></a><a href="https://www.luogu.com.cn/problem/CF372C">CF372C Watching Fireworks is Fun</a></h2><h3 id="题意-9"><a href="#题意-9" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>$n$ 个区域，编号为 $1\sim n$ ,有 $m$ 个烟花，给定地点 $a_i$ ，时间 $t_i$ ，参数 $b_i$ ，在 $x$ 时能获得 $b_i-|a_i-x|$ 的值<br>单位时间内能移动 $\leq d$ 个单位长，初始在 $1$ ，求获得的最大值</p>
</blockquote>
<p>首先显然有转移：</p>
<script type="math/tex; mode=display">f_{i,j}=\min\{f_{i-1,k}+b_i-|a_i-x|\}</script><script type="math/tex; mode=display">其中 k\in [\max\{1,j-t\times d\} , \min\{n,j+t\times d\}],t=t_i-t_{i-1}</script><p>复杂度 $O(mn^2)$</p>
<p>首先有滚动数组优化降低空间</p>
<p>对于枚举的 $b_i-|a_i-x|$ ，套路的转化为求 $\max\{-|a_i-x|\}$ ，即， $\min\{|a_i-x|\}$</p>
<p>考虑到 $i,j$ 的枚举无法被省略，那么就要考虑维护当前 $k$ 能得到的最小值</p>
<p>那么用单调队列，从左右分别求依次 $f_{i,j}$ 即可</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>贪心</tag>
        <tag>dp</tag>
        <tag>数论</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title>k阶常系数齐次-非齐次线性递推</title>
    <url>/2021/11/03/k%E9%98%B6%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%BD%90%E6%AC%A1-%E9%9D%9E%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8/</url>
    <content><![CDATA[<h2 id="二阶常系数齐次递推式的通项公式"><a href="#二阶常系数齐次递推式的通项公式" class="headerlink" title="二阶常系数齐次递推式的通项公式"></a>二阶常系数齐次递推式的通项公式</h2><h3 id="引入与结论"><a href="#引入与结论" class="headerlink" title="引入与结论"></a>引入与结论</h3><blockquote>
<p>常见模型为 $f_n=a\times f_{n-1}+b\times f_{n-2}$ ，$a,b$ 为常数，已知 $f_0,f_1$ 求 $f_n$ 的通项公式</p>
</blockquote>
<p><del>不难利用矩乘得到答案</del></p>
<p>其结论为：</p>
<p>设该递推式的特征方程为 $\lambda^2-a\times \lambda-b=0$ ，其两个特征根为 $\lambda_1,\lambda_2$</p>
<p>若 $\lambda_1\not ={\lambda_2}$ ，则 $f_n=A\times \lambda^n+B\times \lambda_2^n$</p>
<p>若 $\lambda_1=\lambda_2$ ，则 $f_n=(A+b\times n)\times\lambda_1^n$</p>
<p>其中 $A=f_0-\frac{c}{\lambda_2-\lambda_1},B=\frac{c}{\lambda_2-\lambda_1},c=f_1-\lambda_1f_0$</p>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>考虑将递推式转化为一个类似等比数列的式子</p>
<script type="math/tex; mode=display">f_n-\lambda_1\times f_{n-1}=\lambda_2\times (f_{n-1}-\lambda_2\times f_{n-2})</script><script type="math/tex; mode=display">f_n=(\lambda_1+\lambda_2)\times f_{n-1}-\lambda_1\times \lambda_2\times f_{n-2}</script><p>再考虑原递推式，由韦达定理不难得 $\lambda_1,\lambda_2$ 即是递推式的特征方程 $\lambda^2-a\times \lambda-b=0$ 的根</p>
<p>不妨设 $c=f_1-\lambda_1f_0$ ，不难得：</p>
<script type="math/tex; mode=display">\begin{cases}
f_1-\lambda_1f_0=c \\
f_2-\lambda_1f_1=c\lambda_2 \\
...\\
f_{n-2}-\lambda_1f_{n-3}=c\lambda_2^{n-3} &\text{1}\\
f_{n-1}-\lambda_1f_{n-2}=c\lambda_2^{n-2} &\text{2}\\
f_n-\lambda_1f_{n-1}=c\lambda_2^{n-1} &\text{3}\\
\end{cases}</script><p><code>3</code> 式加 $\lambda_1\times$ <code>2</code> 式得：</p>
<script type="math/tex; mode=display">f_n-\lambda_1^2\times f_{n-2}=c\times \lambda_2^{n-1}+c\times \lambda_1\lambda_2^{n-2} \qquad\text{4}</script><p><code>4</code> 式加 $\lambda_1^2\times$ <code>1</code> 式得：</p>
<script type="math/tex; mode=display">f_n-\lambda_1^3 \times f_{n-3}=c\times \lambda_2^{n-1}+c\times \lambda_1\lambda_2^{n-2}+c\times \lambda_1^2\lambda_2^{n-3}</script><p>将上述的 $n$ 个式子相加，能得到：</p>
<script type="math/tex; mode=display">\begin{aligned}
f_n-\lambda_1^n\times f_0
&=c\times (\lambda_2^{n-1}+\lambda_1\times \lambda_2^{n-2}+\lambda_1^2\lambda_2^{n-3}+...+\lambda_1^{n-2}\times \lambda_2+\lambda_1^{n-1}) \\
&=c\times \sum_{i=1}^n \left(\lambda_1^{n-1}\times \left(\frac{\lambda_2}{\lambda_1}\right)^{i-1} \right)
\end{aligned}</script><p>最后的求和式可以看作以 $\lambda_1^{n-1}$ 为首项，$\displaystyle{\frac{\lambda_2}{\lambda_1}}$ 为公比的等比数列前 $n$ 项之和</p>
<ul>
<li><p>若 $\lambda_1==\lambda_2$</p>
<script type="math/tex; mode=display">\begin{aligned}
f_n-\lambda_1^nf_0&=c\times \lambda_1^{n-1}\times n \\
f_n&=c\times \lambda_1^{n-1}\times n+\lambda_1^nf_0 \\
f_n&=\left(f_0+\frac{c}{\lambda_1}\times n \right) \times \lambda_1^n \\
\end{aligned}</script></li>
<li><p>若 $\lambda_1\not ={\lambda_2}$</p>
<p>由等比数列求和得：</p>
<script type="math/tex; mode=display">\begin{aligned}
f_n-\lambda_1^nf_0&=c\times \lambda_1^{n-1}\frac{\left(\frac{\lambda_1}{\lambda_2}\right)^n-1}{\frac{\lambda_2}{\lambda_1}-1} \\
f_n&=c\times \frac{\lambda_2^n-\lambda_1^n}{\lambda_2-\lambda_1}+\lambda_1^nf_0 \\
f_n&=\left(f_0-\frac{c}{\lambda_2-\lambda_1}\right) \lambda_1^n+\frac{c}{\lambda_2-\lambda_1}\lambda_2^n \\
\end{aligned}</script></li>
</ul>
<h2 id="常系数齐次线性递推"><a href="#常系数齐次线性递推" class="headerlink" title="常系数齐次线性递推"></a>常系数齐次线性递推</h2><p><del>NOIP没退役就来学</del></p>
<p>咕咕咕</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>数数</tag>
      </tags>
  </entry>
  <entry>
    <title>min-max容斥</title>
    <url>/2020/12/04/minmax%E5%AE%B9%E6%96%A5/</url>
    <content><![CDATA[<h2 id="minmax容斥"><a href="#minmax容斥" class="headerlink" title="minmax容斥"></a>minmax容斥</h2><ul>
<li><p>用途</p>
<p>已知集合的最小值 (<strong>期望</strong>) 求最大值</p>
<p>$eg:$ $n$ 个元素，每个元素出现概率 $p_i$，求每个元素都出现的期望时间</p>
</li>
<li><p>结论</p>
<script type="math/tex; mode=display">\max\{S\}=\sum_{T\subset S}(-1)^{|T|+1} \min\{T\}</script><p>即</p>
<script type="math/tex; mode=display">E\left(\max\{S\}\right)=\sum_{T\subset S}(-1)^{|T|+1} E\left(\min\{T\}\right)</script></li>
<li><p>证明</p>
<p>设容斥系数 $g\left(|T|\right)$</p>
<p>即 $\displaystyle{\max\{S\}=\sum_{T\subset S}g\left(|T|\right) \min\{T\}}$</p>
<p>考虑当排名为 $k$ 的数作为集合 $T$ 的最小值时，集合 $T$ 中所有值都 $\geq k$</p>
<p>所以对于第$k$大数 ， 在大小为 $|T|$ 的集合中， $\max$ 的选取方案为 $\displaystyle{\binom{k-1}{|T|-1}}$</p>
<p>考虑集合大小为 $1\sim k$ ，则第 $k$ 数的总贡献为</p>
<p>$\displaystyle{\sum_{i=1}^k \binom{k-1}{i-1}} * g(i)=[k=1] \qquad \text{即只有最大值对 max 有贡献}$</p>
<p>由二项式反演得</p>
<script type="math/tex; mode=display">\begin{aligned}
g(k)&=\sum_{i=1}^k (-1)^{k-i} \binom{k-1}{i-1} [i=1] \\
&=(-1)^{k+1} \\
\end{aligned}</script><span id="more"></span>
</li>
<li><p>变式</p>
<ul>
<li><p>由 $\max \Rightarrow \max$</p>
<script type="math/tex; mode=display">\min(S)=\sum_{T\subseteq S,\ T \neq \varnothing} (-1)^{|T|-1} \max(T)</script></li>
<li><p>扩展 $\min\max容斥$</p>
<script type="math/tex; mode=display">\text{kthmax}\{S\}=\sum_{T\subseteq S}(-1)^{|T|-k} \binom{|T|-1}{k-1} \min\{T\}</script><ul>
<li><p>证明</p>
<p>目的是找到容斥系数满足 $\text{kthmax}\{S\}=\sum_{T\subseteq S} f(|T|) \min\{T\}$</p>
<p>考虑第 $x$ 大元素，受原式启发得到</p>
<script type="math/tex; mode=display">\sum_{i=1}^t \binom{t-1}{i-1} f(i)=[t=k]</script><script type="math/tex; mode=display">\therefore 经反演易得 f(n)=(-1)^{n-k} \binom{n-1}{k-1}</script><p><a href="https://oi-wiki.org/math/inclusion-exclusion-principle/#min-max"><del>并不会用到的扩展minmax容斥</del></a></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><ul>
<li><p><a href="https://www.luogu.com.cn/problem/P3175">P3175 [HAOI2015]按位或</a></p>
<ul>
<li><p>题意</p>
<p>设 $\min\{S\}$ 表示二进制数 $S$ 中，第一个元素变为 $1$ 所需时间，$\max\{S\}$ 表示最后一个元素变为 $1$ 所需时间</p>
<p>题为求 $E(\max\{U\})$ ,其中 $U$ 为全集，$U=2^n-1$</p>
</li>
<li><p>解</p>
<p>由公式易知 $\displaystyle{E(\max\{U\})=\sum_{S\subseteq U}(-1)^{|S|-1} \ \sum E(\min\{S\})}$</p>
<p>$\therefore$ 求 $\min$</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><a href="https://www.luogu.com.cn/problem/P5643">P5643 [PKUWC2018]随机游走</a></p>
<ul>
<li><p>题意:</p>
<p>给出一棵树，从根节点出发每次等概率选择并走向一条相邻边</p>
<p>多次询问中，每次给定点集 $S$ ,求从根出发直到 $S$ 中所有点至少经过一次的期望步数</p>
</li>
<li><p>解:</p>
<p>由 $\min-\max$ 容斥得：$\displaystyle{E[ \max(S’) ]=\sum_{T’\in S’}(-1)^{|T’|+1}E[ \min(T’) ]}$</p>
<p>易知 $E[ \max(S’) ]$ 表示走完集合 $S$ 期望步数， $E[ \min(S’) ]$ 表示第一次走到集合 $S$ 的期望步数</p>
<p>设 $f_{S,x}$ 表示从 $x$ 出发，第一次访问到集合 $S$ 的期望步数</p>
<ul>
<li><p>考虑预处理所有 $f_{S,x}$</p>
<p>设 $f_x$ 为点 $x$ 到 $S$ 的最早期望时间</p>
<p>对于 $x\in S$ 有 $f_x=0$</p>
<p>对于 $x\not\in S$ 有 $\displaystyle{f_x=1+\frac{1}{\deg x}\sum_{(x,y)\in E} f_y }$</p>
<p>这里需要 $O(n^3)$ 的高斯消元，考虑到特殊的树形结构，以起点 $root$ 为根，用一次函数分离父子关系</p>
<p>即设 $\displaystyle{f_x=f_{fa_x} \times A_x + B_x }$</p>
<p>$\therefore$ 对于 $x \not\in S$ 有 $\displaystyle{f_x=1+\frac{1}{\deg x} \left(f_{fa_x} + \sum_{y\in son_x}(A_y\times f_x + B_y) \right) }$</p>
<p>化简得</p>
<script type="math/tex; mode=display">\begin{aligned}

​      A_x&=\frac{1}{\deg x-\sum_{y\in son_x}A_x} \\\

​      B_x&=\frac{\deg x+\sum_{y\in son_x}B_x}{\deg x-\sum_{y\in son_x}A_x} \\

 \end{aligned}</script><p>由此，对于给定的询问点集 $S$ ,答案就是 $\sum_{T\in S} (-1)^{|T|+1} f_{T,root}$</p>
</li>
<li><p>再考虑优化询问</p>
<p>由 $n\leq 18$ 提示可以状压点集，并预处理对于每个点集 $S$ 的 $\sum_{T\in S}(-1) ^{|T|+1} f_{T,root}$</p>
<p>那么预处理高维前缀和即可</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>minmax</tag>
      </tags>
  </entry>
  <entry>
    <title>loj#6274.数字</title>
    <url>/2021/07/08/loj-6274%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h3 id="重点说一下与运算中的转移"><a href="#重点说一下与运算中的转移" class="headerlink" title="重点说一下与运算中的转移"></a>重点说一下与运算中的转移</h3><p>考虑在当前位两数分别为 $\langle 1,0 \rangle$ 或 $ \langle 0,1 \rangle$</p>
<p>显然这两种选择的 $\And$ 与 $|$ 操作所得结果相同，由此可知会不同选择中有包含关系</p>
<p>从 $\langle 1,0 \rangle$ 与 $\langle 0,1 \rangle$ 所得情况等价入手</p>
<p>记 $\langle 1,0 \rangle$ 为情况 $S_1$ , 其中 $1$ 是第一个数的选择，$0$ 是第二个数字的选择 ,</p>
<p>$\langle 0,1 \rangle$ 为情况 $S_2$</p>
<p>由于 $S_2$ 中的 $0$ 可知，$S_1$ 选择 $1$ 取不到 $\max$，即无论后面的位如何取都取不到上界</p>
<p>同理，由于 $S_1$ 中的 $1$，$S_2$ 选择 $0$ 取不到 $\min$，即无法取到下界</p>
<ul>
<li><p>假设后面会有情况选择 $\langle 1,1 \rangle$，考虑到第二个数字取不到 $\max$ ，所以等同于选择了 $\langle 1,0 \rangle$</p>
</li>
<li><p>假设后面会有情况选择 $\langle 0,1 \rangle$，考虑到第二个数字取不到 $\min$ ，所以等同于选择了 $\langle 1,1 \rangle$</p>
</li>
</ul>
<p>所以对于与结果为 $0$ 的合法情况，取其结果的最大值即可</p>
<h3 id="另一种-dp-套-dp-的解法参见另一篇博客"><a href="#另一种-dp-套-dp-的解法参见另一篇博客" class="headerlink" title="另一种 $dp$ 套 $dp$ 的解法参见另一篇博客"></a>另一种 $dp$ 套 $dp$ 的解法参见另一篇博客</h3>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>dp套dp</title>
    <url>/2021/09/26/dp%E5%A5%97dp/</url>
    <content><![CDATA[<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><h3 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h3><p>先重复一下 $dp$ 的本质：$dp$ 将问题以某种顺序解决，其中<strong>记录必需的信息作为当前情况下状态</strong>，再考虑状态之间的转移以及如何得到答案所需的状态</p>
<p>从自动机的角度来说：把解决问题的某一步操作的所有所需特征打包为一个节点，将所有节点连成 $DAG$ (通常情况下)，在 $DAG$ 上拓扑的跑就是 $dp$ 的转移</p>
<h3 id="进一步思考"><a href="#进一步思考" class="headerlink" title="进一步思考"></a>进一步思考</h3><blockquote>
<p>现在有一个可以 $dp$ 的问题形式，给定一个答案，有多少种该问题的数据可以使问题的答案是给定的答案</p>
</blockquote>
<p>简而言之就是在 $dp$ 的 $DAG$ 上再跑 $dp$</p>
<p>首先找到 $问题\rightarrow 答案$ 的 $\text{dp}$</p>
<p>考虑到 $dp$ 中最重要的是状态，而状态可以被压缩，<strong>将 $内层dp$ 的结果作为 $外层dp$ 的状态</strong></p>
<p>具体来说：设 $内层dp - f_{i,j}$ 表示 $i$ 位置的 $j$ 状态，那么 $外层dp - F_{i,P}$ 表示 $内层dp$ 考虑到了节点 $i$ ，要研究的若干个 $内层dp$ 的结果压缩后为 $P$ 作为 $外层dp$ 的状态，$外层dp$ 的目的就是研究此状态的方案数</p>
<p>具体实现详见例题</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="bzoj3864-Hero-meet-devil"><a href="#bzoj3864-Hero-meet-devil" class="headerlink" title="bzoj3864 Hero meet devil"></a><a href="https://darkbzoj.tk/problem/3864">bzoj3864 Hero meet devil</a></h3><blockquote>
<p>给一个 $|S|\leq 15$ 的串和数 $m$ ， $\forall k=0\sim |S|$ ，求有多少串 $T$ 满足 $|T|=m$ 且 $|\text{LCS}(S,T)|=k$</p>
</blockquote>
<p>先看 $\text{LCS}$ 的 $dp$ ：</p>
<script type="math/tex; mode=display">\text{LCS}_{i,j}=
\begin{cases}
&\text{LCS}_{i-1,j-1}+1 &\text{ $S_i=T_j$ } \\
&\max\{\text{LCS}_{i-1,j},\text{LCS}_{i,j-1}\} &\text{ $S_i\not =T_j$ } \\
\end{cases}</script><p>为了能压缩，找更多的性质：</p>
<script type="math/tex; mode=display">\begin{cases}
f_{i,j+1}\geq f_{i,j} \\
f_{i,j+1}\leq f_{i,j}+1 \\
\end{cases}
\Rightarrow
f_{i,*} 的差分数列是一个 0/1 数列</script><p>状压差分后的数组，细节看代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rei register int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e3</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n,m,a[N],t[<span class="number">1</span>&lt;&lt;<span class="number">15</span>][<span class="number">4</span>],f[<span class="number">16</span>],f_j[<span class="number">16</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>][<span class="number">1</span>&lt;&lt;<span class="number">15</span>],ans[<span class="number">16</span>];<span class="comment">//dp_&#123;i,j&#125;:当前枚举到兑奖串第i位(但是滚动了)，且和奖章串的LCS(状压后)为j</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fix</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123; x&gt;=mod ? x-=mod : <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">tran</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">	<span class="built_in"><span class="keyword">switch</span></span>(c)&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>: <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>: <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">compress</span><span class="params">(<span class="keyword">int</span> f[],<span class="keyword">int</span> mask=<span class="number">0</span>)</span></span>&#123;<span class="comment">//压缩到bitmask</span></span><br><span class="line">	<span class="keyword">for</span>(rei i=n;i&gt;=<span class="number">1</span>;--i) mask=(mask&lt;&lt;<span class="number">1</span>) | (f[i]-f[i<span class="number">-1</span>]);</span><br><span class="line">	<span class="keyword">return</span> mask;<span class="comment">//mask 0~n-1位依次表示(差分后的)f[1~n]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">extract</span><span class="params">(<span class="keyword">int</span> mask,<span class="keyword">int</span> f[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;=n<span class="number">-1</span>;++i) f[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;=n<span class="number">-1</span>;++i) f[i+<span class="number">1</span>]=f[i]+((mask&gt;&gt;i)&amp;<span class="number">1</span>);<span class="comment">//状压拆开并把差分数组还原为内层dp的第二维</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	rei U=(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>;<span class="comment">//全集</span></span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f); <span class="built_in">memset</span>(f_j,<span class="number">0</span>,<span class="keyword">sizeof</span> f_j); <span class="built_in">memset</span>(t,<span class="number">0</span>,<span class="keyword">sizeof</span> t);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;=U;++i)&#123;</span><br><span class="line">		<span class="built_in">extract</span>(i,f);<span class="comment">//当前f有 (\log i) 位有效位(然而知道这点并没有什么用</span></span><br><span class="line">		<span class="comment">//设 LCS_&#123;x,y&#125; 表示S前x位，T前y位的LCS长度</span></span><br><span class="line">		<span class="comment">//那么f[]相当于LCS[x-1][],f_j相当于LCS[x][]</span></span><br><span class="line">		<span class="keyword">for</span>(rei c=<span class="number">0</span>;c&lt;=<span class="number">3</span>;++c)&#123;</span><br><span class="line">			<span class="built_in">memset</span>(f_j,<span class="number">0</span>,<span class="keyword">sizeof</span> f_j);</span><br><span class="line">			<span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=n;++j)&#123;<span class="comment">//内层做lcs的dp，f_j相当于正常dp时f的第二维</span></span><br><span class="line">				f_j[j]=<span class="built_in">max</span>(f[j],f_j[j<span class="number">-1</span>]);</span><br><span class="line">				<span class="keyword">if</span>(c==a[j]) f_j[j]=<span class="built_in">max</span>(f_j[j],f[j<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			t[i][c]=<span class="built_in">compress</span>(f_j);<span class="comment">//t[i][c]:字符串i加上字符c后与串S的(状压后的)LCS</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	rei T; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>,s+<span class="number">1</span>,&amp;m); n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) a[i]=<span class="built_in">tran</span>(s[i]);</span><br><span class="line">		<span class="built_in">init</span>();</span><br><span class="line">		rei U=(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>; <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span> dp); <span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="keyword">sizeof</span> ans);</span><br><span class="line">		rei pre=<span class="number">0</span>,cur=<span class="number">1</span>; dp[pre][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=m;++i)&#123;<span class="comment">//每循环一次会比上次多一个字符</span></span><br><span class="line">			<span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;=U;++j) <span class="keyword">for</span>(rei c=<span class="number">0</span>;c&lt;=<span class="number">3</span>;++c) <span class="built_in">fix</span>(dp[cur][ t[j][c] ]+=dp[pre][j]);<span class="comment">//由t的定义显然</span></span><br><span class="line">			pre^=<span class="number">1</span>,cur^=<span class="number">1</span>; <span class="built_in">memset</span>(dp[cur],<span class="number">0</span>,<span class="keyword">sizeof</span> dp[cur]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;=U;++i) <span class="built_in">fix</span>(ans[ __builtin_popcount(i) ]+=dp[pre][i]);</span><br><span class="line">		<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="P4590-TJOI2018-游园会"><a href="#P4590-TJOI2018-游园会" class="headerlink" title="P4590 [TJOI2018]游园会"></a><a href="https://www.luogu.com.cn/problem/P4590">P4590 [TJOI2018]游园会</a></h3><blockquote>
<p>给定字符串 $s$ ，数 $n$ ，$\forall i\in[0,|S|]$ 求有多少字符串 $t$ 满足 $|t|=n$ 且 $s$ 与 $t$ 的最长公共子序列长度 $i$ ，其中 $s,t$ 均由 <code>N O I</code> 三个字母组成，且 $t$ 中不能含有子串 <code>NOI</code></p>
</blockquote>
<p>与上题类似，$f$ 多开一维记录是否有后缀 <code>N</code> <code>NO</code> 以避免 <code>NOI</code> 出现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> K=<span class="number">30</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e3</span>+<span class="number">100</span>,S=<span class="number">1</span>&lt;&lt;<span class="number">15</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">2</span>][S][<span class="number">3</span>],ans[N];</span><br><span class="line"><span class="keyword">int</span> g[K],h[K],Size[S];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fix</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123; x&gt;=mod ? x-=mod : <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">compress</span><span class="params">(<span class="keyword">int</span> mask=<span class="number">0</span>)</span></span>&#123;<span class="comment">//压缩到bitmask</span></span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=k;++i) mask|=(h[i]-h[i<span class="number">-1</span>])&lt;&lt;(i<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> mask;<span class="comment">//mask 0~n-1位依次表示f[1~n]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">extract</span><span class="params">(<span class="keyword">int</span> mask)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=k;++i) g[i]=mask&gt;&gt;(i<span class="number">-1</span>)&amp;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=k;++i) g[i]+=g[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">trans</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">char</span> c,<span class="keyword">int</span> st,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="built_in">extract</span>(st);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=k;++i)&#123;</span><br><span class="line">		h[i]=<span class="built_in">max</span>(g[i],h[i<span class="number">-1</span>]);</span><br><span class="line">		<span class="keyword">if</span>(c==s[i]) h[i]=<span class="built_in">max</span>(h[i],g[i<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	rei now=<span class="built_in">compress</span>();</span><br><span class="line">	<span class="built_in">fix</span>(f[a][now][b]+=v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k); <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">	rei U=<span class="number">1</span>&lt;&lt;k;</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		rei p=i&amp;<span class="number">1</span>,q=p^<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">memset</span>(f[q],<span class="number">0</span>,<span class="keyword">sizeof</span> f[q]);</span><br><span class="line">		<span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;U;++j)&#123;</span><br><span class="line">			rei *t=f[p][j];</span><br><span class="line">			<span class="keyword">if</span>(t[<span class="number">0</span>])&#123;</span><br><span class="line">				<span class="built_in">trans</span>(q,<span class="number">1</span>,<span class="string">&#x27;N&#x27;</span>,j,t[<span class="number">0</span>]);</span><br><span class="line">				<span class="built_in">trans</span>(q,<span class="number">0</span>,<span class="string">&#x27;O&#x27;</span>,j,t[<span class="number">0</span>]);</span><br><span class="line">				<span class="built_in">trans</span>(q,<span class="number">0</span>,<span class="string">&#x27;I&#x27;</span>,j,t[<span class="number">0</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(t[<span class="number">1</span>])&#123;</span><br><span class="line">				<span class="built_in">trans</span>(q,<span class="number">1</span>,<span class="string">&#x27;N&#x27;</span>,j,t[<span class="number">1</span>]);</span><br><span class="line">				<span class="built_in">trans</span>(q,<span class="number">2</span>,<span class="string">&#x27;O&#x27;</span>,j,t[<span class="number">1</span>]);</span><br><span class="line">				<span class="built_in">trans</span>(q,<span class="number">0</span>,<span class="string">&#x27;I&#x27;</span>,j,t[<span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(t[<span class="number">2</span>])&#123;</span><br><span class="line">				<span class="built_in">trans</span>(q,<span class="number">1</span>,<span class="string">&#x27;N&#x27;</span>,j,t[<span class="number">2</span>]);</span><br><span class="line">				<span class="built_in">trans</span>(q,<span class="number">0</span>,<span class="string">&#x27;O&#x27;</span>,j,t[<span class="number">2</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;U;++i) Size[i]=Size[i&gt;&gt;<span class="number">1</span>]+(i&amp;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;U;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;<span class="number">3</span>;++j) <span class="built_in">fix</span>(ans[ Size[i] ]+=f[n&amp;<span class="number">1</span>][i][j]);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;=k;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P4484-BJWC2018-最长上升子序列"><a href="#P4484-BJWC2018-最长上升子序列" class="headerlink" title="P4484 [BJWC2018]最长上升子序列"></a><a href="https://www.luogu.com.cn/problem/P4484">P4484 [BJWC2018]最长上升子序列</a></h3><blockquote>
<p>长度为 $n$ 的随机排列，求其最长上升子序列长度的期望</p>
</blockquote>
<p>仍是先考虑 $内层dp \ \text{LIS}$ 的 $O(n\log n)$ 做法：$dp$ 数组记录每个长度的上升子序列的最后一项的最小值</p>
<ul>
<li><p>具体操作是：</p>
<p>构造 $n+1$ 个序列 $L_0\sim L_n$ ，其中序列 $L_{i,j}$ 表示原数组 $A$ 的前 $i$ 个中，能构成的所有长度 $j$ 的 $\text{LIS}$ 中，结尾最小的序列的结尾数字</p>
<ul>
<li>设 $L_0=\varnothing$</li>
<li>若 $L_{i-1}$ 已经被求出且 $A_i$ 大于 $L_{i-1}$ 中每个元素，直接将 $A_i$ 接在 $L_{i-1}$ 后面形成 $L_i$</li>
<li>若 $L_{i-1}$ 中存在最小的比 $A_i$ 大的元素 $x$ ，那么用 $A_i$ 替换掉 $x$ 以形成 $L_i$</li>
</ul>
<p>由此，$L_n$ 的长度就是 $A$ 的 $\text{LIS}$ 长度</p>
</li>
</ul>
<p>可以发现，对于任意一个排列的前缀，只需要存这个数组而不是整个排列就能得到全部所需信息</p>
<p>由于原数组是一个排列，该数组中不含相同元素，故数组中前 $i$ 个数对应的 $dp$ 数组只有不超过 $2^i$ 中可能</p>
<p>设 $f_{i,S}$ 表示长度为 $i$ 的排列的 $\text{LIS} \ dp$ 数组为 $S$ 的概率</p>
<p>转移时枚举长度 $i+1$ 的排列的最后一个元素 $k$ ，将 $S$ 中所有 $\geq k$ 的数 $+1$ ，更新 $dp$ 数组</p>
<h3 id="UOJ-141-【UER-4】量子态的棋盘"><a href="#UOJ-141-【UER-4】量子态的棋盘" class="headerlink" title="UOJ#141. 【UER #4】量子态的棋盘"></a><a href="https://uoj.ac/problem/141">UOJ#141. 【UER #4】量子态的棋盘</a></h3><blockquote>
<p><del>无法简述的题干</del></p>
</blockquote>
<p>小球数 $K\leq 10^{18}$ ，但注意到若落在某个网格内的小球为偶数个，则一半往下一半往右，仅当小球个数奇数时，最后一个小球的走向与格子权值有关</p>
<p>先推一遍 $dp$ ，留下不确定走向的小球，如此最多有 $n\times m$ 个球</p>
<p><del>由官方题解得</del>一个点的状态数 $S\leq 5\times 10^5$</p>
<p>对轮廓线状压，复杂度为 $O(nmS+Q)$</p>
<p>把轮廓线上的球数转化为 $80$ 进制数并和当前已经入袋的球数 $hash$，存到 $hashmap$ 里</p>
<h4 id="写不出来放弃了哈哈哈"><a href="#写不出来放弃了哈哈哈" class="headerlink" title="写不出来放弃了哈哈哈"></a>写不出来放弃了哈哈哈</h4><h3 id="LOJ-6274数字"><a href="#LOJ-6274数字" class="headerlink" title="LOJ#6274数字"></a><a href="https://loj.ac/p/6274">LOJ#6274数字</a></h3><blockquote>
<p>求 $\text{card}(\{x\and y|x\or y=T,x\in [L_x,R_x],y\in [L_y,R_y]\})$ ，其中所有数 $\leq 2^{60}$</p>
</blockquote>
<p>考虑如何验证 $x\and y=V$ : 数位 $dp$ ：设 $f_{i,a,b,c,d}$ 表示第 $i$ 位上 $x,y$ 与 $\{L_x,R_x\},\{L_y,R_y\}$ 的关系(即是否顶到上下界)</p>
<p>将这 $16$ 个数( $xy\in\{0,1\}$, $4$ 种取值，每种取值对应 $a,b,c,d$ $4$ 个数)压起来，$dp_{i,S}$ 表示第 $i$ 位，$f$ 的 $16$ 个值 $S$ 情况下有多少满足条件的 $V$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sta</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span></span>&#123;<span class="keyword">return</span> a | b&lt;&lt;<span class="number">1</span> | c&lt;&lt;<span class="number">2</span> | d&lt;&lt;<span class="number">3</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    dp[<span class="number">60</span>][<span class="number">1</span>&lt;&lt;<span class="built_in">sta</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">59</span>;~i;-- i)&#123;</span><br><span class="line">		rei t=T&gt;&gt;i&amp;<span class="number">1</span>,lx=Lx&gt;&gt;i&amp;<span class="number">1</span>,rx=Rx&gt;&gt;i&amp;<span class="number">1</span>,ly=Ly&gt;&gt;i&amp;<span class="number">1</span>,ry=Ry&gt;&gt;i&amp;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(rei S=<span class="number">0</span>;S&lt;<span class="number">65536</span>;++S) <span class="keyword">if</span>(dp[i+<span class="number">1</span>][S])</span><br><span class="line">			<span class="keyword">for</span>(rei v=<span class="number">0</span>;v&lt;<span class="number">2</span>;++v)&#123;</span><br><span class="line">				rei Next=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span>(rei SS=<span class="number">0</span>;SS&lt;<span class="number">16</span>;++SS) <span class="keyword">if</span>(S&gt;&gt;SS&amp;<span class="number">1</span>)&#123;</span><br><span class="line">					rei a=SS&amp;<span class="number">1</span>,b=SS&gt;&gt;<span class="number">1</span>&amp;<span class="number">1</span>,c=SS&gt;&gt;<span class="number">2</span>&amp;<span class="number">1</span>,d=SS&gt;&gt;<span class="number">3</span>&amp;<span class="number">1</span>;</span><br><span class="line">					<span class="keyword">for</span>(rei x=<span class="number">0</span>;x&lt;<span class="number">2</span>;++x) <span class="keyword">for</span>(rei y=<span class="number">0</span>;y&lt;<span class="number">2</span>;++y)</span><br><span class="line">						<span class="keyword">if</span>((x|y)==t &amp;&amp; (x&amp;y)==v &amp;&amp; (!a || x&gt;=lx) &amp;&amp; (!b || x&lt;=rx) &amp;&amp; (!c || y&gt;=ly) &amp;&amp; (!d || y&lt;=ry))</span><br><span class="line">							Next|=<span class="number">1</span>&lt;&lt;<span class="built_in">sta</span>(a &amp;&amp; x==lx,b &amp;&amp; x==rx,c &amp;&amp; y==ly,d &amp;&amp; y==ry);</span><br><span class="line">				&#125;</span><br><span class="line">				dp[i][Next]+=dp[i+<span class="number">1</span>][S];</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(rei S=<span class="number">1</span>;S&lt;<span class="number">65536</span>;++S) ans+=dp[<span class="number">0</span>][S];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P5279-ZJOI2019-麻将"><a href="#P5279-ZJOI2019-麻将" class="headerlink" title="P5279 [ZJOI2019]麻将"></a><a href="https://www.luogu.com.cn/problem/P5279">P5279 [ZJOI2019]麻将</a></h3><blockquote>
<p>$n$ 种不同的牌，大小 $1\sim n$ ，每种牌都有 $4$ 张。</p>
<p>定义面子为形如 $\{i,i,i\} (1\leq i\leq n) 或 \{i,i+1,i+2\}(1\leq i\leq n-2)$ 的三张牌(这个样子叫做刻子)； 对子为形如 $\{i,i\}(1\leq i\leq n)$ 的两张牌</p>
<p>定义麻将牌集合 $S$ 是胡的当且仅当其大小为 $14$ 且满足至少一个下列条件：$1.$ $S$ 可以被划分成 $5$ 个集合 $S_1\sim S_5$ ，其中 $S_1$ 是对子， $S_{2\sim 5}$ 是面子 ；$2.$ $S$ 可以被划分成 $7$ 个集合 $S_1\sim S_7$ ，它们都是对子，<strong>且对应的大小两两不同</strong></p>
<p>先摸出 $13$ 张牌，并等概率随机打乱剩下的 $4n-13$ 张，对于排列 $P$ ，$S_i$ 为摸出的 $13$ 张加上 $P$ 中前 $i$ 张牌的集合，设 $P$ 权值为最小的 $i$ 满足 $S_i$ 存在一个子集是胡的，求 $P$ 的权值的期望</p>
</blockquote>
<p><del>只会打 $20$ 暴力啊啊啊wtcl</del></p>
<h4 id="内层"><a href="#内层" class="headerlink" title="内层"></a>内层</h4><p>先考虑简化题中条件，不难把牌简化成一个长度 $n$ 的字符串，即，第 $i$ 位表示第 $i$ 种牌出现的次数</p>
<p>考虑如何会胡牌：</p>
<ul>
<li>$7$ 个对子：显然判断一下奇偶就可以，不作讨论</li>
<li>选 $1$ 种牌当对子，剩下的求出最大的面子数量 $\geq 4$</li>
</ul>
<p>考虑第二种情况：<del>不难</del>得出 $f_{0/1,i,j,k}$ 表示有无对子，第 $i-1$ 种牌开头的顺子有 $j$ 个，第 $i$ 种牌开头的顺子有 $k$ 个且其余牌全部是刻子(三个牌都一样)的最大面子数</p>
<p>那么要通过加牌使这个 $dp$ 最终的状态是胡的</p>
<p>开一个结构体 $PAI={\text{data}f_{0/1,j,k},DZ}$ 记录 $dp$ 状态及对子数，每当 $f_{1,0,0}\geq 4 \lor DZ\geq 7$ 时，胡牌</p>
<p>设 $trans(f,x)$ 表示在 $dp$ 状态 $f$ 后加一种新的牌 $x$ 张得到的状态，$\max(f,g)$ 表示 $f,g$ 两个状态种取最优所得的状态，那么有转移：</p>
<script type="math/tex; mode=display">
\begin{cases}
f_0=trans(f_0',x) \\
f_1=\max(trans(f_1',x),[x\geq 2] \ trans(f_0',x-2)) \\
DZ=DZ'+[x\geq 2] \\
\end{cases}</script><p>考虑到胡牌的情况，将 $f$ 中所有值与 $4$ 取 $\min$ ,$DZ$ 与 $7$ 取 $\min$ ，$dfs$ 发现不同的状态只有 $m=3956$ 个，同时预处理 $son_{s,k}$ 表示 $\text{PAI} \ s$ 在后面加上 $k$ 达到的 $\text{PAI}$</p>
<h4 id="外层"><a href="#外层" class="headerlink" title="外层"></a>外层</h4><p>要求最早胡牌巡目数 $i$ ，转化为求巡目数为 $i$ 但仍不是胡的概率 $p_i$ ，由期望公式得：</p>
<script type="math/tex; mode=display">E(x)=\sum_{i=14}^{4n-13}P(x=i)=\sum_{i=13}^{4n-14}P(x>i)=\sum_{i=13}^{4n-14}p_i</script><p>设 $f_{i,j,s}$ 表示前 $i$ 种牌选 $j$ 张后到了 $\text{PAI} s$ 的方案数，每次枚举第 $i$ 种牌选了 $k$ 张，有转移：</p>
<script type="math/tex; mode=display">f_{i,j+k,son_{s,k}}=\binom{j+k-sum_i}{k-a_i}A_{4-a_i}^{k-a_i} \times f_{i-1,j,s}</script><p>其中 $a_i$ 表示第 $i$ 种牌刚开始时摸到的张数，$sum_i=\sum_{j=1}^i a_j$ ，及从 $4-a_i$ 张牌种选出 $k-a_i$ 张进行排列并插入到之前的 $j$ 张牌中，但有 $sum_i$ 张牌默认在最前面，</p>
<p>最后有</p>
<script type="math/tex; mode=display">p_i=\frac{\sum_{s=1}^m f_{n,i,s}}{A_{4n-13}^{i-13}}</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100</span>,M=<span class="number">3956</span>,NN=(N&lt;&lt;<span class="number">2</span>)+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fix</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123; x&gt;=mod ? x-=mod : <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fix</span><span class="params">(ll &amp;x)</span></span>&#123; x&gt;=mod ? x-=mod : <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> w,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> s;<span class="keyword">for</span>(s=<span class="number">1</span>;b;b&gt;&gt;=<span class="number">1</span>,w=(ll) w*w%mod) <span class="keyword">if</span>(b&amp;<span class="number">1</span>) s=(ll) s*w%mod; <span class="keyword">return</span> s;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> f[<span class="number">3</span>][<span class="number">3</span>];<span class="comment">//f_&#123;j,k&#125;</span></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="title">Data</span><span class="params">()</span></span>&#123; <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;<span class="number">3</span>;++j) f[i][j]=<span class="number">-1</span>;&#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Data &amp;a)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;<span class="number">3</span>;++j) <span class="keyword">if</span>(f[i][j]!=a.f[i][j]) <span class="keyword">return</span> f[i][j]&lt;a.f[i][j];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> Data <span class="keyword">operator</span> *(<span class="keyword">int</span> x)&#123;<span class="comment">//*重新定义为添加：x为一种新牌的数量</span></span><br><span class="line">        Data c; c=<span class="built_in">Data</span>();</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>,F;j&lt;<span class="number">3</span>;++j)</span><br><span class="line">			<span class="keyword">if</span>(~(F=f[i][j])) <span class="keyword">for</span>(rei k=<span class="number">0</span>;k&lt;<span class="number">3</span> &amp;&amp; i+j+k&lt;=x;++k) c.f[j][k]=<span class="built_in">max</span>(c.f[j][k],F+i+(x-i-j-k)/<span class="number">3</span>);<span class="comment">//添加的x是否能成为刻子</span></span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;<span class="number">3</span>;++j) c.f[i][j]=<span class="built_in">min</span>(c.f[i][j],<span class="number">4</span>);</span><br><span class="line">		<span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Fix</span><span class="params">(Data c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;<span class="number">3</span>;++j) f[i][j]=<span class="built_in">max</span>(f[i][j],c.f[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PAI</span>&#123;</span></span><br><span class="line">    Data f[<span class="number">2</span>];<span class="comment">/*f_&#123;0/1,j,k&#125;*/</span><span class="keyword">int</span> DZ;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="title">PAI</span><span class="params">()</span></span>&#123;f[<span class="number">0</span>].f[<span class="number">0</span>][<span class="number">0</span>]=DZ=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> PAI &amp;a) <span class="keyword">const</span>&#123;<span class="keyword">return</span> <span class="built_in">mk</span>(<span class="built_in">mk</span>(f[<span class="number">0</span>],f[<span class="number">1</span>]),DZ)&lt;<span class="built_in">mk</span>(<span class="built_in">mk</span>(a.f[<span class="number">0</span>],a.f[<span class="number">1</span>]),a.DZ);&#125;</span><br><span class="line">    <span class="keyword">inline</span> PAI <span class="keyword">operator</span> *(<span class="keyword">int</span> x)&#123;</span><br><span class="line">        PAI c;</span><br><span class="line">		c.f[<span class="number">0</span>]=f[<span class="number">0</span>]*x;c.f[<span class="number">1</span>]=f[<span class="number">1</span>]*x;c.DZ=DZ;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=<span class="number">2</span>) c.f[<span class="number">1</span>].<span class="built_in">Fix</span>(f[<span class="number">0</span>]*(x<span class="number">-2</span>)),c.DZ=<span class="built_in">min</span>(DZ+<span class="number">1</span>,<span class="number">7</span>);<span class="comment">//查看7对子的情况</span></span><br><span class="line">		<span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">HU</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> DZ&gt;=<span class="number">7</span> || f[<span class="number">1</span>].f[<span class="number">0</span>][<span class="number">0</span>]&gt;=<span class="number">4</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,a[N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> m,son[M+<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bool</span> HU[M+<span class="number">5</span>];</span><br><span class="line">map&lt;PAI,<span class="keyword">int</span>&gt; S;</span><br><span class="line"><span class="keyword">int</span> C[NN][NN],fac[NN],f[<span class="number">2</span>][NN][M+<span class="number">5</span>],ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(rei i=C[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">for</span>(rei j=C[i][<span class="number">0</span>]=<span class="number">1</span>;j&lt;=i;++j) C[i][j]=(C[i<span class="number">-1</span>][j]+C[i<span class="number">-1</span>][j<span class="number">-1</span>])%mod;</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) fac[i]=(ll) fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(PAI x,<span class="keyword">int</span> st=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.<span class="built_in">count</span>(x)) <span class="keyword">return</span> S[x];</span><br><span class="line">	rei ID=(S[x]=++m); HU[ID]=x.<span class="built_in">HU</span>();</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;=<span class="number">4</span>;++i) son[ID][i]=<span class="built_in">dfs</span>(x*i,st+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> ID;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="built_in">PAI</span>());</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,x,y;i&lt;=<span class="number">13</span>;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y),++a[x];</span><br><span class="line">    <span class="built_in">init</span>(n&lt;&lt;<span class="number">2</span>); f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,c=<span class="number">1</span>,sum=<span class="number">0</span>;i&lt;=n;++i,c^=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;=(i&lt;&lt;<span class="number">2</span>);++j) <span class="keyword">for</span>(rei k=<span class="number">1</span>;k&lt;=m;++k) f[c][j][k]=<span class="number">0</span>;</span><br><span class="line">		sum+=a[i];</span><br><span class="line">        <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;=(i<span class="number">-1</span>&lt;&lt;<span class="number">2</span>);++j) <span class="keyword">for</span>(rei s=<span class="number">1</span>,G;s&lt;=m;++s)&#123;</span><br><span class="line">			G=f[c^<span class="number">1</span>][j][s]; <span class="keyword">if</span>(!G) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">for</span>(rei k=a[i];k&lt;=<span class="number">4</span>;++k)&#123;</span><br><span class="line">				<span class="keyword">if</span>(HU[ son[s][k] ]) <span class="keyword">continue</span>;</span><br><span class="line">				rei &amp;F=f[c][j+k][ son[s][k] ];</span><br><span class="line">				<span class="built_in">fix</span>(F+=(ll) G*C[j+k-sum][ k-a[i] ]%mod*C[ <span class="number">4</span>-a[i] ][ k-a[i] ]%mod*fac[ k-a[i] ]%mod);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">13</span>;i&lt;(n&lt;&lt;<span class="number">2</span>);++i)&#123;</span><br><span class="line">        rei sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(rei s=<span class="number">1</span>;s&lt;=m;++s) <span class="built_in">fix</span>(sum+=f[n&amp;<span class="number">1</span>][i][s]);</span><br><span class="line">        <span class="built_in">fix</span>(ans+=(ll) sum*<span class="built_in">qpow</span>((ll) C[ (n&lt;&lt;<span class="number">2</span>)<span class="number">-13</span> ][i<span class="number">-13</span>]*fac[i<span class="number">-13</span>]%mod,mod<span class="number">-2</span>)%mod);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>minmax搜索</title>
    <url>/2021/03/21/minmax%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h1 id="minimax搜索（对抗搜索）"><a href="#minimax搜索（对抗搜索）" class="headerlink" title="minimax搜索（对抗搜索）"></a>minimax搜索（对抗搜索）</h1><p><del>qwq莫名在做博弈论时就被卢神推荐来做这个了</del></p>
<h2 id="常见形式"><a href="#常见形式" class="headerlink" title="常见形式"></a>常见形式</h2><p>两人轮流走棋，两人目标相背</p>
<ul>
<li>A希望B输，B希望A输</li>
<li>A使得分最多，B使得分最少。</li>
</ul>
<p>双方智商均在线且极高</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>dfs搜博弈树</p>
<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>把走法看成一棵树</p>
<p>圆形代表 $A$，正方形代表 $B$ ，节点的每个孩子节点代表一个候选方案。</p>
<p>注：圆圈中的数字为 $A$ 的利益值，越大对A越有利</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/4graz4vl.png" alt=""></p>
<ul>
<li><p>假设 $A$ 选择第一种方案（即走第一个子节点）</p>
<p>那么 $B$ 将有两种选择，一种使 $A$ 的值为 $7$，一种使 $A$ 的值为 $3$，那么显然 $B$ 会选择 $3$<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/7lgzhb1j.png" alt=""></p>
</li>
<li><p>假设 $A$ 选择第二种方案</p>
<p>那么 $B$ 只有一种选择<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/6mw5352z.png" alt=""></p>
</li>
<li><p>同理得第三种情况</p>
</li>
</ul>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/rjtl1ad7.png" alt=""></p>
<p>又因为 $A$ 需要最佳方案</p>
<p>于是有<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/xzralhg5.png" alt=""></p>
<h2 id="alpha-beta-剪枝优化"><a href="#alpha-beta-剪枝优化" class="headerlink" title="$alpha-beta$剪枝优化"></a>$alpha-beta$剪枝优化</h2><p>为便于理解，将 $A$ 走的节点命名为 $max$ 节点，$B$ 走到节点命名为 $min$ 节点</p>
<p>$alpha-beta$ 剪枝的基本思想:</p>
<p>是对于每个 $max$ 结点设置一个目前已知下界 $alpha$ ，每个 $min$ 节点设置一个目前已知上界 $beta$ 。$alpha$ 代表 $A$ 可以搜索到的最好值，$beta$ 代表了 $B$ 可以接受的最坏值。</p>
<p>如果某个行动的结果 $\leq alpha$ ，那么它就是很差的行动，$A$ 可以选择更好的行动（即当前 $alpha$ 值的行动）。</p>
<p>反之，如果某个行动的结果 $\geq beta$，那么整个节点就作废了，因为对手不希望走到这个局面，而它有一定有别的行动（即走当前 $beta$ 值的行动）可以避免到达这个局面。</p>
<p>那么发生下面两种情况时可以剪枝，即停止搜索该节点的其余子节点：</p>
<ol>
<li><p>不用该点走：当计算一个 $min$ 结点时，如果它的 $beta$ 值小于等于其父结点的 $alpha$ 值，则可以立即停止此结点的计算（ $alpha$ 剪枝）。</p>
</li>
<li><p>走多了：当计算一个 $max$ 结点时，如果它的 $alpha$ 结点大于等于其父结点的 $beta$ 值，也可以立即停止此结点的计算（ $beta$ 剪枝）。</p>
</li>
</ol>
<p>基本格式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(Status s,<span class="keyword">int</span> Alpha,<span class="keyword">int</span> Beta,<span class="keyword">int</span> Which)</span></span></span><br><span class="line"><span class="function"><span class="comment">//Status记录当前状态，Which记录当前操作的选手，其中0号选手取Max，1号选手取Min</span></span></span><br><span class="line"><span class="function"><span class="comment">//Alpha存储较大值，Beta存储较小值</span></span></span><br><span class="line"><span class="function"><span class="comment">//如果当前节点是取Max的节点，则Alpha表示当前节点父亲的父亲的权值，Beta表示当前节点父亲的权值</span></span></span><br><span class="line"><span class="function"><span class="comment">//如果当前节点是取Min的节点，则Alpha表示当前节点父亲的权值，Beta表示当前节点父亲的父亲的权值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">IsEnd</span>(s)) <span class="keyword">return</span> <span class="built_in">GetVal</span>(s);<span class="comment">//如果当前状态已经为最终状态，就返回当前状态的分值</span></span><br><span class="line">    rei i;</span><br><span class="line">    <span class="built_in">expend</span>(s);<span class="comment">//扩展当前状态，并将新状态存储于NewStatus数组中，用NewStatusTotal记录新状态的数量</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=NewStatusTotal;++i)<span class="comment">//枚举从当前状态能够扩展到的新状态</span></span><br><span class="line">    &#123;</span><br><span class="line">        t=<span class="built_in">dfs</span>(NewStatus,Alpha,Beta,Which^<span class="number">1</span>);<span class="comment">//求出当前枚举到的新状态的分值</span></span><br><span class="line">        (s.Which?Beta=<span class="built_in">min</span>(Beta,t):Alpha=<span class="built_in">max</span>(Alpha,t)); <span class="comment">//如果当前节点取min，就更新Beta，否则更新Alpha</span></span><br><span class="line">        <span class="keyword">if</span>(Alpha&gt;=Beta) <span class="keyword">break</span>;<span class="comment">//如果Alpha≥Beta，就说明这个节点对最终答案没有贡献了，就结束搜索</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.Which?Beta:Alpha;<span class="comment">//返回相应值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>ICPC Asia Nanning 2017 I. Rake It In</p>
<p>P4576 [CQOI2013]棋盘游戏</p>
<p>World Finals 2009 LA4451 House of Cards UVA1085</p>
<pre><code>/*刘汝佳的毒瘤题*/
</code></pre><p>UVA10838 The Pawn Chess</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>minmax搜索</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈论</title>
    <url>/2021/02/04/%E5%8D%9A%E5%BC%88%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="博弈论游戏及其的变形"><a href="#博弈论游戏及其的变形" class="headerlink" title="博弈论游戏及其的变形"></a>博弈论游戏及其的变形</h1><h2 id="请熟背以下结论（因为没看懂推导）"><a href="#请熟背以下结论（因为没看懂推导）" class="headerlink" title="请熟背以下结论（因为没看懂推导）"></a>请熟背以下结论（因为没看懂推导）</h2><hr>
<h2 id="巴什博弈"><a href="#巴什博弈" class="headerlink" title="巴什博弈"></a>巴什博弈</h2><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul>
<li>只有一堆 $n$ 个物品，两个人轮流取</li>
<li>每次至少取一个，最多取 $m$ 个。</li>
<li>最后取光者得胜</li>
</ul>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>$n \mod (m+1)$ 为 $0$ 先手必败否则必胜</p>
<hr>
<h2 id="威佐夫博弈"><a href="#威佐夫博弈" class="headerlink" title="威佐夫博弈"></a>威佐夫博弈</h2><h3 id="规则-1"><a href="#规则-1" class="headerlink" title="规则"></a>规则</h3><ul>
<li>有两堆各若干个物品</li>
<li>两个人轮流从某一堆取至少一个或同时从两堆中取同样多的物品</li>
<li>最后取光者得胜</li>
</ul>
<h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><p>先手必败态的两堆石子之差依次递增，且每个自然数仅出现一次</p>
<p>如果局势为 $(a,b)$，记 $k=(a−b)$，</p>
<p>若 $a=\frac{1+\sqrt{5}}{2}*k$ （这里是等于符号）</p>
<p>则为必胜局势</p>
<hr>
<h2 id="尼姆博弈"><a href="#尼姆博弈" class="headerlink" title="尼姆博弈"></a>尼姆博弈</h2><h3 id="规-则"><a href="#规-则" class="headerlink" title="规 则"></a>规 则</h3><ul>
<li>$n$ 堆石子</li>
<li>两人轮流在任意一堆中取任意石子，不能不取，最多取完，</li>
<li>取到最后一颗石子者胜</li>
</ul>
<h3 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h3><p>$n$ 堆石子数量异或和为 $0$ 则先手必败,否则必胜</p>
<hr>
<h2 id="anti-SG与SJ（贾志豪）定理"><a href="#anti-SG与SJ（贾志豪）定理" class="headerlink" title="anti-SG与SJ（贾志豪）定理"></a>anti-SG与SJ（贾志豪）定理</h2><h3 id="规则-2"><a href="#规则-2" class="headerlink" title="规则"></a>规则</h3><ul>
<li><p>桌子上有 $n$ 堆石子，游戏者轮流取石子。</p>
</li>
<li><p>每次只能从一堆中取出任意数目的石子，但不能不取。</p>
</li>
<li><p>取走最后一个石子者败。</p>
</li>
</ul>
<h3 id="结论-3"><a href="#结论-3" class="headerlink" title="结论"></a>结论</h3><p>先手必胜当且仅当：</p>
<ol>
<li><p>所有堆的石子数都为 $1$ 且游戏的 SG 值为 $0$；</p>
</li>
<li><p>有些堆的石子数大于 $1$ 且游戏的 SG 值不为 $0$。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;tmp);</span><br><span class="line">        <span class="keyword">if</span>(tmp&gt;=<span class="number">2</span>) flag=<span class="number">1</span>;</span><br><span class="line">        ans^=tmp;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span>((ans&amp;&amp;flag) || (!ans&amp;&amp;!flag))</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;John&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Brother&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>P4279 [SHOI2008]小约翰的游戏</p>
<p>UVA1566 John(双倍经验)</p>
<hr>
<h2 id="multi-SG"><a href="#multi-SG" class="headerlink" title="multi-SG"></a>multi-SG</h2><h3 id="规则-3"><a href="#规则-3" class="headerlink" title="规则"></a>规则</h3><ul>
<li>有 $n$ 堆石子</li>
<li>可以从任意一堆石子中拿任意石子(不能不拿)</li>
<li>或者把一堆数量不少于 $2$ 石子分为两堆不为空的石子。</li>
</ul>
<h3 id="结论-4"><a href="#结论-4" class="headerlink" title="结论"></a>结论</h3><p>$SG\left(x\right) =<br>\begin{cases}<br>x-1 &amp; ( x \mod 4=0)<br>\\ x &amp; ( x \mod 4=1 \lor 2)<br>\\ x+1 &amp; ( x \mod 4=3)<br>\end{cases}$</p>
<p>注：$1 \lor 2$ -&gt; $1$ || $2$</p>
<p><del>对这个结论我有绝佳的证明，但我要去玩DDLC了</del></p>
<p><del>Update:更好看且对齐的Latex</del></p>
<h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p>P3185 [HNOI2007]分裂游戏 <del>(关系并不大的样子)</del></p>
<p>P3235 [HNOI2014]江南乐 (未做qwq) (现在做过了qwq)</p>
<hr>
<h2 id="阶梯SG"><a href="#阶梯SG" class="headerlink" title="阶梯SG"></a>阶梯SG</h2><h3 id="规则-4"><a href="#规则-4" class="headerlink" title="规则"></a>规则</h3><ul>
<li>有若干级阶梯，每级阶梯上有一个单个游戏</li>
<li>每次可以对一个阶梯操作并将操作中失去的东西丢到下一级阶梯上。</li>
</ul>
<h3 id="应用范围"><a href="#应用范围" class="headerlink" title="应用范围"></a>应用范围</h3><p>对于单个游戏状态，若操作集合可逆（即上一级丢给这级的东西在这级可以再丢掉），则可以应用。</p>
<h3 id="结论-5"><a href="#结论-5" class="headerlink" title="结论"></a>结论</h3><p>令最低级阶梯为第 $0$ 级，对奇数级阶梯上的游戏 SG 值取异或和，为 $0$ 先手必败，否则先手必胜。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">rei sg=<span class="number">0</span><span class="comment">/*本行sg值*/</span>,tot=<span class="number">0</span><span class="comment">/*连续石头的个数*/</span>;</span><br><span class="line"><span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">rei C=<span class="number">20</span>-m+<span class="number">1</span>;<span class="comment">//空格个数</span></span><br><span class="line"><span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=m;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x),st[x]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=<span class="number">20</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])&#123;<span class="comment">//石头不再连续</span></span><br><span class="line">            <span class="keyword">if</span>((--C)&amp;<span class="number">1</span>) sg^=tot;<span class="comment">//奇数行</span></span><br><span class="line">            tot=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ++tot;</span><br><span class="line">&#125;</span><br><span class="line">ans^=sg;</span><br></pre></td></tr></table></figure>
<h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h3><p>P2575 高手过招</p>
<p>P3480 [POI2009]KAM-Pebbles 需要一些转化技巧</p>
<hr>
<h2 id="k-SG"><a href="#k-SG" class="headerlink" title="k-SG"></a>k-SG</h2><h3 id="规则-5"><a href="#规则-5" class="headerlink" title="规则"></a>规则</h3><ul>
<li>有 $n$ 堆石子</li>
<li>每次可以从不超过 $k$ 堆中按规定规则各取一些石子</li>
<li>不能操作者败。</li>
</ul>
<h3 id="结论-6"><a href="#结论-6" class="headerlink" title="结论"></a>结论</h3><p>将每堆石子的 SG 值设为 $s_i$ 。</p>
<p>将所有 $s_i$ 二进制第 $j$ 位上的数相加得到 $r_1,r_2,\dots,r_J$（ $J$ 为所有 $s_i$ 二进制最高位的位数）</p>
<p>如果 $\forall i \in [1,J]$ 有 $r_i \equiv 0\pmod{k+1}$ ，那么先手必败；否则先手必胜。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;=<span class="number">16</span>;++i)</span><br><span class="line">    <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;=n-k;++j)<span class="comment">//能使用的最多石子</span></span><br><span class="line">        <span class="keyword">for</span>(rei x=<span class="number">0</span>; (<span class="number">1ll</span>&lt;&lt;i)*x*(d+<span class="number">1</span>) &lt;= n-k <span class="comment">/*所取的石子不多于题目限制*/</span>&amp;&amp;<span class="comment">/*所取的石子不多于总堆数 -&gt; 每堆每次只能减1*/</span> x*(d+<span class="number">1</span>) &lt;= k/<span class="number">2</span>; ++x)</span><br><span class="line">        <span class="comment">//从k/2个堆中选出x*(d+1)个，使其石子数二进制在i位为1</span></span><br><span class="line">        <span class="comment">//贡献的方案数为C[k/2][x*(d+1)]</span></span><br><span class="line">            dp[i+<span class="number">1</span>][ j+ (<span class="number">1ll</span>&lt;&lt;i)*x*(d+<span class="number">1</span>) ] = (dp[i+<span class="number">1</span>][ j+ (<span class="number">1ll</span>&lt;&lt;i)*x*(d+<span class="number">1</span>) ] + <span class="number">1ll</span>*dp[i][j]*C[k/<span class="number">2</span>][x*(d+<span class="number">1</span>)]%mod )%mod;</span><br></pre></td></tr></table></figure>
<h3 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h3><p>P2490 [SDOI2011]黑白棋</p>
<hr>
<h2 id="翻棋子游戏"><a href="#翻棋子游戏" class="headerlink" title="翻棋子游戏"></a>翻棋子游戏</h2><h3 id="规则-6"><a href="#规则-6" class="headerlink" title="规则"></a>规则</h3><ul>
<li>在一些棋子中，有的正面朝上，有的反面朝上</li>
<li>每次操作可以翻其中一颗正面朝上的棋子，会带动一些其他棋子的组合翻面。</li>
</ul>
<h3 id="结论-7"><a href="#结论-7" class="headerlink" title="结论"></a>结论</h3><p>局面的 SG 值为局面中每个正面朝上的棋子单一存在时的 SG 值的异或和。</p>
<p>具体问题具体分析吧qwq</p>
<p>将 每颗棋子翻面后可能影响的棋子组成的游戏 作为一个后继状态，<br>对每颗棋子求 SG 值，然后求所有正面朝上的棋子 SG 值的异或和，为 $0$ 先手必败，否则先手必胜</p>
<h3 id="例题-4"><a href="#例题-4" class="headerlink" title="例题"></a>例题</h3><p>P3179 [HAOI2015]数组游戏 （需要数论芝士，未做qwq）</p>
<p>P4077 [SDOI2016]硬币游戏</p>
<hr>
<h2 id="斐波那契博弈"><a href="#斐波那契博弈" class="headerlink" title="斐波那契博弈"></a>斐波那契博弈</h2><h3 id="规则-7"><a href="#规则-7" class="headerlink" title="规则"></a>规则</h3><ul>
<li><p>两人互相取一堆石子，取完者胜</p>
</li>
<li><p>第一次不能取完,至少取 $1$ 颗</p>
</li>
<li><p>从第二次开始,每个人取的石子数至少为1,至多为对手刚取的石子数的 $2$ 倍。</p>
</li>
</ul>
<h3 id="结论-8"><a href="#结论-8" class="headerlink" title="结论"></a>结论</h3><p>当 $n$ 为 $\text{fibonacci}$ 数时，先手必败</p>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><ul>
<li><p>先考虑 $n$ 为斐波那契数 $f_i$</p>
<ul>
<li><p>当 $i=2,n=2$ 显然有 先手必败</p>
</li>
<li><p>设当 $i&lt;=k$ 时结论成立</p>
<p>当 $i=k+1 , f_i=f_k+f_{k-1}$ ,一定可以将这堆石子看成两堆：$k-1,k$，因为 $2\times f_{k-1}&gt;f_k$ ,若 $\geq f_{k-1}$ 则后手可以直接取完 $f_k$ ； 若先手第一次取得石子 $&lt;f_{k-1}$，则后手一定最后取，考虑后手最多取石子 $x$ 个：</p>
<p>那么先手应取尽可能多的石子，来使后手取更多的石子，再在后手取完 $堆k-1$ 后，能使先手取完 $堆k$</p>
<p>那么让先手取 $y\geq \frac{f_{k-1}}{3}$，此时后手可以直接取完 $堆k-1$，$\therefore x=f_{k-1}-y\leq \frac{2}{3}\times f_{k-1}$</p>
<p>易知 $\frac{2}{3}\times f_{k-1}&lt;\frac{1}{2}\times f_k$ ,即，后手取完 $堆k-1$ 后，先手不能一次取完 $堆k$，则 $i=k+1$ 时，结论仍成立</p>
</li>
</ul>
</li>
<li><p>再考虑 $n$ 不为斐波那契数</p>
<ul>
<li><p>齐肯多夫定理：</p>
<p>任何正整数可以表示为若干个<strong><em>\</em>不连续**</strong>的 $\text{fibonacci}$ 数之和 <strong><em>\</em>（优先选取最大的）**</strong></p>
</li>
</ul>
<p>由于对每次取石子的最少数量没有限制，所以可以将 $n$ 按照以上定理拆成多组，每组是一个斐波那契数，并把该拿的一堆石子转化为拿多组石子</p>
<p>由于所取的数不连续，所以有 $f_{i}&gt;2\times f_{i-1}$</p>
</li>
</ul>
<p>​      令先手先取完 $i$ 最小的 $f_i$ ,此时后手不能取完 $f_{i+1} 这一堆$，相当于面临子游戏，且为必败态(有 $f_{i+1}$ 个，且后手先取)，则先手必胜</p>
<p>​       以此类推，先手必胜</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>后缀数组一些题</title>
    <url>/2021/09/24/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8D%81%E4%B8%89%E9%A2%98/</url>
    <content><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p><a href="https://www.luogu.com.cn/problem/P3809">P3809 【模板】后缀排序</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> sa[N],rk[N];<span class="comment">//sa[i]:排名i的后缀的位置;rk[i]:第i个位置开始的后缀的排名.其中 rk[ sa[i] ]=i,sa[ rk[i] ]=i</span></span><br><span class="line"><span class="keyword">int</span> tp[N],tax[N];<span class="comment">//tp[i]:基数排序的第二关键词排名为i的后缀的位置;tax[i]:辅助基数排序,i号元素(即，名次)出现的次数</span></span><br><span class="line"><span class="keyword">int</span> n,m=<span class="number">75</span>;<span class="comment">//m字符集大小</span></span><br><span class="line"><span class="keyword">int</span> height[N];<span class="comment">//height[i]:lcp(sa[i],sa[i-1]):排名为i的后缀与排名i-1的后缀的最长公共前缀</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SA&#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rsort</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;=m;++i) tax[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) ++tax[ rk[i] ];</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=m;++i) tax[i]+=tax[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(rei i=n;i;--i) sa[ tax[ rk[ tp[i] ] ]<span class="comment">/*第一关键词相同时，第二关键词较大的后缀的排名*/</span> -- <span class="comment">/*枚举第二关键词，通过rk定位到第一关键词大侠大小*/</span>]=tp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_sa</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) rk[i]=s[i]-<span class="string">&#x27;0&#x27;</span>+<span class="number">1</span>,tp[i]=i;</span><br><span class="line">        <span class="built_in">Rsort</span>();</span><br><span class="line">        <span class="keyword">for</span>(rei w=<span class="number">1</span>,p=<span class="number">0</span>;p&lt;n;m=p,w&lt;&lt;<span class="number">1</span>)&#123;<span class="comment">//w:当前倍增的长度;当前已经求出长度w的后缀的排名，要更新长度2w的后缀的排名</span></span><br><span class="line">            <span class="comment">//p:不同的后缀个数.显然仅有原字符串后缀不同时,p=n,退出</span></span><br><span class="line">            <span class="comment">//m=p:对基数排序的优化，字符集大小就是排名的个数</span></span><br><span class="line">            p=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//此时sa[i]表示的是长度为w/2的后缀中排名i的位置,即,上一轮的结果</span></span><br><span class="line">            <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=w;++i) tp[++p]=n-w+i;<span class="comment">//一些没有第二关键字的后缀，其排名在最前面</span></span><br><span class="line">            <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>(sa[i]&gt;w) tp[++p]=sa[i]-w;</span><br><span class="line">            <span class="built_in">Rsort</span>();<span class="comment">//上轮的rk更新本轮的sa</span></span><br><span class="line">            <span class="built_in">swap</span>(tp,rk);</span><br><span class="line">            rk[ sa[<span class="number">1</span>] ]=p=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;=n;++i) rk[ sa[i] ]=(tp[ sa[i<span class="number">-1</span>] ]==tp[ sa[i] ] &amp;&amp; tp[ sa[i<span class="number">-1</span>]+w ]==tp[ sa[i]+w ]) ? p : ++p;<span class="comment">//当两个后缀上一轮排名相同时,本轮也相同</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_he</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rei k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k) --k;</span><br><span class="line">            rei j=sa[ rk[i]<span class="number">-1</span> ];</span><br><span class="line">            <span class="keyword">while</span>(s[i+k]==s[j+k]) ++k;</span><br><span class="line">            height[ rk[i] ]=k;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>); n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">	SA::<span class="built_in">get_sa</span>();</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>,sa[i],i==n ? <span class="number">10</span> : <span class="number">32</span>);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><blockquote>
<p>两个后缀的最大公共前缀 $\text{lcp}$</p>
</blockquote>
<p>$\text{lcp}(x,y)=\min\{height_{x+1},height_{x+2},…,height_{y}\}$ , $\text{rmq}$ 维护， $O(1)$ 查询</p>
<blockquote>
<p>可重叠最长重复子串</p>
</blockquote>
<p>$height_{\max}$</p>
<blockquote>
<p>不可重叠最长重复子串</p>
</blockquote>
<p>见例题 $1$</p>
<blockquote>
<p>本质不同的子串数量</p>
</blockquote>
<p>枚举每一个后缀，第 $i$ 个的贡献为 $len-sa_i+1-height_i$</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="P2743-USACO5-1-乐曲主题Musical-Themes"><a href="#P2743-USACO5-1-乐曲主题Musical-Themes" class="headerlink" title="P2743 [USACO5.1]乐曲主题Musical Themes"></a><a href="https://www.luogu.com.cn/problem/P2743">P2743 [USACO5.1]乐曲主题Musical Themes</a></h3><blockquote>
<p>求不重叠的最长重复子串，两字符串相等当且仅当相同为值的两个字符差值一定(即经过转调)</p>
</blockquote>
<p>显然联想到差分，即转化为差分数组下求相等的不重叠最大子串，而最大重复子串为 $height$ 数组中最大值</p>
<p>要求不重叠，对 $k$ 二分，转化为子串的存在问题</p>
<p>将 $height \geq k$ 的归为一组，若组内 $sa_{\max}-sa_{\min}\leq k$ 则存在</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">rk[i]=s[i]+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="built_in">valid</span>(<span class="keyword">int</span> k)&#123;</span><br><span class="line">	rei MAX=-INF,MIN=INF;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(height[i]&lt;k) MAX=-INF,MIN=INF;</span><br><span class="line">		MAX=<span class="built_in">max</span>(MAX,sa[i]),MIN=<span class="built_in">min</span>(MIN,sa[i]);</span><br><span class="line">		<span class="keyword">if</span>(MAX-MIN&gt;k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    rei l=<span class="number">0</span>,r=n;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">	<span class="comment">// puts(&quot;here&quot;);</span></span><br><span class="line">		rei mid=l+r&gt;&gt;<span class="number">1</span>; <span class="built_in">valid</span>(mid) ? (l=mid+<span class="number">1</span>,ans=mid) : r=mid<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P2852-USACO06DEC-Milk-Patterns-G"><a href="#P2852-USACO06DEC-Milk-Patterns-G" class="headerlink" title="P2852 [USACO06DEC]Milk Patterns G"></a><a href="https://www.luogu.com.cn/problem/P2852">P2852 [USACO06DEC]Milk Patterns G</a></h3><blockquote>
<p>至少出现 $k$ 次的最长重复子串</p>
</blockquote>
<p>$k$ 次，相当于选择 $k$ 个后缀后求出它们的 $\text{lcp}$</p>
<p>由 $\text{lcp}_{i,j}=\min\{height[rk[i+1]],…height[rk[j]]\}$ 可知，$k$ 个后缀在 $rk$ 上一定连续</p>
<p>二分即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">valid</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> cnt=<span class="number">0</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(height[i]&lt;now) cnt=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(++cnt&gt;=k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SP694-DISUBSTR-Distinct-Substrings"><a href="#SP694-DISUBSTR-Distinct-Substrings" class="headerlink" title="SP694 DISUBSTR - Distinct Substrings"></a><a href="https://www.luogu.com.cn/problem/SP694">SP694 DISUBSTR - Distinct Substrings</a></h3><blockquote>
<p>本质不同的子串数量</p>
</blockquote>
<p><a href="https://www.luogu.com.cn/problem/SP705">双倍经验SP705 SUBST1 - New Distinct Substrings</a></p>
<p>每个后缀的前缀对应一个子串，枚举 $i$ 会产生 $n-sa_i+1$ 个，但需要减去和上一个的 $\text{lcp}$ 即，$height_i$</p>
<p>注意多测的数据 $\text{clear}$ ，要重置 $m$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n+<span class="number">10</span>;++i) sa[i]=rk[i]=tp[i]=tax[i]=height[i]=<span class="number">0</span>;</span><br><span class="line">	ans=<span class="number">0</span>; m=<span class="number">300</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) ans+=n-sa[i]+<span class="number">1</span>-height[i];</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="URAL1297-Palindrome"><a href="#URAL1297-Palindrome" class="headerlink" title="URAL1297 Palindrome"></a><a href="https://vjudge.net/problem/URAL-1297">URAL1297 Palindrome</a></h3><blockquote>
<p>求最长回文子串</p>
</blockquote>
<p>将整个字符串反过来写在原字符串后，中间用特殊字符隔开，先求这个新字符串的莫两个后缀的最长公共前缀，再枚举每一位，计算以其为重心的最长回文子串，注意分奇偶讨论. $O(n\log n)$ 的后缀数组 $+$ $O(n)$ 的 $\text{RMQ}$</p>
<p>$\sout{O(n)的\text{Manacher}也好啊}$</p>
<p><strong>注意：</strong> 插入的特殊字符为 $1$ 时：</p>
<p>由于 <code>0</code> 的 $\text{ACSII}$ 码值为 $48$</p>
<p>故会出现 <code>rk[i]=1-48(&#39;0&#39;)+1</code> 的情况，于是要改成如下：</p>
<p><code>for(rei i=1;i&lt;=n;++i) rk[i]=s[i]-&#39;0&#39;+49,tp[i]=i;</code></p>
<p><del>qwq卡了一上午在这个了</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lcq</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">	rei l=rk[i],r=rk[j];</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span> -INF;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;r) <span class="built_in">swap</span>(l,r); ++l;</span><br><span class="line">	rei k=<span class="built_in">log2</span>(r-l+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">min</span>(st[l][k],st[ r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span> ][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=len;++i)&#123;</span><br><span class="line">		rei odd=<span class="built_in">lcq</span>(i,<span class="number">2</span>*len+<span class="number">2</span>-i);</span><br><span class="line">		<span class="keyword">if</span>(ans&lt;<span class="number">2</span>*odd<span class="number">-1</span>) ans=<span class="number">2</span>*odd<span class="number">-1</span>,pos=i-odd+<span class="number">1</span>;</span><br><span class="line">		rei even=<span class="built_in">lcq</span>(i,<span class="number">2</span>*len+<span class="number">3</span>-i);</span><br><span class="line">		<span class="keyword">if</span>(ans&lt;<span class="number">2</span>*even) ans=<span class="number">2</span>*even,pos=i-even;</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="UVA10298-Power-Strings"><a href="#UVA10298-Power-Strings" class="headerlink" title="UVA10298 Power Strings"></a><a href="https://www.luogu.com.cn/problem/UVA10298">UVA10298 Power Strings</a></h3><blockquote>
<p>求循环同构串的最小循环节/连续重复最小子串</p>
</blockquote>
<p>$\sout{KMP:n\%(n-next[n])=0 \ ?\ \frac{n}{n-next[n]}\ :\ 1 }$</p>
<p>$\sout{Hash}$</p>
<p>枚举长度的约数 $k$ ，判断 $1$ 与 $k+1$ 的后缀的 $\text{lcp}$ 是否为 $n-k$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(rei k=<span class="number">1</span>;k&lt;n;++k) <span class="keyword">if</span>(n%k==<span class="number">0</span> &amp;&amp; <span class="built_in">lcp</span>(<span class="number">1</span>,k+<span class="number">1</span>)==n-k) ans=n/k,k=n;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,!ans ? <span class="number">1</span> : ans);</span><br></pre></td></tr></table></figure>
<h3 id="SP687-REPEATS-Repeats"><a href="#SP687-REPEATS-Repeats" class="headerlink" title="SP687 REPEATS - Repeats"></a><a href="https://www.luogu.com.cn/problem/SP687">SP687 REPEATS - Repeats</a></h3><blockquote>
<p>重复次数最多的连续重复子串</p>
</blockquote>
<p>枚举长度 $L$ ，求长度 $L$ 的子串最多能连续出现几次</p>
<p>显然可以出现一次，考虑出现至少 $2$ 次的情况。</p>
<p>以子串 $sub_s$ 在 $s$ 中连续出现 $2$ 次为例，$sub_s$ 一定包含字符 $s_0,s_L,s_{2L},…$ 中相邻的两个，设包含了字符 $s_{L\times i},s_{L\times (i+1)}$</p>
<p>那么看这两个字符往前往后各能匹配到多远，记录 $\frac{\max 长度}{L}$ 和 $sub_{s_1}$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(rei L=<span class="number">1</span>;(L&lt;&lt;<span class="number">1</span>)&lt;=n;++L)</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;L*(i+<span class="number">1</span>)+<span class="number">1</span>&lt;=n;++i)&#123;</span><br><span class="line">        rei x=L*i+<span class="number">1</span>,y=L*(i+<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[x]!=s[y]) <span class="keyword">continue</span>;</span><br><span class="line">        rei z=<span class="built_in">lcp</span>(x,y);</span><br><span class="line">        rei t1=y+z<span class="number">-1</span>,t0=<span class="number">0</span>;<span class="comment">//t0最早能匹配到的点，t1最晚能匹配到</span></span><br><span class="line">        <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;=L<span class="number">-1</span>;++j)&#123;<span class="comment">//当前起始点不确定时真正循环节的第几个，所以向前找L个</span></span><br><span class="line">            <span class="keyword">if</span>(x-j&lt;<span class="number">1</span> || s[x-j]!=s[y-j]) <span class="keyword">break</span>;</span><br><span class="line">            t0=x-j;</span><br><span class="line">            rei now=((t1-t0+<span class="number">1</span>)/L);</span><br><span class="line">            <span class="keyword">if</span>(now&gt;ans || (now==ans &amp;&amp; rk[t0]&lt;rk[al])) ans=now,al=t0,ar=t0+now*L<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="P5546-POI2000-公共串"><a href="#P5546-POI2000-公共串" class="headerlink" title="P5546 [POI2000]公共串"></a><a href="https://www.luogu.com.cn/problem/P5546">P5546 [POI2000]公共串</a></h3><blockquote>
<p>给定 $n(n\leq 10)$ 个字符串，求其最长公共子串</p>
</blockquote>
<p><a href="https://www.luogu.com.cn/problem/SP1811">双倍经验SP1811 LCS - Longest Common Substring</a></p>
<p><a href="https://www.luogu.com.cn/problem/SP1812">三倍经验SP1812 LCS2 - Longest Common Substring II</a></p>
<p><a href="https://www.luogu.com.cn/problem/SP10570">四倍经验SP10570 LONGCS - Longest Common Substring</a></p>
<p><del>（逃</del></p>
<p>论文中给出了两个字符串的做法，多字符串能从中推出：</p>
<p>子串具有连续性，字符串的任何一个子串都是这个字符串某个后缀的前缀，求多个字符串的公共子串相当于求每个字符串后缀的最长公共前缀的最大值</p>
<p>首先要把所有字符串连在一起，之间用题目限定的字符集以外的字符分隔</p>
<p>那么问题转化为：在 $height$ 数组上找连续一段使这一段<strong>包含来自每个字符串的至少一个后缀</strong>，设满足条件的第 $i$ 个区间为 $[l_i,r_i]$ ，最后的答案就是 $\displaystyle{\max_{l_i\leq x\leq r_i}height_i}$</p>
<p>先考虑计算区间：双指针扫一遍，数组记录第 $i$ 个字符串的后缀出现过的次数</p>
<p>再考虑计算答案：类比滑动窗口，维护一个单调队列即可</p>
<p>复杂度 $O(\sum |S| \log\sum|S|)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> color&#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123; <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=cnt;++i) <span class="keyword">for</span>(rei j=L[i];j&lt;=R[i];++j) col[ rk[j] ]=i;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!col[x]) <span class="keyword">return</span> ;</span><br><span class="line">        ++num[ col[x] ];</span><br><span class="line">        <span class="keyword">if</span>(num[ col[x] ]==<span class="number">1</span>) ++tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!col[x]) <span class="keyword">return</span> ;</span><br><span class="line">        --num[ col[x] ];</span><br><span class="line">        <span class="keyword">if</span>(!num[ col[x] ]) --tot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;cnt);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=cnt;++i)&#123;</span><br><span class="line">        L[i]=n+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+n+<span class="number">1</span>); n+=<span class="built_in">strlen</span>(s+<span class="number">1</span>+n);</span><br><span class="line">        R[i]=n;</span><br><span class="line">        s[++n]=i+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SA::<span class="built_in">get_sa</span>(),SA::<span class="built_in">get_he</span>();</span><br><span class="line">    color::<span class="built_in">build</span>(); color::<span class="built_in">add</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail &amp;&amp; height[ q[tail] ]&gt;=height[i]) --tail;</span><br><span class="line">        q[++tail]=i; color::<span class="built_in">add</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(tot==cnt)&#123;</span><br><span class="line">            <span class="keyword">while</span>(tot==cnt &amp;&amp; l&lt;i) color::<span class="built_in">del</span>(l++);</span><br><span class="line">            color::<span class="built_in">add</span>(--l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail &amp;&amp; q[head]&lt;=l) ++head;</span><br><span class="line">        <span class="keyword">if</span>(tot==cnt) ans=<span class="built_in">max</span>(ans,height[ q[head] ]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="其他乱七八糟不想用SAM写的"><a href="#其他乱七八糟不想用SAM写的" class="headerlink" title="其他乱七八糟不想用SAM写的"></a>其他乱七八糟不想用SAM写的</h2><h3 id="P4248-AHOI2013-差异"><a href="#P4248-AHOI2013-差异" class="headerlink" title="P4248 [AHOI2013]差异"></a><a href="https://www.luogu.com.cn/problem/P4248">P4248 [AHOI2013]差异</a></h3><blockquote>
<p>求 $\displaystyle{\sum_{1\leq i&lt;j\leq n} i+j-2\times \text{lcp}(T_i,T_j)}$</p>
</blockquote>
<p>原式:</p>
<script type="math/tex; mode=display">=\frac{(n-1)\times n\times (n+1)}{2}-2\times \text{lcp}(T_i,T_j)</script><p>$height$ 数组中 $[2,n]$ 内的每个区间给答案贡献区间最小值，单调栈即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">stk[top=<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">    <span class="keyword">while</span>(top &amp;&amp; height[ stk[top] ]&gt;height[i]) R[ stk[top--] ]=i;</span><br><span class="line">    L[i]=stk[top];</span><br><span class="line">    stk[++top]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(top) R[ stk[top--] ]=n+<span class="number">1</span>;</span><br><span class="line">ans=(ll) (n<span class="number">-1</span>)*n*(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;=n;++i) ans-=(ll) <span class="number">2</span>*(R[i]-i)*(i-L[i])*height[i];</span><br></pre></td></tr></table></figure>
<h3 id="P7409-SvT"><a href="#P7409-SvT" class="headerlink" title="P7409 SvT"></a><a href="https://www.luogu.com.cn/problem/P7409">P7409 SvT</a></h3><blockquote>
<p>求 $\displaystyle{\sum_{i,j\in \{E\},i&lt;j} \text{lcp}(T_i,T_j)}$</p>
</blockquote>
<p>这个类似于上面的内题，但这个是给定的点两两组合，而上一题是全部 $n$</p>
<p>类比上题中用 $height$ 将 $\text{lcp}$ 转化为 $RMQ$ 问题，并用单调栈求答案</p>
<p>考虑本题中是否能得到类似的 $h’$</p>
<p>$\sum t\leq 3\times 10^6$ 的范围与虚树类似，故进行类似虚树的转化：将给定的点按 $rk$ 排序去重，$h’_i=\text{lcp}(st[ a[i-1] ],st[ a[i] ])$ ，那么 $h’$ 与上题的 $height$ 由相同性质，单调栈即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+q,cmp);</span><br><span class="line">q=<span class="built_in">unique</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+q)-a<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(rei i=q;i&gt;=<span class="number">2</span>;--i) a[i]=<span class="built_in">lcp</span>(a[i<span class="number">-1</span>],a[i]);</span><br><span class="line">a[<span class="number">1</span>]=<span class="number">0</span>,stk[++top]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;=q;++i)&#123;</span><br><span class="line">    <span class="keyword">while</span>(top &amp;&amp; a[i]&lt;a[ stk[top] ]) R[ stk[top--] ]=i<span class="number">-1</span>;</span><br><span class="line">    L[i]=stk[top]+<span class="number">1</span>,stk[++top]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(top) R[ stk[top--] ]=q;</span><br><span class="line"><span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;=q;++i) ans+=(ll) a[i]*(R[i]-i+<span class="number">1</span>)*(i-L[i]+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title>回文自动机笔记</title>
    <url>/2021/09/25/%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p><a href="https://www.luogu.com.cn/problem/P3649">P3649 [APIO2014]回文串</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">300010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,tot,cnt[N],len[N],fail[N],last,son[N][<span class="number">27</span>],cur;</span><br><span class="line"><span class="comment">//len_i：编号i的节点表示的回文串长度，son_&#123;i,c&#125;：i节点回文串在两边添加字符c后变成的回文串编号</span></span><br><span class="line"><span class="comment">//fail_i：回文串i的最长后缀回文串</span></span><br><span class="line"><span class="comment">//cnt_i：节点i表示的本质不同的串个数</span></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> PAM&#123;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">new_node</span><span class="params">(rei x)</span></span>&#123;</span><br><span class="line">		len[tot]=x; cnt[tot]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> tot++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_fail</span><span class="params">(rei x,rei now)</span></span>&#123;<span class="comment">//跳到最长的两边能拓展该字符的回文串</span></span><br><span class="line">		<span class="keyword">while</span>(s[ now-len[x]<span class="number">-1</span> ]!=s[now]) x=fail[x];</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">			rei x=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">			cur=<span class="built_in">get_fail</span>(last,i);<span class="comment">//找可拓展的节点</span></span><br><span class="line">			<span class="keyword">if</span>(!son[cur][x])&#123;</span><br><span class="line">				rei now=<span class="built_in">new_node</span>(len[cur]+<span class="number">2</span>);</span><br><span class="line">				fail[now]=son[ <span class="built_in">get_fail</span>(fail[cur],i) ][x];<span class="comment">//找最长回文后缀</span></span><br><span class="line">				son[cur][x]=now;<span class="comment">//cur对应的字符串拓展后对应的节点编号</span></span><br><span class="line">			&#125;</span><br><span class="line">			last=son[cur][x];</span><br><span class="line">			++cnt[last];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sumup</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(rei i=tot<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i) cnt[ fail[i] ]+=cnt[i],ans=<span class="built_in">max</span>(ans,(ll) cnt[i]*len[i]);</span><br><span class="line">		<span class="comment">// for(rei i=2;i&lt;tot;++i) ans+=cnt[i];</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">	n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">	PAM::<span class="built_in">new_node</span>(<span class="number">0</span>); PAM::<span class="built_in">new_node</span>(<span class="number">-1</span>);</span><br><span class="line">	fail[<span class="number">0</span>]=<span class="number">1</span>; last=<span class="number">0</span>;</span><br><span class="line">	PAM::<span class="built_in">build</span>();</span><br><span class="line">	PAM::<span class="built_in">sumup</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><blockquote>
<p>本质不同的回文串个数</p>
</blockquote>
<p>$tot-2$ 即可</p>
<blockquote>
<p>所有回文子串出现次数</p>
</blockquote>
<p>按拓扑序将每个节点的最长回文后缀的出现次数加上该节点的出现次数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(rei i=cnt;i&gt;=<span class="number">2</span>;--i)</span><br><span class="line">    sum[ fail[i] ]+=sum[i];</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://www.luogu.com.cn/problem/P5496">以当前节点结尾的回文子串个数</a></p>
</blockquote>
<p>设 $num_i$ 表示节点 $i$ 的回文子串个数，由于 <code>new_node</code> 操作建立的节点 $x$ 就是在 $fail_x$ 左右各加一个相同字符，则有 $num_x=num_{fail_x}+1$</p>
<p><code>build</code> 的时候动态求即可</p>
<blockquote>
<p><a href="https://www.luogu.com.cn/problem/P4287">双倍回文后缀</a></p>
</blockquote>
<p>引入 $trans$ 指针：小于等于当前节点长度一半的最长回文后缀</p>
<p>做法显然：</p>
<ul>
<li>对于 $len\leq 2$ 的串， $trans$ 指针指向其 $fail$ 节点</li>
<li>从其父亲的 $trans$ 指针开始跳 $fail$ ，直到跳到满足长度且左右能拓展当前字符的节点，将 $trans$ 指针指向该节点的儿子</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(len[now]&lt;=<span class="number">2</span>) trans[now]=fail[now];</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        rei tmp=trans[cur];<span class="comment">//从父亲的trans指针指向的节点开始</span></span><br><span class="line">        <span class="keyword">while</span>(s[ i-len[tmp]<span class="number">-1</span> ]!=s[i] || ((len[tmp]+<span class="number">2</span>)&lt;&lt;<span class="number">1</span>)&gt;len[now]) tmp=fail[tmp];<span class="comment">//直到跳到一个满足长度且左右两边能拓展该字符的节点</span></span><br><span class="line">        <span class="comment">//注意len[tmp]+2 -&gt; 要考虑拓展后的长度</span></span><br><span class="line">        trans[now]=son[tmp][x];<span class="comment">//指向其儿子</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="P4555-国家集训队-最长双回文串"><a href="#P4555-国家集训队-最长双回文串" class="headerlink" title="P4555 [国家集训队]最长双回文串"></a><a href="https://www.luogu.com.cn/problem/P4555">P4555 [国家集训队]最长双回文串</a></h3><blockquote>
<p>求串 $S$ 的最长双回文子串 $T$ 使 $T$ 可以分成 $X,Y$ ，其中 $X,Y$ 都是回文串</p>
</blockquote>
<p>考虑 $last$ 的含义：以当前加入字符结尾能得到的最长回文串的节点号，记录 $l_i=len_{last}$ 就表示以 $i$ 字符结尾的最长回文串长度</p>
<p>做两次回文自动机，一正一反，那么 $l_i+r_{n-i}$ 就是两最长回文串拼起来的结果</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> PAM&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_fail</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> n,<span class="keyword">int</span> op)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(op)&#123;</span><br><span class="line">			<span class="keyword">while</span>(s[ n-len[x]<span class="number">-1</span> ]!=s[n]) x=fail[x];</span><br><span class="line">			<span class="keyword">return</span> x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">while</span>(rev[ n-len[x]<span class="number">-1</span> ]!=rev[n]) x=fail[x];</span><br><span class="line">			<span class="keyword">return</span> x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> i,<span class="keyword">int</span> op)</span></span>&#123;</span><br><span class="line">		cur=<span class="built_in">get_fail</span>(last,i,op);</span><br><span class="line">		<span class="keyword">if</span>(!son[cur][x])&#123;</span><br><span class="line">			rei now=<span class="built_in">new_node</span>(len[cur]+<span class="number">2</span>);</span><br><span class="line">			fail[now]=son[ <span class="built_in">get_fail</span>(fail[cur],i,op) ][x];</span><br><span class="line">			son[cur][x]=now;</span><br><span class="line">		&#125;</span><br><span class="line">		last=son[cur][x];</span><br><span class="line">		op ? r[i]=len[last] : l[i]=len[last];</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) rev[i]=s[n-i+<span class="number">1</span>];</span><br><span class="line">	PAM::<span class="built_in">new_node</span>(<span class="number">0</span>); PAM::<span class="built_in">new_node</span>(<span class="number">-1</span>);</span><br><span class="line">	fail[<span class="number">0</span>]=<span class="number">1</span>; last=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) PAM::<span class="built_in">extend</span>(rev[i]-<span class="string">&#x27;a&#x27;</span>,i,<span class="number">0</span>);</span><br><span class="line">	PAM::<span class="built_in">clear</span>();</span><br><span class="line">	PAM::<span class="built_in">new_node</span>(<span class="number">0</span>); PAM::<span class="built_in">new_node</span>(<span class="number">-1</span>);</span><br><span class="line">	fail[<span class="number">0</span>]=<span class="number">1</span>; last=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) PAM::<span class="built_in">extend</span>(s[i]-<span class="string">&#x27;a&#x27;</span>,i,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;++i) ans=<span class="built_in">max</span>(ans,l[i]+r[n-i]);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CF17E-Palisection"><a href="#CF17E-Palisection" class="headerlink" title="CF17E Palisection"></a><a href="https://www.luogu.com.cn/problem/CF17E">CF17E Palisection</a></h3><blockquote>
<p>求多少对相交的回文子串(包含属于相交)</p>
</blockquote>
<p><del>容斥(</del> 正难则反</p>
<p>求所有回文子串对数减去不相交的</p>
<p>设 $l_i$ 表示从 $i$ 开始的回文串个数，$r_i$ 表示从 $i$ 结束的回文串个数</p>
<p>与上题相同，正反构造两次回文自动机</p>
<p>不相交的即为：$\displaystyle{\sum_{i=1}^{|S|} r_i \sum_{j=i+1}^{|S|}l_j}$</p>
<p>每个节点到根节点的距离(深度)，就是回文后缀的数量</p>
<p>注意这个题的空间比较紧，所以考虑用邻接表替代 $son$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> PAM&#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;=tot_pam;++i) head[i]=<span class="number">0</span>,fail[i]=len[i]=<span class="number">0</span>;</span><br><span class="line">        tot_line=<span class="number">0</span>,last=<span class="number">0</span>; len[tot_pam=<span class="number">1</span>]=<span class="number">-1</span>; fail[<span class="number">0</span>]=fail[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_son</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(rei i=head[k];i;i=Next[i]) <span class="keyword">if</span>(val[i]==c) <span class="keyword">return</span> ver[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">extend</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span>(!...)&#123;</span><br><span class="line">            ...</span><br><span class="line">            depth[now]=depth[ fail[now] ]+<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">add</span>(cur,now,x);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    PAM::<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        PAM::<span class="built_in">extend</span>(s[i]<span class="number">-97</span>,i,s);</span><br><span class="line">        ans=(ans+(r[i]=depth[last]))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=(ll) ans*(ans<span class="number">-1</span>)/<span class="number">2</span>%mod;</span><br><span class="line">    <span class="built_in">reverse</span>(s+<span class="number">1</span>,s+n+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(depth,<span class="number">0</span>,<span class="keyword">sizeof</span> depth);</span><br><span class="line">    PAM::<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        PAM::<span class="built_in">extend</span>(s[i]<span class="number">-97</span>,i,s);</span><br><span class="line">        l[n-i+<span class="number">1</span>]=depth[last];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=n;i;--i) (l[i]+=l[i+<span class="number">1</span>])%=mod;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) ans=(ans-(ll) r[i]*l[i+<span class="number">1</span>]%mod+mod)%mod;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P5555-秩序魔咒"><a href="#P5555-秩序魔咒" class="headerlink" title="P5555 秩序魔咒"></a><a href="https://www.luogu.com.cn/problem/P5555">P5555 秩序魔咒</a></h3><blockquote>
<p>求双串的最长公共回文串</p>
</blockquote>
<p>分别建两个回文自动机，最后从奇偶根开始搜索相同状态即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(MAX&lt;pam1.len[l]) MAX=pam1.len[l],ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(MAX==pam1.len[l]) ++ans;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i) <span class="keyword">if</span>(pam1.son[l][i] &amp;&amp; pam2.son[r][i]) <span class="built_in">dfs</span>(pam1.son[l][i],pam2.son[r][i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P5685-JSOI2013-快乐的-JYY"><a href="#P5685-JSOI2013-快乐的-JYY" class="headerlink" title="P5685 [JSOI2013]快乐的 JYY"></a><a href="https://www.luogu.com.cn/problem/P5685">P5685 [JSOI2013]快乐的 JYY</a></h3><blockquote>
<p>求两字符串的相等回文子串对数</p>
</blockquote>
<p>同上题，搜索中将对应节点的 $cnt$ 相乘并求和即可</p>
<p><del>大写字母蚌埠住了</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l+r&gt;<span class="number">2</span>) ans+=(ll) pam1.cnt[l]*pam2.cnt[r];</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i) <span class="keyword">if</span>(pam1.son[l][i] &amp;&amp; pam2.son[r][i]) <span class="built_in">dfs</span>(pam1.son[l][i],pam2.son[r][i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>回文自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>学不会的生成函数</title>
    <url>/2021/05/05/%E5%AD%A6%E4%B8%8D%E4%BC%9A%E7%9A%84%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="不知道怎么开始"><a href="#不知道怎么开始" class="headerlink" title="不知道怎么开始"></a>不知道怎么开始</h2><ul>
<li><p>$a=\langle1,1,1,1,1…\rangle$的生成函数是</p>
<script type="math/tex; mode=display">f(x)=x+x^2+x^3+x^4+...</script><p>限定 $x\in(-1,1)$</p>
<script type="math/tex; mode=display">f(x)=\lim_{n\to \infty} \frac{1-x^n}{1-x} = \frac{1}{1-x}</script><p>同理得,函数</p>
<script type="math/tex; mode=display">f(x)=1+x^2+x^4+x^6...=\frac{1}{1-x^2}</script><script type="math/tex; mode=display">f(x)=1+2x+3x^2+4x^3...=\frac{1}{\left(1-x \right)^2}</script><script type="math/tex; mode=display">f(x)=1+3x+6x^2+10x^3+15x^4...=\frac{1}{\left(1-x\right)^3}</script><p>推广有：</p>
<script type="math/tex; mode=display">\frac{1}{\left(1-x\right)^k} 的生成数列是 \sum_i^\infty C_{i+k-1}^{k-1} x^i</script></li>
</ul>
<p>设 $F(z) , G(z)$ 是数列 $\langle \ f_n \ \rangle , \langle \ g_i \ \rangle$ 的生成函数</p>
<ul>
<li><p>相加</p>
<script type="math/tex; mode=display">\begin{aligned}
\alpha F(z)+ \beta G(z)
&= \alpha \sum_n f_nz^n + \beta \sum_ng_nz^n \\
&=\sum_n (\alpha f_n + \beta g_n) z^n\\
\end{aligned}</script><p>得到数列 $\langle \ \alpha f_n+\beta g_n \  \rangle$ 的生成函数</p>
</li>
<li><p>平移生成函数</p>
<ul>
<li><p>向右 $m$ 位</p>
<p>即，构造前面有 $m$ 个 $0$ 的数列 $\langle \ \underbrace{0,\cdots}_{m个},g_0,g_1,\cdots \ \rangle = \langle \ g_{n-m} \ \rangle$ 的生成函数</p>
<p>直接用 $z_m$ 乘</p>
<script type="math/tex; mode=display">z_m \cdot G(z) = \sum_n g_nz^{n+m} = \sum_n g_{n-m}z^n</script></li>
<li><p>向左 $m$ 位</p>
<p>即，构造前面 $m$ 个元素被删除的数列 $\langle \ g_m,g_{m+1},g_{m+2},\cdots \ \rangle$ 的生成函数</p>
<p>减去前 $m$ 项，并用 $z_m$ 来除</p>
<script type="math/tex; mode=display">\frac{G(z)-g_0-g_1z-\cdots -g_{m-1}z^{m-1}}{z^m} = \sum_{n\geq m} g_nz^{n-m} = \sum_{n\geq 0} g_{n+m}g^z</script></li>
</ul>
</li>
<li><p>常数倍的 $z$</p>
<script type="math/tex; mode=display">G(cz) = \sum_ng_n(cz)^n = \sum_n g_nz^n</script><p>即，数列 $\langle \ c^ng_n  \ \rangle$ 的生成函数</p>
<p>当 $c=-1$ 时特别有用</p>
</li>
<li><p>相乘</p>
<script type="math/tex; mode=display">\begin{aligned}
F(z)G(z)
&=(f_0+f_1z+f_2z^2+\cdots ) \cdot (g_0+g_0z+g_0z^2+\cdots) \\
&=(f_0 \cdot g_0) + (f_0\cdot g_1 + f_1 \cdot g_0)z + (f_0\cdot g_2 + f_1\cdot g_1 + f_2 \cdot g_0) z^2 + \cdots \\
&=\sum_n \left(\sum f_k \cdot g_{n-k} \right) z^n \\
\end{aligned}</script><p>求得数列 $\langle \ h_n \ \rangle$ 的生成函数，即数列 $\langle \ f_n \ \rangle , \langle \ g_i \ \rangle$ 的卷积的生成函数</p>
<p>和式 $\displaystyle{h_n=\sum_{k=0}^n f_k \cdot g_{n-k}}$</p>
</li>
</ul>
<p><strong>具体参见具体数学P280 , 表7-1，7-2</strong></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>卢神的神题选讲</title>
    <url>/2021/05/14/%E5%8D%A2%E7%A5%9E%E7%9A%84%E6%9D%82%E9%A2%98%E9%80%89%E8%AE%B2/</url>
    <content><![CDATA[<h2 id="P6962-NEERC2017-Knapsack-Cryptosystem"><a href="#P6962-NEERC2017-Knapsack-Cryptosystem" class="headerlink" title="P6962 [NEERC2017]Knapsack Cryptosystem"></a>P6962 [NEERC2017]Knapsack Cryptosystem</h2><p>依据数据范围分成两部分</p>
<ul>
<li><p>折半算法 $O(2^{\frac{n}{2}})$</p>
<p>将 $n$ 个数分为 $\left\lfloor \frac{n}{2} \right\rfloor$ 和 $\left\lceil \frac{n}{2} \right\rceil$ 两组，对每组中的每个子集计算和</p>
<p>再枚举其中一组，判断另一组</p>
</li>
<li><p>$O(2^{64-n} \cdot n)$</p>
<p>发现$b_i$ 与 $a_i$ 对应，枚举 $a_1$ 取值并以此解出 $r$ , 再解出 $a_2’,a_3’ \cdots a_n’$</p>
<p>从大到小贪心枚举，判断 $a’$ 是否满足条件</p>
<ul>
<li><p>注：</p>
<p>求解 $r$ 时，根据 $a_1\cdot r\equiv b_1\pmod{2^{64}} \quad \text{式1}$</p>
<p>设 $k=\text{__builtin_ctz}(b_1)$ (即，$b_1$ 二进制下末尾 $0$ 的个数)</p>
<p>$\displaystyle{\because r 是奇数 \qquad \text{注：r,q 互质}}$</p>
<p>$\therefore \text{__builtin_ctz}(a_1)=k$</p>
<p>式 $1$ 两边同除以 $2^k$ 得： $a_1 \cdot r \cdot 2^{-k} = b_1 \cdot 2^{-k} \pmod{2^{64}-k}$</p>
<p>$\therefore 得到的 r 只能保证前 64-k 位正确$</p>
<p>$\therefore 再继续枚举后 k 位$</p>
<p>注意到 $a_1$ 末尾恰好有 $k$ 个 $0$，所以枚举的时候每次加上 $2^{k+1}即可$</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="P6938-ICPC2017-WF-Son-of-Pipe-Stream"><a href="#P6938-ICPC2017-WF-Son-of-Pipe-Stream" class="headerlink" title="P6938 [ICPC2017 WF]Son of Pipe Stream"></a>P6938 [ICPC2017 WF]Son of Pipe Stream</h2><p>先忽略 $v$ , 因为当 $v\not ={1}$ 时，将 $v=1$ 的答案 $\cdot v^{-\alpha}$ 即可</p>
<ul>
<li><p>证：</p>
<p>$\because v\cdot f_i+w_i \leq c_i,\\ \therefore把 v 看成 1 相当于 f_i少算了 \frac{1}{v}$</p>
<p>$\because F^{\alpha}\\ \therefore \cdot v^{-\alpha}$</p>
</li>
</ul>
<p>易知若流 $(F,W)$ 合法，当且仅当 $F\leq F_{max},W\leq W_{max},F+W\leq S$</p>
<p>有解 $(F_{max},S-F_{max})$ 和 $(S-W_{max},W_{max})$</p>
<blockquote>
<p>看成增广时优先增广其中一边</p>
</blockquote>
<p>设函数 $V(F)=F^{\alpha} \cdot (S-W)^{\alpha}$ , V的最大值就是所求答案</p>
<p>当 $F=\alpha S$ 时 $V$ 有最大值</p>
<ul>
<li><p>证明 （%%%@神仙ljr</p>
<p>对 $V$ 求导</p>
<script type="math/tex; mode=display">\begin{aligned}
V(F)^{\prime}
&= (F^\alpha)^{\prime} \cdot (C-F)^{1-\alpha} + \left((C-F)^{1-\alpha} \right)^{\prime} \cdot F^{\alpha} \\
&=\alpha F^{\alpha-1} \cdot \left(\frac{1}{C-F}\right)^{\alpha-1} +  (-(1-\alpha))(C-F)^{-\alpha} \cdot x^{\alpha} \\
&=\alpha \cdot \left(\frac{F}{C-F} \right)^{\alpha-1} + (\alpha-1) \cdot \left(\frac{F}{C-F} \right)^{\alpha} \\
&=\left(\frac{F}{C-F} \right)^{\alpha-1} \cdot \left(\alpha + (\alpha-1) \cdot \frac{F}{C-F} \right) \\
\end{aligned}</script><p>当 $V(F)^{\prime}=0$ 时，V有 $\max$</p>
<p>$\therefore F=0 或 F=\alpha C$</p>
</li>
</ul>
<p>所以构造出流 $(F_0,S-F_0)$ ，其中 $F_0$ 是与 $\alpha \cdot S$ 最接近的</p>
<ul>
<li><p>实现</p>
<ol>
<li><p>分别以 $1,2$ 为源跑一次最大流，得 $Flubber$ 和 $Water$ 的最大流量 $F_{max},W_{max}$</p>
</li>
<li><p>再新建源连向 $1,2$ ，跑一次 $Flubber+Water$ 的最大混合流量 $S$ ，最优的 $F$ 就是在 $[S−W_{max},F_{max}]$ 里最贴近 $\alpha \cdot S$ 的值，于是得到新的 $F^{\prime}$ ，然后 $W^{\prime}=S−F^{\prime}$ ，可以证明这两个流量是一定可以得到且一定是最优的</p>
</li>
<li><p>然后考虑构造解，新建源连向 $1,2$ 容量分别为 $F^{\prime},W^{\prime}$ ，跑一次最大流，然后根据这次结果新建图，新图中每条边的方向就是这次流的方向，容量就是这次的流量</p>
</li>
<li><p>超级源点只连 $1$ 容量 $F^{\prime}$ 跑一次得到每条边 $Flubber$ 的流量，只连 $2$ 容量 $W^{\prime}$ 跑一次得到每条边 $Water$ 的流量</p>
</li>
</ol>
</li>
</ul>
<hr>
<h2 id="P6944-ICPC2018-WF-Gem-Island"><a href="#P6944-ICPC2018-WF-Gem-Island" class="headerlink" title="P6944 [ICPC2018 WF]Gem Island"></a>P6944 [ICPC2018 WF]Gem Island</h2><p>最终状态出现次数相等，均为 $d!$ 次</p>
<p>不同操作方案有 $n\cdot (n+1)\cdot \cdots (n+1-1)=\frac{(n+d-1)!}{(n-1)!}$</p>
<p>先求出不同的最终状态，再进行处理</p>
<p>$\therefore$ 转化为求和为 $n+d$ 的 $n$ 个数，且满足每个数 $\geq$ $1$ 的所有方案的前 $r$ 个数的和</p>
<p>起初每个人都为 $1$ 个，和为 $n$</p>
<p>选 $s_1$ 个人变成 $2$ 个，和为 $n+s_1$，方案数 $\ast$= $\dbinom{n}{s_1}$</p>
<p>在 $s_1$ 个人中选 $s_2$ 个，和为 $n+s_1+s_2$ ，方案数 $\ast$= $\dbinom{s_1}{s_2}$</p>
<p>$\cdots$</p>
<p>每一次对前 $r$ 大的贡献为 $\min(r,s_x)$ ，其中 $s_x$ 为当前加入的个数</p>
<hr>
<h2 id="P6922-ICPC2016-WF-Longest-Rivers"><a href="#P6922-ICPC2016-WF-Longest-Rivers" class="headerlink" title="P6922 [ICPC2016 WF]Longest Rivers"></a>P6922 [ICPC2016 WF]Longest Rivers</h2><p>对于叶子节点 $i$ ，一定有从其到根的一条路径,距离为 $d_i$</p>
<p>要满足剖分 $D$ 中叶子节点 $j$ 所在链长 $l_{D,j} &gt; d_i$ 的链 $l$ 的数量最小</p>
<p>对于每个节点 $i$ ，如果存在一条河流比 $d_i$ 长，那么让它延伸会使答案最小，否则要选择一条最短的河流来进行延伸。</p>
<p>设 $f_i$ 表示每个节点往外延伸的河流的长度的最小值，通过树形DP求。</p>
<p>将 $d$ 升序，临界点自下向上收束，对每个 $d_i$ ，所有超过了上一个 $d$ 的限制，但是满足当前的 $d$ 限制的临界点，这些点将不再是临界点。</p>
<p>若一个点所有的儿子都不是临界点，则它变为临界点。</p>
<p>用堆按 $f$ 从小到大维护临界点，答案就是临界点个数+1，也就是堆中元素个数+1。</p>
<hr>
<h2 id="P4348-CERC2015-Cow-Conﬁnement"><a href="#P4348-CERC2015-Cow-Conﬁnement" class="headerlink" title="P4348 [CERC2015]Cow Conﬁnement"></a>P4348 [CERC2015]Cow Conﬁnement</h2><p>扫描线 <del>显然</del></p>
<p>考虑从右往左扫，维护 $f_y$：</p>
<ul>
<li><p>当 $y+1$ 处是栅栏，$(x,y)$ 处的答案就是 $f_y$</p>
</li>
<li><p>若不是，$f_y$ 是 $(x,y)$ 比 $(x,y+1)$ 多出来的值</p>
</li>
<li><p>看成差分</p>
<p>向下累加 $y$ 直到栅栏</p>
<ul>
<li><p>牛 $\Rightarrow$ 查询</p>
</li>
<li><p>花 $\Rightarrow$ $+1$</p>
</li>
<li><p>栅栏 $(x_l,y_l,x_r,y_r)$</p>
<p>在 $x_r$ 处清空 $[y_l,y_r]$ , $y_l-1$ 处加上 $y_l$ 的值,记录 $y_r+1$ 的值</p>
<p>在 $x_l-1$ 处清空 $[y_l,y_r]$ , $y_l-1$ 减去在 $x_r$ 处记录的 $y_r+1$ 的值，防止没有栅栏阻挡而重复计算</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="P7024-NWRRC2017-Fygon-2-0"><a href="#P7024-NWRRC2017-Fygon-2-0" class="headerlink" title="P7024 [NWRRC2017]Fygon 2.0"></a>P7024 [NWRRC2017]Fygon 2.0</h2><p>神仙图论题</p>
<p>考虑语句<code>for i in range(a,b):</code></p>
<p>它创建了变量 $i,a,b$ 并给出它们的大小关系 $a\leq i \ , \ i\leq b$</p>
<p>对于条件 $x\leq y$ ，由 $x$ 向 $y$ 连出有向边</p>
<p>在整张图上，若出现强连通分量就必须满足其中的每个点取值相同(即 $a\leq b\leq c \cdots \leq a$) $\Rightarrow$ 考虑缩点</p>
<p>缩点后得到一个DAG，考虑到有向无环且每个点的值都可以在 $1\to n$ 中取，那么DAG的顶点数即为 $k$</p>
<p>而DAG的一个拓扑序 (即DAG上点的一种大小关系) 对应一个合法的 $k$ 元组</p>
<p>设拓扑序有 $N$，则 $f(n)\geq N \cdot \dbinom{n}{k}$</p>
<p>$\displaystyle{\because \lim_{n \to \infty}\frac{f(n)}{C \cdot n^k}=1 \And \lim_{n \to \infin} \frac{n^{\underline{k}}}{n^k}=1}$</p>
<p>那么 $C=\frac{N}{k!}$</p>
<p>最后用状压求拓扑序个数</p>
<p>注:   输入: <code>I</code><br>        输出:  <code>I</code><br>        输入: <code>I qwq</code><br>       输出: <code>I</code><br>即，当 <code>cin&gt;&gt;string</code> 时，会因为 <code>[space]</code> 而停止，但不会因为最前面的 <code>space</code> 停止</p>
<hr>
<h2 id="P7016-CERC2013-Captain-Obvious-and-the-Rabbit-Man"><a href="#P7016-CERC2013-Captain-Obvious-and-the-Rabbit-Man" class="headerlink" title="P7016 [CERC2013]Captain Obvious and the Rabbit-Man"></a>P7016 [CERC2013]Captain Obvious and the Rabbit-Man</h2><p>这是人做的？</p>
<p><del>并不会<a href="https://www.cnblogs.com/Winniechen/p/10246295.html">特征多项式与常系数线性齐次递推</a></del></p>
<p>GG</p>
<p>$f_2,f_3,\cdots ,f_{k+1}$ 互不相同，$\therefore \{a_n\}_{n\geq 1}$ 是一个 $n$ 阶的常系数线性齐次递推数列</p>
<p>特征多项式为 $\displaystyle{P(x)=(x-f_2)\cdot(x-f_3)\cdots(x-f_{k+1})}$</p>
<p>设 $\displaystyle{P(x)=x^k-b_1x^{k-1}-b_2x^{k-2}-\cdots -b_{k-1}x-b_k}$</p>
<p>则 $a_{k+1}=b^1a_k+b_2a_{k-1}+\cdots +b^ka_1$</p>
<p>所以计算出 $P(x)$ 系数再带入即可</p>
<hr>
<h2 id="P4354-CERC2015-Ice-Igloos"><a href="#P4354-CERC2015-Ice-Igloos" class="headerlink" title="P4354 [CERC2015]Ice Igloos"></a>P4354 [CERC2015]Ice Igloos</h2><p>对每个圆，与之相交的直线只会在其周围的4个方格中出现</p>
<p>那么对每个线段，枚举其经过的方格，查看在当前单元格中出现的圆是否与该直线相交</p>
<p>垃圾暴力复杂度 $\Theta(m\ast 4\ast 1000)$ <del>但够过了</del></p>
<p><del>实现好烦</del></p>
<hr>
<h2 id="P7054-NWRRC2015-Graph"><a href="#P7054-NWRRC2015-Graph" class="headerlink" title="P7054 [NWRRC2015]Graph"></a>P7054 [NWRRC2015]Graph</h2><p>神仙图论题</p>
<p>贪心，从开头到末尾依次贪心，让第一个位置的字典序最大，再让第二个最大</p>
<p>对某个拓扑层来说，需要对该点中最小节点加边</p>
<p>用一个最大堆存暂时无法连边的节点，之后无法拓扑时从中取出顶，将拓扑序的结尾点连向该顶</p>
<hr>
<h2 id="P4351-CERC2015-Frightful-Formula"><a href="#P4351-CERC2015-Frightful-Formula" class="headerlink" title="P4351 [CERC2015]Frightful Formula"></a>P4351 [CERC2015]Frightful Formula</h2><ul>
<li><p>题意</p>
<script type="math/tex; mode=display">f_{i , j} = \begin{cases} l_i & j = 1 \\ t_j & i = 1 \\ a \cdot f_{i, j - 1} + b \cdot f_{i - 1, j} + c & \text{otherwise} \end{cases}</script><p>求 $f_{n,n}$</p>
<p>取模 $1e6+3$</p>
</li>
<li><p>解</p>
<ul>
<li><p>先考虑 $c=0$</p>
<p>该情况是典型的<a href="https://www.cnblogs.com/p-b-p-b/p/14184761.html">格路计数</a></p>
<p>从 $(1,1)$ 到 $(n,m)$ 的路径数为 $\displaystyle{C_{n+m-2}^{n-1}}$</p>
<ul>
<li><p>证：</p>
<p>一条 $(1,1)$ 到 $(n,m)$ 的自由路可以唯一对应到一个含有 $n-1$ 个右步 $L$ 和 $m-1$ 个下步 $U$ 的序列</p>
<p>每个这种序列也可唯一对应一条自由路</p>
<p>$\therefore$ $(n,m)$ 自由路的条数等于从 $n+m-2$ 个位置中选出 $n-1$ 个 $L$ 的方案数</p>
</li>
</ul>
<p>考虑右步贡献 $\ast a$ , 下步贡献 $\ast b$</p>
<p>$\therefore$ 总贡献是 $C_{n+m-2}^{n-1}\cdot a^{n-1}\cdot b^{m-1}$</p>
<p>由于第一行/列初始贡献不同，所以对每个起点都要计算</p>
</li>
<li><p>考虑 $c\not ={0}$</p>
<p>考虑消掉常数 $c$</p>
<p>找到 $x$ 满足 $x=ax+bx+c$ , 则设 $g_{i,j}=f_{i,j}-x=a\cdot (f_{i,j-1}-x)+b\cdot (f_{i-1,j}-x)$</p>
<p>将 $g_{n,n}$ 用上面的方法求出再加上 $x=\frac{c}{1-a-b}$ 即可</p>
</li>
<li><p>观察 $x$ 的值，仅当 $a+b \not\equiv 1\pmod {10^6+3}$</p>
<p>式子转化为 $f_{i,j}=a\cdot f_{i,j-1}+(1-a)f_{i-1,j}+c$</p>
<p>此时两项系数和相等，下标和相等，所以考虑一个与 $i+j$ 有关的函数 $h_{i,j}$</p>
<p>易得 $h_{i,j}=k\cdot (i+j)=k\cdot (i+j-1)+c$ , $\therefore k=c$</p>
<p>$\therefore (f_{i,j}-h_{i,j})=a\cdot(f_{i,j-1}-h_{i,j-1})+(1-a)\cdot(f_{i-1,j}-h_{i-1,j})$</p>
<p>令 $g_{i,j}=f_{i,j}-h_{i,j}$ ，用最上面的方法求 $g_{n,n}$ ，最后加上 $2n\cdot c$</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="P6943-ICPC2018-WF-Conquer-The-World"><a href="#P6943-ICPC2018-WF-Conquer-The-World" class="headerlink" title="P6943 [ICPC2018 WF]Conquer The World"></a>P6943 [ICPC2018 WF]Conquer The World</h2><p>具体思想可参考 $\text{WC}2019$ 论文</p>
<p>把<strong>需要军队的地方</strong>称为老鼠，<strong>军队</strong>为洞，转化为使所有老鼠进洞的总代价最小</p>
<p>为每一个老鼠设一个额外代价 $-\infty$ ，其中 $-\infty$ 是一个足够小的数，表示该老鼠和某个洞匹配后的代价。</p>
<p>因为会最小化总代价，可以保证所有老鼠进洞</p>
<p>只需要最后把答案加上 $-\infty \cdot M$ 即可，其中 $M$ 是老鼠个数</p>
<p>记节点 $i$ 到根的距离为 $depth_i$ ，树上 $Lca$ 为 $z$ 的点 $x,y$ 之间的路径长度为 $depth_x+depth_y-2\times depth_z$</p>
<p>考虑在 $z$ 子树中的所有老鼠和洞，仅需要数值，而不关心具体位置</p>
<p>上述额外代价 $-\infty$ 可与 $depth_x$ 或 $depth_y$ 累加，看做固有属性，记为 $value_x,value_y$</p>
<p>每当我们找到可以使当前总代价减小的匹配，即 $value_x+value_y-2\times depth_z&lt;0$ 的匹配，选取，答案将会变优</p>
<p>但这样找到的匹配可能不是最终答案 $\Rightarrow$ 需要一个反悔</p>
<p>考虑撤销本次匹配的代价，我们可以重新计算得到新的 $value’_x=2\times depth_z-value’_y,value’_y=2\times depth_z-value_x$</p>
<p>所以解法：即从叶子结点出发，向上进行贪心</p>
<p>用两个小根堆来维护子树内 $value_x,value_y$ 的集合，在合并两棵子树的同时合并它们对应的堆。当堆顶元素满足 $value_x+value_y-2\times depth_z&lt;0$ 时更新答案，并删除堆顶元素，加入 $value’_x,value’_y$</p>
<p>可以发现，若一对已经在 $z$ 处匹配的老鼠和洞同时反悔，那么 $z$ 的父边将会被老鼠正反经过两次，因此不反悔是更优的，从而<strong>不可能出现同时反悔的情况</strong></p>
<hr>
<h2 id="P6899-ICPC2014-WF-Pachinko"><a href="#P6899-ICPC2014-WF-Pachinko" class="headerlink" title="P6899 [ICPC2014 WF]Pachinko"></a>P6899 [ICPC2014 WF]Pachinko</h2><p>模型是网格图的随机游走</p>
<p>考虑高斯消元，有 $w\cdot h$ 个未知数，对网格 $(i,j)$ 可以设值为 $X_{i\ast w+j}$</p>
<p>则有公式 $X_{i\ast w+j}=u\cdot X_{w\ast (i-1)+j} + l\cdot X_{w\ast i+(j-1)} + r\cdot X_{w\ast i-(j+1)} + d\cdot X_{w\ast (i+1)+j} + P_{直接选到该格子}$</p>
<p>其中</p>
<script type="math/tex; mode=display">P=\begin{cases}
    \frac{1}{满足该条件的格子数} &i==0 \And \And mp_{i,j}==\text{'.'} \\
    0 &\text{otherwise} \\
\end{cases}</script><p>考虑高斯消元</p>
<p>每个方程只有 $5$ 个未知数，则有值的位置形成了一个带状矩阵</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/fz1t6hbc.png" alt=""></p>
<blockquote>
<p>偷一张<a href="https://ctp314.github.io/2020/10/14/WF2014H-Pachinko/">卢神的图</a></p>
</blockquote>
<p>$\therefore$ 一个未知数只有上 $w$ 行与下 $w$ 行之间的系数不为 $0$</p>
<hr>
<h2 id="P7011-CERC2013-Escape"><a href="#P7011-CERC2013-Escape" class="headerlink" title="P7011 [CERC2013]Escape"></a>P7011 [CERC2013]Escape</h2><p>神仙题</p>
<ul>
<li><p>先考虑最简单的链情况</p>
<p>  $blood$ 的变化为 $w_1,w_1+w_2,w_1+w_2+w_3+\cdots ,w_1+w_2+\cdots+w_n$，只有当所有数均 $\geq 0$ 时游戏胜利</p>
<p>  做一条折线图反映血量变化</p>
<p>  <img src="https://cdn.luogu.com.cn/upload/image_hosting/efbuhkq9.png" style="zoom: 33%;" /></p>
<p>  可以发现中间的部分对我们没有用，有用的是最低值(决定了是否可行)，以及最终能得到的最高值(中间的加减可忽略掉)</p>
<p>  所以可以处理得到</p>
<p>  <img src="https://cdn.luogu.com.cn/upload/image_hosting/43lz9r7u.png" style="zoom:33%;" /></p>
<p>  所以维护这个链上所能得到的最大前缀和以及最小前缀和即可</p>
<p>  所以可以把一条链简化成一个 $pair$ 数组 $[(a_1,b_1),(a_2,b_2),\cdots]$</p>
<p>  注意：这里 $a_1,b_1$ 等<strong>都是正数</strong></p>
<p>  表示折线方向为 $-a_1+b_1-a_2+b_2\cdots$ ，为统一，规定 $a_1$ 一定向下</p>
</li>
<li><p>再考虑树上</p>
<p>  每棵树总可分成多条链来考虑，只考虑两条链即可</p>
<p>  设两条链分别为 $[(a_1,b_1),(a_2,b_2),\cdots]$ 和 $[(c_1,d_1),(c_2,d_2),\cdots]$ ，<del>显然</del>第一步走 $\min(a_1,c_1)$ 是一个不劣的选择</p>
<p>  考虑向 $[(a_1,b_1),(a_2,b_2),\cdots]$ 中插入一个 $pair (x,y)$</p>
<p>  <strong>应该放到最后一个满足 $a_i &lt; x$ 的位置的后面，原因是靠前会影响前缀最小值，使无法继续向下走；靠后则不能充分利用走该处所带来的 $-x+y$ 的优势</strong></p>
</li>
<li><p>具体实现</p>
</li>
</ul>
<ol>
<li>使最终能到 $t$ 点，则设 $t$ 点权值 $\text{INF}$<ol>
<li>显然 $t$ 的子树不需要考虑</li>
<li>选用了 $\text{map}$ 存放 $\text{pair}$ ，即 $mp[a_i]=b_i$</li>
</ol>
</li>
</ol>
<h2 id="P6970-NEERC2016-Game-on-Graph"><a href="#P6970-NEERC2016-Game-on-Graph" class="headerlink" title="P6970 [NEERC2016]Game on Graph"></a>P6970 [NEERC2016]Game on Graph</h2><p>概括题意：</p>
<script type="math/tex; mode=display">\begin{cases}
    A:无限循环>A赢>B赢 \\
    B:B赢>A赢>无限循环 \\
\end{cases}</script><p>设 $v_A$ 表示在节点 $v$ 且 $A$ 先手，$v_B$ 同理</p>
<p>用 $\N+(v)$ 表示 $v$ 通过一条边可到达的所有点集合</p>
<p>定义 $\N+(v_A)$ 中的点表示下一轮轮到 $B$</p>
<ul>
<li><p>先考虑无限循环</p>
<p>对点 $v_A$ 来说，无限循环需要满足 $\exist v_B\in \N+(v_A)$ 使 $v_B$ 无限进行</p>
<p>对点 $v_B$ 来说，需要满足 $\N+(v_B) \not =\empty \And\And \forall v_A\in \N+(v_B)$ 都有 $v_A$ 满足无限循环</p>
<p>出度为 $0$ 的点可以在刚开始时分出胜负，那么不断迭代即可</p>
<p><a href="https://yhx-12243.github.io/OI-transit/records/lg6970%3Bgym101190G.html">可以剩余的点一定为无限循环点</a></p>
</li>
<li><p>考虑胜负</p>
<p>将所有无限进行的状态从图中删去，得到新图，若一个点存在先负的后继状态，则它一定是先胜；若一个点的所有后继状态都是先胜 (含没有后继状态)，则它是先负。</p>
<p>如果遇到圈则一定为 $A$ 赢</p>
</li>
</ul>
<hr>
<h2 id="P6932-ICPC2017-WF-Money-for-Nothing"><a href="#P6932-ICPC2017-WF-Money-for-Nothing" class="headerlink" title="P6932 [ICPC2017 WF]Money for Nothing"></a>P6932 [ICPC2017 WF]Money for Nothing</h2><ul>
<li><p>题意</p>
<p>这道题有个很妙的题意转化</p>
<p>即给定 $m$ 个 $A$ 点的坐标(表示生产商)， $n$ 个 $B$ 点的坐标(消费商)，求一个边与坐标轴平行的矩形，其以 $A$ 类点为右上角， $B$ 类点为左下角，且其面积最大</p>
</li>
<li><p>先考虑显然的单调性</p>
<p>对 $A$ 来说，若存在 $\{x_1,y_1\} , \{x_2,y_2\}$ 满足 $x_2\geq x_1 , y_2\geq y_1$，则只保留 $\{x_2,y_2\}$， $B$ 同理</p>
<p>只维护 $A$ 的左上单调集和 $B$ 的右下单调集</p>
<p>设 $A$ 点 $(x_A,y_A)$，$B$ 点 $(x_B,y_B)$，其形成的矩形面积</p>
<script type="math/tex; mode=display">
\begin{cases}
-\infty & x_b\leq x_r \wedge y_b\leq y_r \\
(x_b-x_r) \cdot (y_b-y_r) & \text{otherwise}
\end{cases}</script><p>易得若有一个 $A$ 点与所有 $B$ 点围成的矩形都为 $-\infty$ 则根据单调性，其余点也只能围成 $-\infty$ 的矩形，故此时答案为 $0$</p>
</li>
<li><p>考虑决策单调性</p>
<p>设 $(x_B,y_B)$ 是与 $A$ 类点 $(x_A,y_A)$ 配对的矩阵面积最大的 $B$ 类点，则对于 </p>
<script type="math/tex; mode=display">x^{\prime}<x_A , y^{\prime}>y_A ; a^{\prime}>x_B , b^{\prime}<y_B</script><p>有 </p>
<script type="math/tex; mode=display">\displaystyle{\left(a'-x'\right) \cdot \left(b'-y'\right) < \left(x_B-x'\right) \cdot \left(y_B-y'\right)}</script></li>
</ul>
<p>所以可以考虑整体二分</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>换根dp</title>
    <url>/2021/10/18/%E6%8D%A2%E6%A0%B9dp/</url>
    <content><![CDATA[<h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><p>换根 $dp$ 通常在 <strong>不指定根节点，且根节点的不同对于所求值有影响时</strong> 使用</p>
<p>套路的，有以下步骤：</p>
<ul>
<li>任意的指定根节点</li>
<li>对于当前的有根树，做一次树形 $dp$ ，并将状态转移到上面</li>
<li>从第一次的根开始做 $dfs$ ,计算转移后的阶</li>
</ul>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="P6419-COCI2014-2015-1-Kamp"><a href="#P6419-COCI2014-2015-1-Kamp" class="headerlink" title="P6419 [COCI2014-2015#1] Kamp"></a><a href="https://www.luogu.com.cn/problem/P6419">P6419 [COCI2014-2015#1] Kamp</a></h3><blockquote>
<p>一棵树上有 $K$ 个人集中在同一点，需要将这 $K$ 人分别送回，对于 $i=1\sim n$ ，如果集中在 $i$ 最少需要多少时间</p>
</blockquote>
<p>题面描述并不是太清楚，但手玩样例会发现司机最后不需要返回到聚会点</p>
<ul>
<li><p>$dfs1$</p>
<p>考虑子树内的部分如何统计：设 $g_u$ 表示从 $u$ 点开始将 $u$ 子树内的人全部送回家并返回 $u$ 的方案数</p>
<p>显然有 $g_u=\sum_{v\ is\ subtree\ of\ u} g_v+2\times w_{u,v}$</p>
<p>再考虑到司机不需要回到出发点，那么最后的答案需要减去离聚会点距离最远的一个人的距离</p>
<p>那么还需要存从当前点出发的最长链 $len_u$</p>
</li>
<li><p>$dfs2$</p>
<p>从全局的考虑，设 $f_u$ 表示以点 $u$ 为聚会点送人并最后回到 $u$ 的最短距离，那么有：</p>
<script type="math/tex; mode=display">\begin{cases}
f_u=f_v+2\times w_{u,v} &\text{以 $u$ 为根的子树中没有人家} \\
f_u=g_u &\text{除了以 $u$ 为根的子树以外其余地方没有人家} \\
f_u=f_v &\text{其余} \\
\end{cases}</script><p>对于最长链，考虑在 $dfs1$ 中维护另一个次长链便于转移</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,K;</span><br><span class="line"><span class="keyword">int</span> head[N],tot,ver[N&lt;&lt;<span class="number">1</span>],Next[N&lt;&lt;<span class="number">1</span>],edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> pos[N],num[N];<span class="comment">//num是家在u子树内的人数</span></span><br><span class="line"><span class="keyword">int</span> len[N],id[N],se_len[N];<span class="comment">//id_u 从u开始的最长链经过的第一个节点</span></span><br><span class="line">ll g[N],f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123; ver[++tot]=v,Next[tot]=head[u],head[u]=tot,edge[tot]=w;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(pos[x]) num[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=head[x];i;i=Next[i])&#123;</span><br><span class="line">		rei y=ver[i],w=edge[i]; <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs1</span>(y,x);</span><br><span class="line">		<span class="keyword">if</span>(num[y])&#123;</span><br><span class="line">			g[x]+=g[y]+(ll) <span class="number">2</span>*w;</span><br><span class="line">			rei now=len[y]+w;</span><br><span class="line">			<span class="keyword">if</span>(now&gt;=len[x]) se_len[x]=len[x],len[x]=now,id[x]=y;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(now&gt;se_len[x]) se_len[x]=now;</span><br><span class="line">		&#125;</span><br><span class="line">		num[x]+=num[y];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(rei i=head[x];i;i=Next[i])&#123;</span><br><span class="line">		rei y=ver[i],w=edge[i]; <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(!num[y]) f[y]=f[x]+(ll) <span class="number">2</span>*w,len[y]=len[x]+w;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(K-num[y])&#123;</span><br><span class="line">			f[y]=f[x];</span><br><span class="line">			<span class="keyword">if</span>(id[x]!=y &amp;&amp; len[y]&lt;len[x]+w) se_len[y]=len[y],len[y]=len[x]+w,id[y]=x;<span class="comment">//x的最长链可以更新y</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(len[y]&lt;se_len[x]+w) se_len[y]=len[y],len[y]=se_len[x]+w,id[y]=<span class="number">1</span>;<span class="comment">//x次长链可以</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(se_len[y]&lt;len[x]+w &amp;&amp; id[x]!=y) se_len[y]=len[x]+w;<span class="comment">//x最长可以更新y次长</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(se_len[y]&lt;se_len[x]+w) se_len[y]=se_len[x]+w;<span class="comment">//x次长更新y次长</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> f[y]=g[y];</span><br><span class="line">		<span class="built_in">dfs2</span>(y,x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;K);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>,u,v,w;i&lt;n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w),<span class="built_in">add</span>(u,v,w),<span class="built_in">add</span>(v,u,w);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>,x;i&lt;=K;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x),pos[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    f[<span class="number">1</span>]=g[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[i]-len[i]);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P3647-APIO2014-连珠线"><a href="#P3647-APIO2014-连珠线" class="headerlink" title="P3647 [APIO2014]连珠线"></a><a href="https://www.luogu.com.cn/problem/P3647">P3647 [APIO2014]连珠线</a></h3><blockquote>
<p>从一个珠子开始，每次可以用以下一种方式添加一个新珠子：用红线与一个珠子连起来；将两个被红线链接的珠子之间插入一个新珠子，并用蓝边链接两边两个</p>
<p>每条边有边权，得分是所有蓝线长度之和，只给出珠子和链的连接方式，但不告诉颜色，求最大可能得分</p>
</blockquote>
<p>有一个结论是：蓝线中点的形式一定是形如 <code>sonx-x-fax</code> 而不是 <code>sonx-x-sonx</code></p>
<p>先假定一个根，设 $f_{i,0/1}$ 表示点 $i$ 是否是蓝线中点，以 $i$ 为根的子树中得到的最大值</p>
<p>那么有转移：</p>
<script type="math/tex; mode=display">\begin{cases}
f_{i,0}=\sum_{j\in son_i} \max\{f_{j,0},f_{j,1}+w_j\} &\text{$ij$ 之间是红线或 $j$ 是蓝线中点}\\
f_{i,1}=f_{i,0}+\max\{f_{j,0}+w_j-\max(f_{j,0},f_{j,1}+w_j)\} &\text{枚举蓝线链接的点 $j$ ，对于 $j$ 减去之前的贡献并加上蓝线的贡献 }\\
\end{cases}</script><p>再考虑如何换根：</p>
<p>当一个点的儿子变成父亲时：儿子的贡献消失，转移方程中的最大值可能不存在，所以记录次大值</p>
<p>设 $dp_{i,0/1,j}$ 表示 $f_{i,0/1}$ 统计中，不考虑第 $j$ 个儿子所得的答案，对于 $dp_{i,0,j}$ 直接减去，对于 $dp_{i,1,j}$ 用次大值维护</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,ans;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[N&lt;&lt;<span class="number">1</span>],Next[N&lt;&lt;<span class="number">1</span>],edge[N&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line"><span class="keyword">int</span> par[N],len[N],f[N][<span class="number">2</span>];<span class="comment">//f_i,0/1:以i为根子树中，i是否作为蓝线中点得到的最大价值</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; son[N],dp[N][<span class="number">2</span>],Mx[N];<span class="comment">//dp&#123;i,0/1,j&#125; 在f_&#123;i,0/1&#125; 状态中，不考虑第j个儿子所能得到的答案</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> val)</span></span>&#123; ver[++tot]=v,Next[tot]=head[u],head[u]=tot,edge[tot]=val;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> i)</span></span>&#123; <span class="keyword">return</span> f[x][<span class="number">0</span>]+edge[i]-<span class="built_in">max</span>(f[x][<span class="number">0</span>],f[x][<span class="number">1</span>]+len[x]);&#125;<span class="comment">//状态转移</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    f[x][<span class="number">0</span>]=<span class="number">0</span>,f[x][<span class="number">1</span>]=-INF;</span><br><span class="line">    rei MAX=-INF,MAX_se=-INF;</span><br><span class="line">    <span class="keyword">for</span>(rei i=head[x];i;i=Next[i])&#123;</span><br><span class="line">        rei y=ver[i]; <span class="keyword">if</span>(y==fa) <span class="keyword">continue</span>;</span><br><span class="line">        len[y]=edge[i],par[y]=x;</span><br><span class="line">        son[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">        f[x][<span class="number">0</span>]+=<span class="built_in">max</span>(f[y][<span class="number">0</span>],f[y][<span class="number">1</span>]+edge[i]);</span><br><span class="line">        rei tmp=<span class="built_in">move</span>(y,i);</span><br><span class="line">        <span class="keyword">if</span>(tmp&gt;MAX) MAX_se=MAX,MAX=tmp;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tmp&gt;MAX_se) MAX_se=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    f[x][<span class="number">1</span>]=f[x][<span class="number">0</span>]+MAX;</span><br><span class="line">    <span class="keyword">for</span>(rei i=head[x];i;i=Next[i])&#123;</span><br><span class="line">        rei y=ver[i]; <span class="keyword">if</span>(y==fa) <span class="keyword">continue</span>;</span><br><span class="line">        dp[x][<span class="number">0</span>].<span class="built_in">push_back</span>(f[x][<span class="number">0</span>]-<span class="built_in">max</span>(f[y][<span class="number">0</span>],f[y][<span class="number">1</span>]+edge[i]));</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">move</span>(y,i)==MAX)&#123;</span><br><span class="line">            dp[x][<span class="number">1</span>].<span class="built_in">push_back</span>(dp[x][<span class="number">0</span>].<span class="built_in">back</span>()+MAX_se);</span><br><span class="line">            Mx[x].<span class="built_in">push_back</span>(MAX_se);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            dp[x][<span class="number">1</span>].<span class="built_in">push_back</span>(dp[x][<span class="number">0</span>].<span class="built_in">back</span>()+MAX);</span><br><span class="line">            Mx[x].<span class="built_in">push_back</span>(MAX);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>,SS=son[x].<span class="built_in">size</span>()<span class="number">-1</span>;i&lt;=SS;++i)&#123;</span><br><span class="line">        f[x][<span class="number">0</span>]=dp[x][<span class="number">0</span>][i],f[x][<span class="number">1</span>]=dp[x][<span class="number">1</span>][i];</span><br><span class="line">        <span class="keyword">if</span>(par[x])&#123;</span><br><span class="line">            f[x][<span class="number">0</span>]+=<span class="built_in">max</span>(f[ par[x] ][<span class="number">0</span>],f[ par[x] ][<span class="number">1</span>]+len[x]);</span><br><span class="line">            f[x][<span class="number">1</span>]=f[x][<span class="number">0</span>]+<span class="built_in">max</span>(Mx[x][i],f[ par[x] ][<span class="number">0</span>]+len[x]-<span class="built_in">max</span>(f[ par[x] ][<span class="number">0</span>],f[ par[x] ][<span class="number">1</span>]+len[x]));</span><br><span class="line">        &#125;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,f[ son[x][i] ][<span class="number">0</span>]+<span class="built_in">max</span>(f[x][<span class="number">0</span>],f[x][<span class="number">1</span>]+len[ son[x][i] ]));</span><br><span class="line">        <span class="built_in">dfs2</span>(son[x][i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,x,y,z;i&lt;n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z),<span class="built_in">add</span>(x,y,z),<span class="built_in">add</span>(y,x,z);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>); <span class="built_in">dfs2</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P4228-清华集训2017-榕树之心"><a href="#P4228-清华集训2017-榕树之心" class="headerlink" title="P4228 [清华集训2017] 榕树之心"></a><a href="https://www.luogu.com.cn/problem/P4228">P4228 [清华集训2017] 榕树之心</a></h3><blockquote>
<p>起初时，树上只有一个点，心也在一号点，之后每一步树会长出一个新节点，心会沿着其到新节点的简单路径走一步，不同的生长顺序会时心最终位置不同，求哪些点可能时心最后在的位置</p>
</blockquote>
<p>对于任意点 $x$ ，心最后在 $x$ 的必要条件为 $depth_x+n$ 是奇数</p>
<p>再考虑如何使心在根节点：显然当根的所有子树大小都小于 $\left\lfloor\frac{n}{2} \right\rfloor$ 时，心可能在根节点</p>
<p>那么当有一子树大小大于 $\left\lfloor\frac{n}{2} \right\rfloor$ 时，根可能被拉到该子树中，但也可能仍会在根节点中(例如当该子树是一个菊花图时)</p>
<p>考虑维护子树内 心的深度：设 $f_i$ 表示 $i$ 子树中，心与 $i$ 相对深度的最小值，显然 $f_i$ 与 $Size_i$ 始终具有不同的奇偶值</p>
<p>设 $i$ 的子树中子树大小最大的是 $c$ 子树，那么有：</p>
<ul>
<li><p>若 $Size_c\leq \left\lfloor\frac{Size_i}{2} \right\rfloor$</p>
<p>则心可以被拉回，$f_i=(Size_i+1)\mod 2$</p>
</li>
<li><p>否则</p>
<p>心可能在 $c$ 子树中，设 $rest=Size_i-Size_c-1$</p>
<p>若 $f_c\leq rest$ ，则心能拉回来，仍有 $f_i=(Size_i+1)\mod 2$</p>
<p>若 $f_c&gt;rest$ ，此时仍要尽力去拉，则有 $f_i=f_c-rest+1$</p>
</li>
</ul>
<p>那么当 $f_0=1$ 时，心在根节点</p>
<p>再考虑换根过程：</p>
<p>对于每个点，先考虑 $depth_x+n$ 的奇偶性</p>
<p>对于根从 $1$ 转移到 $x$ 的情况，此时 $x$ 上方可以看成另一个子树</p>
<p>那么换根时，对于每个点 $x$ ，求出其上面的子树大小</p>
<p>与 $1$ 为根时类似的，考虑 $x$ 中 $\max\{Size_c\}$ 的子树 $c$ ，比较 $rest$ 与 $f_c$ 的关系即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[N&lt;&lt;<span class="number">1</span>],Next[N&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> fa[N],depth[N],Size[N];</span><br><span class="line"><span class="keyword">int</span> prf[N],sef[N],f[N];<span class="comment">//f_i:以i为根的子树中，通过操作，心深度相对于i的最小值</span></span><br><span class="line"><span class="comment">//最大子树，次大子树</span></span><br><span class="line"><span class="keyword">char</span> ok[N];</span><br><span class="line"><span class="keyword">bool</span> only_root= <span class="built_in">getchar</span>()==<span class="number">51</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    ver[++tot]=v,Next[tot]=head[u],head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ups</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">const</span> <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    Size[x]&lt;Size[y] ? x=y : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    rei &amp;fi=prf[x],&amp;se=sef[x];</span><br><span class="line">    Size[x]=fi=se=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=head[x];i;i=Next[i])&#123;</span><br><span class="line">        rei y=ver[i]; <span class="keyword">if</span>(y==fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">        fa[y]=x, depth[y]=depth[x]+<span class="number">1</span>, <span class="built_in">dfs</span>(y), Size[x]+=Size[y];</span><br><span class="line">        Size[fi]&lt;Size[y] ? (se=fi,fi=y) : (<span class="built_in">ups</span>(se,y),<span class="number">0</span>);<span class="comment">//注意这里ups没有返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">    f[x]=(f[fi]&lt;=Size[x]-Size[fi] ? Size[x]&amp;<span class="number">1</span><span class="comment">/*在子树中，心相对深度取决于子树奇偶*/</span> : f[fi]-(Size[x]-Size[fi])+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//是否是重子树 ？ 否：心可以被拉回来 ： 是：心可能在fi的子树中（注意相对深度</span></span><br><span class="line">    ++Size[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> g=<span class="number">0</span>)</span></span>&#123;<span class="comment">//换根，考虑其他点能否为心</span></span><br><span class="line">    rei y,fi;</span><br><span class="line">    <span class="comment">//显然有结论，depth(x)+n为奇数是x为心的必要条件</span></span><br><span class="line">    rei V=n-depth[x];</span><br><span class="line">    <span class="keyword">if</span>(V&amp;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">ups</span>(fi=prf[x],g);</span><br><span class="line">        ok[x]=(f[fi]&lt;=V<span class="number">-1</span>-Size[fi]) | <span class="number">48</span>;<span class="comment">//换根</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=head[x];i;i=Next[i])&#123;</span><br><span class="line">        rei y=ver[i]; <span class="keyword">if</span>(fa[y]!=x) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">ups</span>(fi=g,y==prf[x] ? sef[x] : prf[x]);</span><br><span class="line">        <span class="built_in">dfs2</span>(y,fi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rei T; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        tot=<span class="number">0</span>; <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;n;++i)&#123;rei u,v; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v); <span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);&#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(<span class="number">1</span>),only_root)&#123;<span class="built_in">putchar</span>( (!f[<span class="number">1</span>])|<span class="number">48</span> ),<span class="built_in">putchar</span>(<span class="number">10</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="built_in">memset</span>(ok,<span class="number">48</span>,<span class="keyword">sizeof</span> ok), ok[n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(<span class="number">1</span>),<span class="built_in">puts</span>(ok+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>(); <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>数数总结</title>
    <url>/2021/10/10/%E6%95%B0%E6%95%B0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="Twelvefold-way"><a href="#Twelvefold-way" class="headerlink" title="Twelvefold way"></a>Twelvefold way</h3><blockquote>
<p>$n$ 个有/无标号的球放到 $m$ 个有无标号的盒子中，无限制/每个盒子至少一个/每个盒子至多一个</p>
</blockquote>
<p>$1.$ 有标号球放有标号盒子，无限制</p>
<p>​    <script type="math/tex">m^n</script></p>
<p>$2.$ 有标号球放有标号盒子，每个盒子至少一个</p>
<p>​    考虑容斥，设 $S(a_1,a_2,…,a_k)$ 表示 $a_1,a_2,…,a_k$ 全空的情况</p>
<p>​    答案即为:</p>
<p>​    <script type="math/tex">m^n-S(1)-S(2)-...+(-1)^m S(1,2,...,m)=\sum_{i=0}^m (-1)^i (m-i)^n \binom{m}{i}</script></p>
<p>$3.$ 有标号球放有标号盒子，每个盒子至多一个</p>
<p>​    <script type="math/tex">A_m^n</script></p>
<p>$4.$ 无标号球放有标号盒子，无限制</p>
<p>​    设 $y_i=x_i+1$ ，即求方程 $y_1+y_2+…+y_m=n+m$ 的正整数解的个数</p>
<p>​    <script type="math/tex">\binom{n+m-1}{m-1}</script></p>
<p>$5.$ 无标号球放有标号盒子，每个盒子至少一个</p>
<p>​    经典插板法，不妨看成方程 $x_1+x_2+…+x_m=n$ 的正整数解个数，也就是 $n$ 个球插入 $m-1$ 个板子</p>
<p>​    <script type="math/tex">\binom{n-1}{m-1}</script></p>
<p>$6.$ 无标号球放有标号盒子，每个盒子至多一个</p>
<p>​    <script type="math/tex">A_m^n</script></p>
<p>$7.$ 有标号球放无标号盒子，无限制</p>
<p>​    通过 $8$ 的答案，枚举多少个盒子放了球即可</p>
<p>​     $$\sum_{i=1}^m {n\brace i}$$  </p>
<p>$8.$ 有标号球放无标号盒子，每个盒子至少一个</p>
<p>​    显然符合第二类斯特林数  $\displaystyle{{n\brace m}}$  ，即，将 $n$ 个物品的集合划分成 $m$ 个非空子集的方案数</p>
<p>$9.$ 有标号球放无标号盒子，每个盒子至多一个</p>
<p>​    <script type="math/tex">[n\leq m]</script></p>
<p>$10.$ 无标号球放无标号盒子，无限制</p>
<p>​    通过 $11$ 的答案，枚举盒子数</p>
<p>​    <script type="math/tex">\sum_{i=1}^m p_{n,i}</script></p>
<p>$11.$ 无标号球放无标号盒子，每个盒子至少一个</p>
<p>​    满足划分数 $p_{n,m}$ ，即，将 $n$ 划分为 $m$ 个正整数方案数</p>
<p>​    满足递推式 $p_{n,m}=p_{n-m,m}+p_{n-1,m-1}$</p>
<p>$12.$ 无标号球放无标号盒子，每个盒子至多一个</p>
<p>​    <script type="math/tex">[n\leq m]</script></p>
<h3 id="错排"><a href="#错排" class="headerlink" title="错排"></a>错排</h3><ul>
<li><p>考虑 $D_n$ 的递推</p>
<p>$n$ 能放到 $[1,n)$ 的任意一位置 $k$ 上</p>
<p>若 $k$ 在 $n$ 上，则还有 $n-2$ 个数没有确定位置，答案为 $D_{n-2}$</p>
<p>若 $k$ 不在 $n$ 上，那么 $n-1$ 个数都没有位置，$D_{n-1}$</p>
<p>$k$ 有 $n-1$ 种取值，那么有 $\displaystyle{D_n=(n-1)(D_{i-1}+D_{i-2})}$</p>
</li>
<li><p>考虑封闭形式</p>
<p>容斥有：</p>
<script type="math/tex; mode=display">D_n=n!-\binom{n}{1}(n-1) + \binom{n}{2}(n-2)!+...+(-1)^n \binom{n}{n}(n-n)!</script><p>由于：</p>
<script type="math/tex; mode=display">\binom{n}{i}(n-i)! =\frac{n!}{i!(n-i)!} \times (n-1)!=\frac{n!}{i!}</script><p>所以有：</p>
<script type="math/tex; mode=display">D_i=n!\times \sum_{i=0}^n (-1)^i \frac{1}{i!}</script></li>
</ul>
<h2 id="组合式子"><a href="#组合式子" class="headerlink" title="组合式子"></a>组合式子</h2><h3 id="上指标"><a href="#上指标" class="headerlink" title="上指标"></a>上指标</h3><p>对于任意实数 $r$ 和正整数 $k$ ，有</p>
<script type="math/tex; mode=display">\binom{r}{k}=\frac{r^{\underline{k}}}{k!}</script><p>如此，在上指标是负数是，即有：</p>
<script type="math/tex; mode=display">\binom{r}{k}=(-1)^k\binom{k-r+1}{k}</script><h3 id="组合恒等式"><a href="#组合恒等式" class="headerlink" title="组合恒等式"></a>组合恒等式</h3><ul>
<li><p>一行的和</p>
<script type="math/tex; mode=display">\sum_k \binom{n}{k}=(1+1)^n=2^n</script></li>
<li><p>分奇偶</p>
<script type="math/tex; mode=display">\sum_k (-1)^k \binom{n}{k}=(1-1)^n=[n=0]</script></li>
<li><p>提取/吸收恒等式</p>
<script type="math/tex; mode=display">\binom{n}{m}=\frac{n}{m}\binom{n-1}{m-1}\Rightarrow m\binom{n}{m}=n\binom{n-1}{m-1}</script></li>
<li><p>相伴恒等式</p>
<script type="math/tex; mode=display">(r-k)\binom{r}{k}=r\times \frac{(r-1)^{\underline{r-k-1}}}{(r-k-1)!}=r\binom{r-1}{k}</script><script type="math/tex; mode=display">k\binom{r}{k}=\frac{r^{\underline{k}}}{(k-1)!}=\frac{(r-k+1)\times r^{\underline{k-1}}}{(k-1)!}=(r-k+1)\binom{r}{k-1}</script></li>
<li><p>上指标反转</p>
<script type="math/tex; mode=display">\binom{r}{k}=(-1)^k \binom{r-k-1}{k}</script><ul>
<li><p>证明：</p>
<script type="math/tex; mode=display">\binom{r}{k}=\frac{r^{\underline{k}}}{k}=\frac{r(r-1)\times ...\times (r-k+1)}{k!}=(-1)^k\frac{(r-k-1)^{\underline{k}}}{k!}=(-1)^k\binom{r-k-1}{k}</script></li>
</ul>
</li>
<li><p>三项式系数恒等式</p>
<script type="math/tex; mode=display">\binom{r}{m}\binom{m}{k}=\frac{r!}{(r-m)!(m-k)!k!}=\binom{r-k}{m-k}\binom{r}{k}</script></li>
</ul>
<h3 id="一些求和"><a href="#一些求和" class="headerlink" title="一些求和"></a>一些求和</h3><ul>
<li><p>上指标求和</p>
<script type="math/tex; mode=display">\sum_{i=m}^n\binom{i}{m}=\binom{n+1}{m+1}</script><p>文字叙述为：在 $n$ 个物品后分别插入一个结束符，强选结束符并在结束符前选 $m$ 个物品数</p>
</li>
<li><p>平行求和</p>
<script type="math/tex; mode=display">\sum_{i=0}^n\binom{m+i}{i}=\binom{m+n+1}{n}</script></li>
</ul>
<h3 id="卷积与点积"><a href="#卷积与点积" class="headerlink" title="卷积与点积"></a>卷积与点积</h3><ul>
<li><p>下指标卷积</p>
<script type="math/tex; mode=display">\sum_k\binom{n}{k}\binom{m}{r-k}=\binom{n+m}{r}</script></li>
<li><p>下指标点积</p>
<script type="math/tex; mode=display">\sum_i\binom{n}{i}\binom{m}{i}=\sum_i\binom{n}{i}\binom{m}{m-i}=\binom{n+m}{m}</script><p>特殊的，有</p>
<script type="math/tex; mode=display">\sum_i\left(\binom{n}{i}^2\right)=\binom{2n}{n}</script></li>
<li><p>上指标卷积</p>
<script type="math/tex; mode=display">\begin{aligned}
\sum_i\binom{i}{a}\binom{n-i}{b}&=\sum_i\left(\sum_{j<i}\binom{i}{a-1}\right)\binom{n-i}{b} \\
&=\sum_j\binom{j}{a-1}\sum_{i>j}\binom{n-i}{b} \\
&=\sum_j\binom{j}{a-1}\binom{n-j}{b+1} \\
&=...=\sum_{j\leq n}\binom{n-j}{a+b} \\
&=\binom{n+1}{a+b+1} \\
\end{aligned}</script><p>考虑组合意义：原式相当于把 $n$ 个物品分开从前一段选 $a$ ，后一段选 $b$ 个</p>
<p>等同于将一个分隔符同 $a+b$ 个物品从 $n+1$ 选出来，其中第 $a+1$ 个物品是分隔符，方案与原式对应</p>
</li>
</ul>
<h3 id="多重集的排列数"><a href="#多重集的排列数" class="headerlink" title="多重集的排列数"></a>多重集的排列数</h3><p>多重集的全排列数为<strong>元素总数的阶乘除以重复度之和的阶乘</strong>，形式化的：</p>
<p>对于多重集 $S=\{a_1\times n_1,a_2\times n_2,…,a_k\times n_k\}$ ，全排列数为：</p>
<script type="math/tex; mode=display">\frac{\left(\sum n_i \right)!}{\prod (n_i!)}</script><p>证明：</p>
<p>设 $n=\sum n_i$</p>
<p>对于元素 $a_1$ ，放置的方案数为 $\displaystyle{\binom{n}{n_1}}$</p>
<p>对于元素 $a_2$ ，放置的方案数为 $\displaystyle{\binom{n-n_1}{n_2}}$</p>
<p>对于元素 $a_k$ ，放置的方案数为 $\displaystyle{\binom{n-n_1-n_2-…-n_{k-1}}{n_k}}$</p>
<p>那么总方案数即为 $\displaystyle{\frac{n!}{n_1!\times n_2!\times …\times n_k!}}$</p>
<h4 id="P2518-HAOI2010-计数"><a href="#P2518-HAOI2010-计数" class="headerlink" title="P2518 [HAOI2010]计数"></a><a href="https://www.luogu.com.cn/problem/P2518">P2518 [HAOI2010]计数</a></h4><blockquote>
<p>一组非 $0$ 数字，可以插入人一个 $0$ ，给出一个数，求这个数前有多少被上述方法产生的数</p>
</blockquote>
<p>设 $t$ 表示当前已处理的几位的排列总数，初始有 $t=1$</p>
<p>考虑手玩数据得到：从后往前枚举每一位，若当前位为 $a$ ，截至目前 $a$ 出现 $b$ 次，比 $a$ 小的数有 $c$ 个，则当前位对 $ans$ 的贡献为 $\frac{t\times c}{b}$</p>
<p>emmm对于正确性的话并不是太会证，感性理解一下吧qwq</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">60</span>;</span><br><span class="line"><span class="keyword">char</span> ch[N];</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">20</span>],tr[<span class="number">20</span>],n;</span><br><span class="line">ld s=<span class="number">0</span>,t=<span class="number">1</span>;<span class="comment">//s当前答案，t当前已处理的后t位的排列总数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x&amp;(-x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">for</span>(;x&lt;=<span class="number">10</span>;x+=<span class="built_in">lowbit</span>(x)) ++tr[x];&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> res=<span class="number">0</span>)</span></span>&#123; <span class="keyword">for</span>(;x;x-=<span class="built_in">lowbit</span>(x)) res+=tr[x]; <span class="keyword">return</span> res;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,ch+<span class="number">1</span>); n=<span class="built_in">strlen</span>(ch+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(rei i=n;i;--i)&#123;</span><br><span class="line">		rei a=ch[i]-<span class="string">&#x27;0&#x27;</span>+<span class="number">1</span>,c=<span class="built_in">sum</span>(a<span class="number">-1</span>);<span class="comment">//c:比a小的数的个数</span></span><br><span class="line">		<span class="keyword">if</span>(!c) t=t*(n-i+<span class="number">1</span>)/(++cnt[a]);</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			t/=(++cnt[a]);</span><br><span class="line">			s+=t*c,t*=(n-i+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">add</span>(a);</span><br><span class="line">		<span class="comment">// printf(&quot;%d %lld\n&quot;,a,(ll) s);</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(ll) s);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多项式系数"><a href="#多项式系数" class="headerlink" title="多项式系数"></a>多项式系数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><script type="math/tex; mode=display">(x+y+z)^n=\sum_{i+j+k=n} \binom{n}{i,j,k}\ \  x^i y^jz^k</script><script type="math/tex; mode=display">其中 \binom{n}{k_1,k_2,...,k_m}=\frac{n!}{\prod_{i=1}^m k_i!} 即为多重集的组合数，即，将n分为多个集合的方案数</script><script type="math/tex; mode=display">\sum k_i=n</script><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><blockquote>
<p>n个节点的有根树。给每个节点分配一个 $1\sim n$ 的数字，使得每个节点分配的数字不同，并且每个节点分配的数字都是它子树内最小的。求方案数。</p>
</blockquote>
<p>对于子树 $u$ 被分配到的字符集 $\{p_1,p_2,…,p_k | i&lt;j\Leftrightarrow p_i&lt;p_j\}$ , 节点 $u$ 值即为 $p_1$</p>
<p>将剩下的分给其子树，方案数即为：</p>
<script type="math/tex; mode=display">\binom{size_u-1}{size_{v_1},size_{v_2},...,size_{v_k}}</script><p>考虑转移，由树形 $\text{dp}$ 得：</p>
<script type="math/tex; mode=display">dp_u=\binom{size_u-1}{size_{v_1},size_{v_2},...,size_{v_k}} \times \prod_{i=1}^k dp_{v_i}</script><p>不妨设 $\displaystyle{P_i=\frac{dp_i}{size_i!}}$</p>
<p>那么有：</p>
<script type="math/tex; mode=display">dp_u=(size_u-1)!\times \prod_{i=1}^k P_{v_i}=\frac{size_u!}{size_u} \times P_{v_1}</script><p>发现递推 $\text{dp}$ 后并不太能直接看出答案：</p>
<script type="math/tex; mode=display">dp_u=\frac{size_u!}{size_u}\times \prod_{i=1}^k \frac{\frac{size_{v_i}!}{size_{v_1}} \times \prod_{j=1}^{kk} \frac{dp_{vv_i}}{size_{vv_i}!}}{size_{v_i!}}</script><p>考虑尝试递推 $\text{P}$ ，那么有：</p>
<script type="math/tex; mode=display">P_u=\frac{1}{size_u}\times \prod_{i=1}^k P_{v_i}=\frac{1}{size_u}\prod_{i=1}^k \frac{1}{size_v}\prod_{j=1}^{kk} P_{vv_j}=\prod_{v \in subtree\ of\ u} \frac{1}{size_v}</script><script type="math/tex; mode=display">P_1=\prod^n \frac{1}{size_i}</script><p>那么答案即为：</p>
<script type="math/tex; mode=display">dp_1=P_1\times size_i! =n!\times \prod^n \frac{1}{size_i}</script><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><h3 id="P3214-HNOI2011-卡农"><a href="#P3214-HNOI2011-卡农" class="headerlink" title="P3214 [HNOI2011]卡农"></a><a href="https://www.luogu.com.cn/problem/P3214">P3214 [HNOI2011]卡农</a></h3><blockquote>
<p>题意见原题面  <del>实在太繁琐了吧</del></p>
</blockquote>
<p>要求在 $n$ 个音节中挑选若干个，且音节集合不同，那么不妨将音阶集合用二进制表示，即 $1\sim 2^n-1$ 种片段</p>
<p>又要求选择无序的 $m$ 个片段，可以考虑按照有序计算并除以 $m!$</p>
<p>题干中的规定可以有如下转化：</p>
<ul>
<li>任意两片段音节集合不同 $\Rightarrow$ $m$ 个数互不相同</li>
<li>一段音乐中每个音阶出现次数为偶数 $\Rightarrow$ $m$ 个数异或和为 $0$</li>
</ul>
<p>设 $f_i$ 表示选 $i$ 个数且满足上述性质的方案数</p>
<p>直接计算并不方便，考虑做一下容斥：</p>
<p>先局部的考虑：若有 $f_{i-1}$ 的异或和为 $x$</p>
<p><del>是的这准确来说不是 $f$</del></p>
<p>为了便于理解，设 $a_i$ ，其中 $a_{1\sim i-1}$ 并不满足上述性质，但 $a_i$ 满足性质 $2$</p>
<p>那么 $a_i$ 的方案数就是 $a_{i-1}$ 的方案数，也就是，选出 $a_i$ 的方案数为 $A_{2^n-1}^{i-1}$ ，即，从所有非空子集里选出前 $i-1$ 个的排列数</p>
<p>再考虑减去其中不合法的方案：</p>
<ul>
<li><p>第 $i$ 个子集为空，即前 $i-1$ 个子集异或和为 $0$</p>
<p>方案数 $f_{i-1}$</p>
</li>
<li><p>第 $i$ 个子集和之前的第 $j$ 个子集相同</p>
<p>方案数 $f_{i-2}\times (2^n-1-(i-2))\times (i-1)$</p>
</li>
</ul>
<p>那么总的转移就是：</p>
<script type="math/tex; mode=display">f_i=A_{2^n-1}^{i-1}-f_{i-1}-f_{i-2}\times (2^n-1-(i-2))\times (i-1)</script><p>答案就是:</p>
<script type="math/tex; mode=display">\frac{f_m}{m!}</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e8</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[N],f[N],fac;<span class="comment">//f_i是满足性质的有序集合的方案数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(ll x,<span class="keyword">int</span> y,ll res=<span class="number">1</span>)</span></span>&#123; <span class="keyword">while</span>(y)&#123; <span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=res*x%mod; y&gt;&gt;=<span class="number">1</span>; x=x*x%mod;&#125; <span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_fac</span><span class="params">(<span class="keyword">int</span> x,ll res=<span class="number">1</span>)</span></span>&#123; <span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;=x;++i) res=res*i%mod; <span class="keyword">return</span> res;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    fac=<span class="built_in">qpow</span>(<span class="number">2</span>,n)<span class="number">-1</span>; a[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=m;++i) a[i]=(ll) a[i<span class="number">-1</span>]*(fac-i+<span class="number">1</span>+mod)%mod;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;=m;++i) f[i]=(ll) (a[i<span class="number">-1</span>]-f[i<span class="number">-1</span>]+mod-(fac-i+<span class="number">2</span>)*(i<span class="number">-1</span>)%mod*f[i<span class="number">-2</span>]%mod+mod)%mod;<span class="comment">//容斥一下</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(ll) f[m]*<span class="built_in">qpow</span>(<span class="built_in">get_fac</span>(m),mod<span class="number">-2</span>)%mod);<span class="comment">//答案需要无序，去重</span></span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P5376-THUPC2019-过河卒二"><a href="#P5376-THUPC2019-过河卒二" class="headerlink" title="P5376 [THUPC2019]过河卒二"></a><a href="https://www.luogu.com.cn/problem/P5376">P5376 [THUPC2019]过河卒二</a></h3><blockquote>
<p>$n\times m$ 的棋盘上有 $k$ 个障碍点，从 $(1,1)$ 移动到棋盘的最上方或最右方 ，移动方式为 $(i,j)\Rightarrow(i+1,j),(i,j+1),(i+1,j+1)$ ，走出棋盘时仍有方案的选择，求方案数</p>
</blockquote>
<p>先考虑没有障碍：题目能转化为 $(1,1)\Rightarrow (n+1,m+1)$ ，理解为到边缘就只有一种走法</p>
<p>该题比平常的过河卒问题多了斜着走，那么枚举斜着走的次数就能转化为经典的过河卒，即：</p>
<script type="math/tex; mode=display">\sum_{i=0}^{\min(n,m)} \binom{n+m-i}{i}\binom{n+m-2\times i}{n-i}</script><p>再考虑有障碍情况，$k\leq 20$ 启示把障碍用二进制表示为 $S$</p>
<p>那么能做容斥：</p>
<script type="math/tex; mode=display">\sum_S (-1)^{|S|} g_S</script><p>其中 $g_S$ 表示至少有 $S$ 的障碍时到达终点方案数</p>
<p>提前预处理两两障碍相到达的方案数，以及起点到每个障碍，每个障碍到终点的方案数就能在 $O(\log S)$ 的时间里求出 $g_S$</p>
<p>注意 $S$ 中障碍的顺序要排序</p>
<p>题中的 $mod\leq 59393$ 较小，做预处理并用 $\text{Lucas}定理$ 求组合数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">25</span>,M=<span class="number">1048576</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">59393</span>;</span><br><span class="line">PII p[N];</span><br><span class="line"><span class="keyword">int</span> n,m,k,ans,fac[mod+<span class="number">10</span>],inv[mod+<span class="number">10</span>],fac_inv[mod+<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> Size[M],cnt[N][N],s_b[N],b_e[N];<span class="comment">//s_b:start-block; b_e:block-end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fix</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123; x&gt;=mod ? x-=mod : <span class="number">0</span>; x&lt;<span class="number">0</span> ? x+=mod : <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123; <span class="keyword">return</span> (n&lt;<span class="number">0</span> || m&lt;<span class="number">0</span> || n&lt;m) ? <span class="number">0</span> : (ll) fac[n]*fac_inv[m]%mod*fac_inv[n-m]%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lucas</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123; <span class="keyword">return</span> n&lt;mod ? <span class="built_in">get_C</span>(n,m) : (ll) <span class="built_in">lucas</span>(n/mod,m/mod)*<span class="built_in">lucas</span>(n%mod,m%mod)%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_ways</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m,ll ans=<span class="number">0</span>)</span></span>&#123; <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;=<span class="built_in">min</span>(n,m);++i) ans=(ans+(ll) <span class="built_in">lucas</span>(n+m-i,i)*<span class="built_in">lucas</span>(n+m<span class="number">-2</span>*i,n-i))%mod; <span class="keyword">return</span> ans;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fac[<span class="number">0</span>]=fac[<span class="number">1</span>]=inv[<span class="number">1</span>]=fac_inv[<span class="number">0</span>]=fac_inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;=mod<span class="number">-1</span>;++i)&#123;</span><br><span class="line">		fac[i]=(ll) fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">		inv[i]=mod-(ll) (mod/i)*inv[mod%i]%mod;</span><br><span class="line">		fac_inv[i]=(ll) fac_inv[i<span class="number">-1</span>]*inv[i]%mod;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> S)</span></span>&#123;<span class="comment">//至少经过S中的障碍的方案数</span></span><br><span class="line">	rei pre=<span class="number">-1</span>,ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;=k<span class="number">-1</span>;++i) <span class="keyword">if</span>((S&gt;&gt;i)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(pre==<span class="number">-1</span>) ans=(ll) ans*s_b[i]%mod;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(p[pre].second&gt;p[i].second) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			ans=(ll) ans*cnt[pre][i]%mod;</span><br><span class="line">		&#125;</span><br><span class="line">		pre=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (~pre) ? (ll) ans*b_e[pre]%mod : <span class="built_in">get_ways</span>(n,m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;=k<span class="number">-1</span>;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;p[i].first,&amp;p[i].second);</span><br><span class="line">	<span class="built_in">sort</span>(p,p+k);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;=k<span class="number">-1</span>;++i) <span class="keyword">for</span>(rei j=i+<span class="number">1</span>;j&lt;=k<span class="number">-1</span>;++j) cnt[i][j]=<span class="built_in">get_ways</span>(p[j].first-p[i].first,p[j].second-p[i].second);<span class="comment">//预处理两两障碍点的方案数</span></span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;=k<span class="number">-1</span>;++i) s_b[i]=<span class="built_in">get_ways</span>(p[i].first<span class="number">-1</span>,p[i].second<span class="number">-1</span>),b_e[i]=<span class="built_in">get_ways</span>(n-p[i].first+<span class="number">1</span>,m-p[i].second+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=(<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span>;++i) Size[i]=Size[i&gt;&gt;<span class="number">1</span>]+(i&amp;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;=(<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span>;++i)<span class="comment">//容斥原理：\sum_S (-1)^&#123;|S|&#125; g_S</span></span><br><span class="line">		(Size[i]&amp;<span class="number">1</span>) ? <span class="built_in">fix</span>(ans-=<span class="built_in">solve</span>(i)) : <span class="built_in">fix</span>(ans+=<span class="built_in">solve</span>(i));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P5339-TJOI2019-唱、跳、rap和篮球"><a href="#P5339-TJOI2019-唱、跳、rap和篮球" class="headerlink" title="P5339 [TJOI2019]唱、跳、rap和篮球"></a><a href="https://www.luogu.com.cn/problem/P5339">P5339 [TJOI2019]唱、跳、rap和篮球</a></h3><blockquote>
<p>见原题</p>
</blockquote>
<p>设 $f_i$ 表示序列中至少有 $i$ 组人讨论的方案数，由容斥得：</p>
<script type="math/tex; mode=display">ans=\sum_{i=0}^{\min(\frac{n}{4},a,b,c,d)} (-1)^i f_i</script><p>将讨论 $\text{cxk}$ 的四个人看成一个一个元素，那么共有 $n-4\times i+i=n-3\times i$ 个元素</p>
<p>考虑多重集排列的方案数：</p>
<script type="math/tex; mode=display">\left(\sum_{i=1}^m a_i\right)!\times \prod_{i=1}^m\frac{1}{a_i!}</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e3</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n,a,b,c,d,lim;</span><br><span class="line"><span class="keyword">int</span> fac[N],facinv[N],f[N],res,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fix</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123; x&gt;=mod ? x-=mod : <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(ll x,<span class="keyword">int</span> y,ll res=<span class="number">1</span>)</span></span>&#123; <span class="keyword">while</span>(y)&#123; <span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=res*x%mod; y&gt;&gt;=<span class="number">1</span>; x=x*x%mod;&#125; <span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fac[<span class="number">0</span>]=<span class="number">1</span>; <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) fac[i]=(ll) fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">	facinv[n]=<span class="built_in">qpow</span>(fac[n],mod<span class="number">-2</span>); <span class="keyword">for</span>(rei i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i) facinv[i]=(ll) facinv[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>,&amp;n,&amp;a,&amp;b,&amp;c,&amp;d);</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	lim=(n&gt;&gt;<span class="number">2</span>,<span class="built_in">min</span>(<span class="built_in">min</span>(a,b),<span class="built_in">min</span>(c,d)));</span><br><span class="line">	<span class="keyword">for</span>(rei x=<span class="number">0</span>;x&lt;=lim;++x)&#123;</span><br><span class="line">		rei flag=x&amp;<span class="number">1</span> ? mod<span class="number">-1</span> : <span class="number">1</span>; <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">		<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;=a-x;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;=<span class="built_in">min</span>(n<span class="number">-4</span>*x-i,b-x);++j) <span class="built_in">fix</span>(f[i+j]+=(ll) facinv[i]*facinv[j]%mod);</span><br><span class="line">		res=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;=c-x;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;=<span class="built_in">min</span>(n<span class="number">-4</span>*x-i,d-x);++j) <span class="built_in">fix</span>(res+=(ll) facinv[i]*facinv[j]%mod*f[n<span class="number">-4</span>*x-i-j]%mod);</span><br><span class="line">		res=(ll) res*fac[n<span class="number">-3</span>*x]%mod*facinv[x]%mod;</span><br><span class="line">		<span class="built_in">fix</span>(ans+=(ll) flag*res%mod);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>容斥</tag>
        <tag>数数</tag>
        <tag>组合数</tag>
      </tags>
  </entry>
  <entry>
    <title>树链剖分</title>
    <url>/2021/07/01/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/</url>
    <content><![CDATA[<h2 id="关于长链剖分中指针的理解"><a href="#关于长链剖分中指针的理解" class="headerlink" title="关于长链剖分中指针的理解"></a>关于长链剖分中指针的理解</h2><p>与指针有关的变量：$\ast dp[N],tmp[N]$,$\ast pos$</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pos=tmp;<span class="comment">//将pos指向tmp空间</span></span><br><span class="line">dp[<span class="number">1</span>]=pos, pos+=height[<span class="number">1</span>];</span><br><span class="line">   <span class="comment">//改变后pos加上dp[1]所需的长度，防止内存冲突</span></span><br></pre></td></tr></table></figure>
<p>可以把 $*dp[1]$ 看成指向 $tmp$ 上一段长为 $height[1]$ 的指针</p>
<p>那么指针 $dp[1]$ 与 $tmp[\ 0,…height[1]-1 \ ]$ 共同构成了 $dp[1][\ 0,…,height[1]-1\ ]$</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dp[to]=pos, pos+=len;</span><br></pre></td></tr></table></figure>
<p>与上面相同，在进入 $dfs2$ 前开好 $dp[to]$ 所需的空间，即以 $to$ 为起点的链，其长度为 $len$</p>
<p>而对于链上其他点(即点 $to$ 的长儿子，其长儿子的长儿子，…)，不会进入当前行，即不需开新空间</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dp[son[cur]] = dp[cur] + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>即继承长儿子的答案: $dp[i][j]=dp[lson][j-1]$</p>
<p>数组指针形式：$dp[\ i\ ]=dp[\ lson[\ i\ ]\ ]-1$</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dp[cur][j+<span class="number">1</span>] += dp[to][j];</span><br></pre></td></tr></table></figure>
<p>暴力合并轻儿子的值</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/utbnpeqk.png" alt=""></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>根号分治</title>
    <url>/2021/10/06/%E6%A0%B9%E5%8F%B7%E5%88%86%E6%B2%BB/</url>
    <content><![CDATA[<h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>大概就是，对于一类问题，可以用 $O(n^2)$ 预处理并 $O(1)$ 查询，或者用 $O(n)$ 处理每个询问，复杂度都是 $O(n^2)$ 数量级</p>
<p>此时可以通过预处理前 $\sqrt{N}$ 的部分，并对 $\sqrt{N}\sim N$ 的部分暴力以达到 $O(N\sqrt{N})$ 的复杂度</p>
<p>这跟筛法的思路相近</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="P5901-IOI2009-regions"><a href="#P5901-IOI2009-regions" class="headerlink" title="P5901 [IOI2009]regions"></a><a href="https://www.luogu.com.cn/problem/P5901">P5901 [IOI2009]regions</a></h3><blockquote>
<p>有 $n$ 位委员，第 $1$ 个资历最高，委员所属的地区为 $1\sim R$ ，除第一个以外的所有委员都有一个直接导师，任何直接导师的资历高于其指导的委员，给定两个地区 $r_1,r_2$ ，要求回答有多少对委员 $e_1,e_2$ 满足 $e_1\in r_1,e_2\in r_2$ ，且 $e_1$ 是 $e_2$ 的导师</p>
<p><img src="https://pic.imgdb.cn/item/616ff4782ab3f51d91bf3b57.png" alt="数据范围"></p>
</blockquote>
<p>这个题有一个很好的启示：<strong>针对询问地区的大小设计不同的算法</strong></p>
<p>不妨设 $r_1$ 中的点有 $A$ 个 $x_1,x_2,…,x_A$ ，$r_2$ 中的点有 $B$ 个 $y_1,y_2,…,y_B$</p>
<ul>
<li><p>如果 $A$ 不大而 $B$ 很大</p>
<p>那么可以接受扫描 $A$ 而不能扫描 $B$</p>
<p>考虑 $dfs$ 序，$A$ 中每个节点的子树在 $dfs$ 序中都对应一段区间 $[l_A,r_A]$ ，而若 $y$ 是 $x$ 的子节点当且仅当 $l_x\leq l_y \And r_x\geq r_y \Leftrightarrow l_x\leq l_y \And r_x\geq l_y$</p>
<p>那么枚举每个以 $x$ 为根的子树，$dfs$ 序按 $l_i$ 排序，二分</p>
<p>用 $lower_bound$ 容易实现，复杂度 $O(A\log B)$</p>
</li>
<li><p>$A$ 很大而 $B$ 不大</p>
<p>上面启示我们应该设计一个 $O(B\log A)$ 的算法</p>
<p>也就是找到多少区间 $[l_x,r_x]$ 包含 $l_y$</p>
<p>仍可以用 $lower_bound$ 实现</p>
</li>
<li><p>$A$ 很大且 $B$ 很大</p>
<p>此时只能有无法优化的 $O(A+B)$ ，但考虑一个涉及很多点的询问不会出现多次，对于重复出现记忆化即可</p>
<p>具体的，当有 $y$ 满足 $l_y\in[l_x,r_y]$ 时表明前面的 $l_x,r_x$ 已经没用了，那么考虑尺取，对于每一个 $y$ ，找在当前 $x$ 之后的 $x$ 以累加答案</p>
<p><del>嗯，玄学证明</del></p>
</li>
</ul>
<p>而对于不同复杂度的算法选取，论文给出的答案是 $lim=\sqrt{N\log N}$ ，但这里使用动态分析复杂度</p>
<p><del>开 $O(2)$ 才苟过的屑代码</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">26100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">19260817</span>;</span><br><span class="line"><span class="keyword">int</span> tot,head[M],ver[M&lt;&lt;<span class="number">1</span>],Next[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; dfn_left[N],num[N];</span><br><span class="line">vector&lt;PII&gt; range[N];</span><br><span class="line">map&lt;PII,<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="keyword">int</span> Size[M],re_dfn[M],area[M],dfn_cnt;</span><br><span class="line"><span class="keyword">int</span> n,r,q,x,y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123; rei ans=<span class="number">0</span>; <span class="keyword">char</span> ch=<span class="built_in">getchar</span>(); <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span> || ch&gt;<span class="string">&#x27;9&#x27;</span>) ch=<span class="built_in">getchar</span>(); <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123; ans=(ans&lt;&lt;<span class="number">1</span>)+(ans&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>); ch=<span class="built_in">getchar</span>();&#125; <span class="keyword">return</span> ans;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123; ver[++tot]=v,Next[tot]=head[u],head[u]=tot;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">	Size[x]=<span class="number">1</span>; re_dfn[++dfn_cnt]=x; dfn_left[ area[x] ].<span class="built_in">push_back</span>(dfn_cnt);</span><br><span class="line">	<span class="keyword">for</span>(rei i=head[x],y;i;i=Next[i])&#123;</span><br><span class="line">		y=ver[i]; <span class="keyword">if</span>(y==fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(y,x);</span><br><span class="line">		Size[x]+=Size[y];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve1</span><span class="params">()</span></span>&#123;<span class="comment">//O(A\log B)</span></span><br><span class="line">	rei res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>,SS=dfn_left[x].<span class="built_in">size</span>();i&lt;SS;++i)&#123;</span><br><span class="line">		rei l=dfn_left[x][i],r=l+Size[ re_dfn[l] ]<span class="number">-1</span>;</span><br><span class="line">		l=<span class="built_in">lower_bound</span>(dfn_left[y].<span class="built_in">begin</span>(),dfn_left[y].<span class="built_in">end</span>(),l)-dfn_left[y].<span class="built_in">begin</span>();</span><br><span class="line">		r=<span class="built_in">upper_bound</span>(dfn_left[y].<span class="built_in">begin</span>(),dfn_left[y].<span class="built_in">end</span>(),r)-dfn_left[y].<span class="built_in">begin</span>();</span><br><span class="line">		res+=r-l;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[ <span class="built_in">mk</span>(x,y) ]=res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve2</span><span class="params">()</span></span>&#123;<span class="comment">//B\log A</span></span><br><span class="line">	rei res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>,SS=dfn_left[y].<span class="built_in">size</span>();i&lt;SS;++i)&#123;</span><br><span class="line">		rei tmp=<span class="built_in">lower_bound</span>(range[x].<span class="built_in">begin</span>(),range[x].<span class="built_in">end</span>(),<span class="built_in">mk</span>(dfn_left[y][i],INF))-range[x].<span class="built_in">begin</span>()<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">if</span>(tmp&gt;=<span class="number">0</span>) res+=num[x][tmp];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[ <span class="built_in">mk</span>(x,y) ]=res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve3</span><span class="params">()</span></span>&#123;<span class="comment">//O(A+B)</span></span><br><span class="line">	rei cntx=<span class="number">0</span>,cnty=dfn_cnt=<span class="number">0</span>,res=<span class="number">0</span>,added=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(cntx!=range[x].<span class="built_in">size</span>() || cnty!=dfn_left[y].<span class="built_in">size</span>())&#123;<span class="comment">//对每一对xy，将包含以y为根的子树的以x为根的子树的数量叠加</span></span><br><span class="line">		<span class="keyword">if</span>(cntx==range[x].<span class="built_in">size</span>()) ++cnty,res+=added;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(cnty==dfn_left[y].<span class="built_in">size</span>()) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(range[x][cntx].first&lt;=dfn_left[y][cnty]) added+=range[x][cntx++].second;</span><br><span class="line">		<span class="keyword">else</span> ++cnty,res+=added;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[ <span class="built_in">mk</span>(x,y) ]=res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(),r=<span class="built_in">read</span>(),q=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&gt;<span class="number">1</span>)&#123;</span><br><span class="line">			rei fa=<span class="built_in">read</span>();</span><br><span class="line">			<span class="built_in">add</span>(fa,i);</span><br><span class="line">		&#125;</span><br><span class="line">		area[i]=<span class="built_in">read</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=r;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(rei j=<span class="number">0</span>,SS=dfn_left[i].<span class="built_in">size</span>();j&lt;SS;++j)&#123;</span><br><span class="line">			range[i].<span class="built_in">push_back</span>(<span class="built_in">mk</span>(dfn_left[i][j],<span class="number">1</span>));</span><br><span class="line">			range[i].<span class="built_in">push_back</span>(<span class="built_in">mk</span>(dfn_left[i][j]+Size[ re_dfn[ dfn_left[i][j] ] ],<span class="number">-1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">sort</span>(range[i].<span class="built_in">begin</span>(),range[i].<span class="built_in">end</span>());</span><br><span class="line">		<span class="built_in">sort</span>(dfn_left[i].<span class="built_in">begin</span>(),dfn_left[i].<span class="built_in">end</span>());</span><br><span class="line">		rei added=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(rei j=<span class="number">0</span>,SS=range[i].<span class="built_in">size</span>();j&lt;SS;++j) num[i].<span class="built_in">push_back</span>(added+=range[i][j].second);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(q--)&#123;</span><br><span class="line">		x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">if</span>(ans.<span class="built_in">count</span>(<span class="built_in">mk</span>(x,y))) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[ <span class="built_in">mk</span>(x,y) ]);</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			rei O1=dfn_left[x].<span class="built_in">size</span>()*<span class="built_in">log2</span>(dfn_left[y].<span class="built_in">size</span>());</span><br><span class="line">			rei O2=dfn_left[y].<span class="built_in">size</span>()*<span class="built_in">log2</span>(range[x].<span class="built_in">size</span>());</span><br><span class="line">			rei O3=range[x].<span class="built_in">size</span>()+dfn_left[y].<span class="built_in">size</span>();</span><br><span class="line">			rei MIN=<span class="built_in">min</span>(O1,<span class="built_in">min</span>(O2,O3));</span><br><span class="line">			<span class="keyword">if</span>(MIN==O1) <span class="built_in">solve1</span>();</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(MIN==O2) <span class="built_in">solve2</span>();</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">solve3</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CF1039D-You-Are-Given-a-Tree"><a href="#CF1039D-You-Are-Given-a-Tree" class="headerlink" title="CF1039D You Are Given a Tree"></a><a href="https://www.luogu.com.cn/problem/CF1039D">CF1039D You Are Given a Tree</a></h3><blockquote>
<p>$n$ 个节点的数，其中一个简单路径的集合被称为 $k合法$ 当且仅当树的每个节点至多属于其中一条路径且每条路径恰好包含 $k$ 个点 $\qquad$ 对于 $k\in[1,n]$ 求 $k合法$ 路径集合的最多路径数，即，设 $k合法$路径集合为 $S$ ，求 $\max|S|$</p>
</blockquote>
<p>显然能对于每个 $k$ ，在 $O(n)$ 内贪心出最长链</p>
<p>可以发现，随着 $k$ 的增大答案变小，在 $k&gt;\sqrt{n}$ 的情况下，答案取值至多有 $\sqrt{n}$ 种</p>
<p>那么，对于 $k\sqrt{n}$ 的部分，暴力即可</p>
<p>剩下的部分二分求相同的值，至多 $O(\log n)$</p>
<p>可以再考虑分治的优化：设分治点 $T$ ，有 $O(nT+\frac{n^2\log n}{T})$</p>
<p>考虑两项相乘为定值，那么当两者相等，即 $T=\sqrt{n\log n}$ 时，有最优复杂度</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rei register int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],Next[N&lt;&lt;<span class="number">1</span>],ver[N&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line"><span class="keyword">int</span> n,p,fa[N],dfn[N],cnt,ans[N],f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123; ver[++tot]=v; Next[tot]=head[u],head[u]=tot;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fath)</span></span>&#123;</span><br><span class="line">	fa[x]=fath;</span><br><span class="line">	<span class="keyword">for</span>(rei i=head[x],y;i;i=Next[i])&#123;</span><br><span class="line">		y=ver[i]; <span class="keyword">if</span>(y==fath) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(y,x);</span><br><span class="line">	&#125;</span><br><span class="line">	dfn[++cnt]=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	rei res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) f[i]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		rei x=dfn[i],fath=fa[x];</span><br><span class="line">		<span class="keyword">if</span>(fath &amp;&amp; f[x]!=<span class="number">-1</span> &amp;&amp; f[fath]!=<span class="number">-1</span>)&#123;</span><br><span class="line">			f[x]+f[fath]&gt;=k ? (++res,f[fath]=<span class="number">-1</span>) : (f[fath]=<span class="built_in">max</span>(f[fath],f[x]+<span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n); p=<span class="built_in">sqrt</span>(n*<span class="built_in">log2</span>(n));</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>,u,v;i&lt;n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v),<span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	ans[<span class="number">1</span>]=n; <span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;=p;++i) ans[i]=<span class="built_in">solve</span>(i);</span><br><span class="line">	<span class="keyword">for</span>(rei i=p+<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		rei tmp=<span class="built_in">solve</span>(i);</span><br><span class="line">		rei l=i,r=n,pos=i;</span><br><span class="line">		<span class="keyword">while</span>(l&lt;r<span class="number">-1</span>)&#123;</span><br><span class="line">			rei mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			<span class="built_in">solve</span>(mid)==tmp ? (l=mid,pos=<span class="built_in">max</span>(pos,mid)) : r=mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(;i&lt;=pos;++i) ans[i]=tmp;<span class="comment">//类似数论分块</span></span><br><span class="line">		--i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>根号分治</tag>
      </tags>
  </entry>
  <entry>
    <title>SDOI2019-猪国杀</title>
    <url>/2021/10/05/%E7%8C%AA%E5%9B%BD%E6%9D%80/</url>
    <content><![CDATA[<p>没什么好说的，就是写完了发个代码</p>
<p>获得修正：心情+10 ( -1每天 )</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rei register int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">15</span>,M=<span class="number">2100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_HP=<span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">char</span> ide_MP[N];<span class="comment">//在主猪眼中的身份</span></span><br><span class="line"><span class="keyword">char</span> card_heap[M];<span class="comment">//谔谔，这个堆第1个是最底下一张，也就是说存的时候是反着存的</span></span><br><span class="line"><span class="keyword">int</span> n,m,num_FP;</span><br><span class="line"><span class="keyword">bool</span> ended,used_kill;</span><br><span class="line"><span class="comment">//这个地方，将used_kill作为局部变量时，用int &amp;修改报错惹</span></span><br><span class="line"><span class="comment">//又用了函数返回值维护但还是错了</span></span><br><span class="line"><span class="comment">//但放到外面就对了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> tmp[<span class="number">10</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pig</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Next,Last,HP;</span><br><span class="line">    <span class="comment">// bool isMP,isZP,isFP;//谔谔这样存猪的身份的话需要同时维护这三个和ide_MP中的身份</span></span><br><span class="line">    <span class="keyword">char</span> ide;</span><br><span class="line">    <span class="keyword">bool</span> crossbow;</span><br><span class="line">    <span class="keyword">int</span> cardnum; <span class="keyword">char</span> card[M];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear_card</span><span class="params">()</span></span>&#123; cardnum=<span class="number">0</span>; crossbow=<span class="literal">false</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_card</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;<span class="comment">//摸牌数量</span></span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=num;++i) card[++cardnum]=card_heap[ m==<span class="number">0</span> ? m=<span class="number">1</span> : m ],--m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;pig[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SETTLE&#123;<span class="comment">//settlement</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;<span class="comment">//结算</span></span><br><span class="line">        <span class="built_in">puts</span>(pig[<span class="number">1</span>].HP ? <span class="string">&quot;MP&quot;</span> : <span class="string">&quot;FP&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!pig[i].HP)&#123; <span class="built_in">puts</span>(<span class="string">&quot;DEAD&quot;</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=pig[i].cardnum;++j) <span class="keyword">if</span>(pig[i].card[j]!=<span class="string">&#x27;U&#x27;</span>) <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,pig[i].card[j]);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> COND&#123;<span class="comment">//condition</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">enable_to_kill</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(used_kill &amp;&amp; !pig[a].crossbow) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(pig[a].ide==<span class="string">&#x27;M&#x27;</span> &amp;&amp; ide_MP[b]!=<span class="string">&#x27;L&#x27;</span> &amp;&amp; ide_MP[b]!=<span class="string">&#x27;F&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(pig[a].ide==<span class="string">&#x27;Z&#x27;</span> &amp;&amp; ide_MP[b]!=<span class="string">&#x27;F&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(pig[a].ide==<span class="string">&#x27;F&#x27;</span> &amp;&amp; ide_MP[b]!=<span class="string">&#x27;M&#x27;</span> &amp;&amp; ide_MP[b]!=<span class="string">&#x27;Z&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">if_killed</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="comment">//a killed b?</span></span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=pig[b].cardnum;++i) <span class="keyword">if</span>(pig[b].card[i]==<span class="string">&#x27;P&#x27;</span>) <span class="keyword">return</span> pig[b].card[i]=<span class="string">&#x27;U&#x27;</span>,++pig[b].HP,<span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">        pig[ pig[b].Next ].Last=pig[b].Last; pig[ pig[b].Last ].Next=pig[b].Next;<span class="comment">//更改距离</span></span><br><span class="line">        <span class="keyword">if</span>(pig[b].ide==<span class="string">&#x27;F&#x27;</span>)&#123;</span><br><span class="line">            --num_FP;</span><br><span class="line">            <span class="keyword">if</span>(!num_FP) <span class="keyword">return</span> ended=<span class="number">1</span>,<span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">            pig[a].<span class="built_in">get_card</span>(<span class="number">3</span>);<span class="comment">//先判断是否胜利再摸牌</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pig[b].ide==<span class="string">&#x27;M&#x27;</span>) <span class="keyword">return</span> ended=<span class="number">1</span>,<span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">        <span class="keyword">if</span>(pig[b].ide==<span class="string">&#x27;Z&#x27;</span> &amp;&amp; pig[a].ide==<span class="string">&#x27;M&#x27;</span>) pig[a].<span class="built_in">clear_card</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">duel_with</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> &amp;b)</span></span>&#123;<span class="comment">//a duel with b,get_b</span></span><br><span class="line">        <span class="keyword">if</span>(pig[a].ide==<span class="string">&#x27;F&#x27;</span>) <span class="keyword">return</span> b=<span class="number">1</span>,<span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">        <span class="keyword">for</span>(rei i=pig[a].Next;i!=a;i=pig[i].Next) <span class="keyword">if</span>((pig[a].ide==<span class="string">&#x27;M&#x27;</span> &amp;&amp; (pig[i].ide==<span class="string">&#x27;L&#x27;</span> || pig[i].ide==<span class="string">&#x27;F&#x27;</span>)) || (pig[a].ide==<span class="string">&#x27;Z&#x27;</span> &amp;&amp; pig[i].ide==<span class="string">&#x27;F&#x27;</span>)) <span class="keyword">return</span> b=i,<span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> CARD&#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">unbreakable</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> x2,<span class="keyword">int</span> x3)</span></span>&#123;</span><br><span class="line">        rei i=x1,pd=x3 ? x2 : x1;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x3==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ide_MP[x2]==pig[i].ide || (ide_MP[x2]==<span class="string">&#x27;M&#x27;</span> &amp;&amp; pig[i].ide==<span class="string">&#x27;Z&#x27;</span>) || (ide_MP[x2]==<span class="string">&#x27;Z&#x27;</span> &amp;&amp; pig[i].ide==<span class="string">&#x27;M&#x27;</span>))&#123;</span><br><span class="line">                    <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=pig[i].cardnum;++j) <span class="keyword">if</span>(pig[i].card[j]==<span class="string">&#x27;J&#x27;</span>)&#123;</span><br><span class="line">                        pig[i].card[j]=<span class="string">&#x27;U&#x27;</span>; ide_MP[i]=pig[i].ide;</span><br><span class="line">                        <span class="keyword">return</span> !<span class="built_in">unbreakable</span>(i,x1,<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(((pig[i].ide==<span class="string">&#x27;M&#x27;</span> || pig[i].ide==<span class="string">&#x27;Z&#x27;</span>) &amp;&amp; ide_MP[x1]==<span class="string">&#x27;F&#x27;</span>) || (pig[i].ide==<span class="string">&#x27;F&#x27;</span> &amp;&amp; (ide_MP[x1]==<span class="string">&#x27;M&#x27;</span> || ide_MP[x1]==<span class="string">&#x27;Z&#x27;</span>)))</span><br><span class="line">                    <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=pig[i].cardnum;++j) <span class="keyword">if</span>(pig[i].card[j]==<span class="string">&#x27;J&#x27;</span>)&#123;</span><br><span class="line">                        pig[i].card[j]=<span class="string">&#x27;U&#x27;</span>; ide_MP[i]=pig[i].ide;</span><br><span class="line">                        <span class="keyword">return</span> !<span class="built_in">unbreakable</span>(i,x1,<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i=pig[i].Next;</span><br><span class="line">            <span class="keyword">if</span>(i==x1) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">bas_usecard_P</span><span class="params">(<span class="keyword">int</span> id,<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">if</span>(pig[id].HP&lt;MAX_HP)&#123; ++pig[id].HP; pig[id].card[x]=<span class="string">&#x27;U&#x27;</span>;&#125;&#125;<span class="comment">//used</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">bas_usecard_K</span><span class="params">(<span class="keyword">int</span> id,<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//x为id猪的第x张牌</span></span><br><span class="line">        rei nnext=pig[id].Next;</span><br><span class="line">        <span class="keyword">if</span>(!COND::<span class="built_in">enable_to_kill</span>(id,nnext)) <span class="keyword">return</span> ;</span><br><span class="line">        used_kill=<span class="number">1</span>;</span><br><span class="line">        pig[id].card[x]=<span class="string">&#x27;U&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=pig[nnext].cardnum;++i) <span class="keyword">if</span>(pig[nnext].card[i]==<span class="string">&#x27;D&#x27;</span>) <span class="keyword">return</span> pig[nnext].card[i]=<span class="string">&#x27;U&#x27;</span>,<span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">        --pig[nnext].HP; <span class="keyword">if</span>(!pig[nnext].HP) COND::if_killed(id,nnext);</span><br><span class="line">        ide_MP[id]=pig[id].ide;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">equip_crossbow</span><span class="params">(<span class="keyword">int</span> id,<span class="keyword">int</span> x)</span></span>&#123; pig[id].crossbow=<span class="literal">true</span>; pig[id].card[x]=<span class="string">&#x27;U&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">oper_duel</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="comment">// if(--无懈可击--) return ;</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">unbreakable</span>(a,b,<span class="number">1</span>)) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">1</span> &amp;&amp; pig[b].ide==<span class="string">&#x27;Z&#x27;</span>)&#123;</span><br><span class="line">            --pig[b].HP;</span><br><span class="line">            <span class="keyword">if</span>(!pig[b].HP) COND::if_killed(a,b);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        rei j=<span class="number">1</span>,k=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(pig[b].card[j]!=<span class="string">&#x27;K&#x27;</span> &amp;&amp; j&lt;=pig[b].cardnum) ++j;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;pig[b].cardnum)&#123;</span><br><span class="line">                --pig[b].HP;<span class="keyword">if</span>(!pig[b].HP) COND::if_killed(a,b);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> pig[b].card[j]=<span class="string">&#x27;U&#x27;</span>;</span><br><span class="line">            <span class="keyword">while</span>(pig[a].card[k]!=<span class="string">&#x27;K&#x27;</span> &amp;&amp; k&lt;=pig[a].cardnum) ++k;</span><br><span class="line">            <span class="keyword">if</span>(k&gt;pig[a].cardnum)&#123;</span><br><span class="line">                --pig[a].HP; <span class="keyword">if</span>(!pig[a].HP) COND::if_killed(b,a);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> pig[a].card[k]=<span class="string">&#x27;U&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">spe_usecard_duel</span><span class="params">(<span class="keyword">int</span> id,<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//这里注意，当没有决斗目标时，j不需要归0，所以有返回值</span></span><br><span class="line">        <span class="keyword">if</span>(pig[id].ide==<span class="string">&#x27;F&#x27;</span>)&#123;</span><br><span class="line">            pig[id].card[x]=<span class="string">&#x27;U&#x27;</span>,<span class="built_in">oper_duel</span>(id,<span class="number">1</span>);</span><br><span class="line">            ide_MP[id]=pig[id].ide;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=pig[id].Next;k!=id;k=pig[k].Next)</span><br><span class="line">            <span class="keyword">if</span>((pig[id].ide==<span class="string">&#x27;M&#x27;</span> &amp;&amp; (ide_MP[k]==<span class="string">&#x27;L&#x27;</span> || ide_MP[k]==<span class="string">&#x27;F&#x27;</span>)) || (pig[id].ide==<span class="string">&#x27;Z&#x27;</span> &amp;&amp; ide_MP[k]==<span class="string">&#x27;F&#x27;</span>))&#123;</span><br><span class="line">                pig[id].card[x]=<span class="string">&#x27;U&#x27;</span>,<span class="built_in">oper_duel</span>(id,k);</span><br><span class="line">                ide_MP[id]=pig[id].ide;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spe_usecard_invade</span><span class="params">(<span class="keyword">int</span> id,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        pig[id].card[x]=<span class="string">&#x27;U&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(rei i=pig[id].Next;i!=id;i=pig[i].Next)&#123;</span><br><span class="line">            <span class="comment">// if(--无懈可击--) continue;</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">unbreakable</span>(id,i,<span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            rei i_now=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(;i_now&lt;=pig[i].cardnum;++i_now) <span class="keyword">if</span>(pig[i].card[i_now]==<span class="string">&#x27;K&#x27;</span>)&#123; pig[i].card[i_now]=<span class="string">&#x27;U&#x27;</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span>(i_now&gt;pig[i].cardnum)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">1</span> &amp;&amp; ide_MP[id]==<span class="string">&#x27;U&#x27;</span>) ide_MP[id]=<span class="string">&#x27;L&#x27;</span>;<span class="comment">//注意这里的误伤</span></span><br><span class="line">                --pig[i].HP; <span class="keyword">if</span>(!pig[i].HP) COND::if_killed(id,i);</span><br><span class="line">                <span class="keyword">if</span>(ended) <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spe_usecard_arrow</span><span class="params">(<span class="keyword">int</span> id,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        pig[id].card[x]=<span class="string">&#x27;U&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(rei i=pig[id].Next;i!=id;i=pig[i].Next)&#123;</span><br><span class="line">            <span class="comment">// if(--无懈可击--) continue;</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">unbreakable</span>(id,i,<span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            rei i_now=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(;i_now&lt;=pig[i].cardnum;++i_now) <span class="keyword">if</span>(pig[i].card[i_now]==<span class="string">&#x27;D&#x27;</span>)&#123; pig[i].card[i_now]=<span class="string">&#x27;U&#x27;</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span>(i_now&gt;pig[i].cardnum)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">1</span> &amp;&amp; ide_MP[id]==<span class="string">&#x27;U&#x27;</span>) ide_MP[id]=<span class="string">&#x27;L&#x27;</span>;<span class="comment">//注意这里的误伤</span></span><br><span class="line">                --pig[i].HP; <span class="keyword">if</span>(!pig[i].HP) COND::if_killed(id,i);</span><br><span class="line">                <span class="keyword">if</span>(ended) <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Begin</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!num_FP) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i;i=pig[i].Next)&#123;</span><br><span class="line">        used_kill=<span class="number">0</span>;</span><br><span class="line">        pig[i].<span class="built_in">get_card</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=pig[i].cardnum;++j)&#123;<span class="comment">//每次出牌都要判断是否已经胜利，而不是在换人的时候判断</span></span><br><span class="line">            <span class="keyword">if</span>(!pig[i].HP) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">char</span> C=pig[i].card[j]; <span class="keyword">if</span>(C==<span class="string">&#x27;U&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(C==<span class="string">&#x27;P&#x27;</span>) CARD::<span class="built_in">bas_usecard_P</span>(i,j);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(C==<span class="string">&#x27;K&#x27;</span>)&#123; CARD::<span class="built_in">bas_usecard_K</span>(i,j); <span class="keyword">if</span>(ended) <span class="keyword">return</span> ;&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(C==<span class="string">&#x27;Z&#x27;</span>) CARD::<span class="built_in">equip_crossbow</span>(i,j),j=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(C==<span class="string">&#x27;F&#x27;</span>)&#123; CARD::<span class="built_in">spe_usecard_duel</span>(i,j) ? j=<span class="number">0</span> : <span class="number">0</span>; <span class="keyword">if</span>(ended) <span class="keyword">return</span> ;&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(C==<span class="string">&#x27;N&#x27;</span>)&#123; CARD::<span class="built_in">spe_usecard_invade</span>(i,j),j=<span class="number">0</span>; <span class="keyword">if</span>(ended) <span class="keyword">return</span> ;&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(C==<span class="string">&#x27;W&#x27;</span>)&#123; CARD::<span class="built_in">spe_usecard_arrow</span>(i,j),j=<span class="number">0</span>; <span class="keyword">if</span>(ended) <span class="keyword">return</span> ;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;1.in&quot;,&quot;r&quot;,stdin); freopen(&quot;1.ans&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) pig[i].Next=i+<span class="number">1</span>,pig[i].Last=i<span class="number">-1</span>;</span><br><span class="line">    pig[n].Next=<span class="number">1</span>,pig[<span class="number">1</span>].Last=n;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;M;++j) pig[i].card[j]=<span class="string">&#x27;U&#x27;</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,tmp); pig[i].ide=tmp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=<span class="number">4</span>;++j) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,tmp),pig[i].card[j]=tmp[<span class="number">0</span>];</span><br><span class="line">        pig[i].HP=pig[i].cardnum=<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">if</span>(pig[i].ide==<span class="string">&#x27;F&#x27;</span>) ++num_FP;</span><br><span class="line">    &#125;</span><br><span class="line">    ide_MP[<span class="number">1</span>]=<span class="string">&#x27;M&#x27;</span>; <span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;=n;++i) ide_MP[i]=<span class="string">&#x27;U&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=m;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,tmp),card_heap[m-i+<span class="number">1</span>]=tmp[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">Begin</span>();</span><br><span class="line">    SETTLE::<span class="built_in">print</span>();</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵树定理</title>
    <url>/2021/07/02/%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<h2 id="前置芝士"><a href="#前置芝士" class="headerlink" title="前置芝士"></a>前置芝士</h2><h3 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h3><p>行列式为标量，对于矩阵 $A$ 来说，其行列式定义为：</p>
<script type="math/tex; mode=display">|A|=\sum_P(-1)^{\delta(P)}\prod_{k=1}^n A_{i,P_k}</script><p>其中 $P$ 取遍 $1\sim n$ 的所有排列，$\delta(P)$ 取 $P$ 的逆序对数</p>
<p>即，对每一个矩阵每行每列只选择一个元素并求他们的乘积，其乘积相加减（取决于逆序对数）</p>
<p>对于 $n$ 阶行列式，有 $n!$ 项</p>
<ul>
<li><p>eg:</p>
<script type="math/tex; mode=display">\left| \begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix}\right |=ad-bc</script></li>
<li><p>计算</p>
<script type="math/tex; mode=display">|A|=(-1)^S |A'|=(-1)^S \prod\limits_{i=1}^n{a'_{i,i}}</script><p>其中 $A’$ 是 $A$ 的上三角矩阵</p>
</li>
</ul>
<p>高斯消元在 $O(n^3)$ 内求出 $n$ 阶矩阵的行列式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ld <span class="title">determinant</span><span class="params">(ld (*A)[N],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,c=<span class="number">1</span>,j;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=c;j&lt;=n &amp;&amp; <span class="built_in">fabs</span>(A[j][i])&lt;eps;++j);</span><br><span class="line">        <span class="keyword">if</span>(j==n+<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        s-=s;</span><br><span class="line">        <span class="keyword">for</span>(rei k=<span class="number">1</span>;k&lt;=n;++k) <span class="built_in">swap</span>(A[c][k],A[j][k]);</span><br><span class="line">        <span class="keyword">for</span>(j=c+<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(A[j][i])&gt;eps)&#123;</span><br><span class="line">                ld t=A[j][i]/A[c][i];</span><br><span class="line">                <span class="keyword">for</span>(rei k=i;k&lt;=n;++k) A[j][k]-=A[c][k]*t;</span><br><span class="line">            &#125;</span><br><span class="line">        ++c;</span><br><span class="line">    &#125;</span><br><span class="line">    ld ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) ans*=A[i][i];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="k-阶主子式"><a href="#k-阶主子式" class="headerlink" title="$k$ 阶主子式"></a>$k$ 阶主子式</h3><p>在 $n$ 阶行列式中，选取行数和列数都为 $i$ 个的行列式即为 $n$ 阶行列式的 $i$ 阶主子式</p>
<h3 id="关联矩阵与邻接矩阵与基尔霍夫矩阵"><a href="#关联矩阵与邻接矩阵与基尔霍夫矩阵" class="headerlink" title="关联矩阵与邻接矩阵与基尔霍夫矩阵"></a>关联矩阵与邻接矩阵与基尔霍夫矩阵</h3><p>对于无向图 $G=(V,E) V=\{v_1,v_2,…,v_n\},E=\{e_1,e_2,…,e_m\}$</p>
<h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>设 $edgenum_{i,j}$ 表示顶点 $v_i,v_j$ 之间的边数，邻接矩阵即为：$A(G)=(edgenum_{i,j})_{n\times n}$ 的矩阵</p>
<ul>
<li>$A(G)$ 为对称矩阵</li>
<li>若 $G$ 为无环图，那么 $A(G)$ 中第 $i$ 行/列的元素之和等于 $deg_{v_i}$</li>
<li>图 $G,H$ 同构的充要条件是存在置换矩阵 $P$ 使 $A(G)=P^TA(H)P$ <del>但这条并没有什么用</del></li>
<li>$eg：$<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/6quf8jfy.png" alt="https://cdn.luogu.com.cn/upload/image_hosting/6quf8jfy.png"> 该无向图的邻接矩阵为 $\begin{bmatrix}0 &amp; 1 &amp; 1 &amp; 1 \\ 1 &amp; 0 &amp; 1 &amp; 0 \\ 1 &amp; 1 &amp; 0 &amp; 1 \\ 1 &amp; 0 &amp; 1 &amp; 0\end{bmatrix}$</li>
</ul>
<h4 id="关联矩阵"><a href="#关联矩阵" class="headerlink" title="关联矩阵"></a>关联矩阵</h4><ul>
<li><p>设 $m_{i,j}$ 表示顶点 $v_i$ 与边 $e_j$ 关联的次数，$M(G)=(m_{ij})_{n\times m}$ 为图 $G$ 的关联矩阵</p>
</li>
<li><p>类似的，对于有向图，关联矩阵的 $m_{i,j}$ 定义为</p>
</li>
</ul>
<script type="math/tex; mode=display">m_{i,j}=
\begin{cases}
1 &\text{$v_i$ 是有向边 $a_j$ 的始点} \\
-1 &\text{$v_i$ 是有向边 $a_j$ 的终点} \\
0 &\text{$v_i$ 与 $a_j$ 无关联} \\
\end{cases}</script><h4 id="基尔霍夫矩阵"><a href="#基尔霍夫矩阵" class="headerlink" title="基尔霍夫矩阵"></a>基尔霍夫矩阵</h4><ul>
<li><p>定义基尔霍夫矩阵满足:</p>
<script type="math/tex; mode=display">v_{i,j}=
\begin{cases}
    -edgenum_{i,j} &i\not ={} j \\
    deg_{v_i} &i=j \\
\end{cases}</script><p>其中 $e_{u,v}$ 表示若 $u,v$ 相连，则 $e(u,v)=1$</p>
</li>
</ul>
<hr>
<h2 id="矩阵树定理及其扩展"><a href="#矩阵树定理及其扩展" class="headerlink" title="矩阵树定理及其扩展"></a>矩阵树定理及其扩展</h2><h3 id="矩阵树定理"><a href="#矩阵树定理" class="headerlink" title="矩阵树定理"></a>矩阵树定理</h3><p><strong>一个无重边，自环的图 $G$ 的生成树个数，等于其基尔霍夫矩阵任意一个 $n-1$ 阶主子式的行列式的绝对值</strong></p>
<h3 id="变元矩阵树定理"><a href="#变元矩阵树定理" class="headerlink" title="变元矩阵树定理"></a>变元矩阵树定理</h3><p>对于生成树 $T$ 定义求其边权之积的函数：</p>
<script type="math/tex; mode=display">F(T)=\prod_{e\in T} w(e)</script><p>那么有：</p>
<script type="math/tex; mode=display">H(G)=\sum_{T\ is\ a\ spanning\ tree\ of\ G} F(T)=(带边权的)基尔霍夫矩阵的任意一个 n-1 列主子式的行列式的绝对值</script><h3 id="有向图的矩阵树定理"><a href="#有向图的矩阵树定理" class="headerlink" title="有向图的矩阵树定理"></a>有向图的矩阵树定理</h3><ul>
<li><p>对于外向树：</p>
<script type="math/tex; mode=display">v_{i,j}=
\begin{cases}
    -e(i,j) &i\not ={} j \\
    \sum_{k=1}^n e(i,k) &i=j \\
\end{cases}</script><script type="math/tex; mode=display">L=D^I-A</script></li>
<li><p>对于内向树</p>
<script type="math/tex; mode=display">v_{i,j}=
\begin{cases}
    -e(i,j) &i\not ={} j \\
    \sum_{k=1}^n e(k,i) &i=j \\
\end{cases}</script><script type="math/tex; mode=display">L=D^O-A</script></li>
</ul>
<p>其中，以 $i$ 为起点/终点的树形图数量为 去掉第 $i$ 列和第 $i$ 行形成的 $n-1$ 阶主子式的行列式的值</p>
<p>$D^I,D^O$ 分别为入度,出度矩阵，$A$ 是邻接矩阵</p>
<h3 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h3><p>求 $n$ 个点组成的无根带标号树的个数，即，求无向完全图生成树计数</p>
<p>其基尔霍夫矩阵主对角线都是 $n-1$ ，其余均为 $-1$</p>
<p>让第一行加上其余行，第一行均为 $1$ ，第一行加上其余行，每行在主对角线上的为 $n$ ，其余为 $0$，最后变为一个上三角矩阵，行列式为主对角线元素相乘</p>
<p>$\therefore$ 是 $n^{n-2}$</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="P3317-SDOI2014-重建"><a href="#P3317-SDOI2014-重建" class="headerlink" title="P3317 [SDOI2014]重建"></a><a href="https://www.luogu.com.cn/problem/P3317">P3317 [SDOI2014]重建</a></h3><blockquote>
<p>给定一张无向完全图以及每条边没有被损毁的概率，求最后剩下的边正好组成原图的一颗生成树的概率</p>
</blockquote>
<p>由题意易得，答案为：</p>
<script type="math/tex; mode=display">\sum_{T\ is\ a\ spanning\ tree\ of\ G} \quad \prod_{u\in T}E(u) \prod_{v\notin T} (1-E(v))</script><p>尝试往变元矩阵树定理的形式上面靠，有：</p>
<script type="math/tex; mode=display">\prod_{v\notin T}\left(1-E(v)\right)=\prod_{u\in G} \left(1-E(u)\right) \prod_{w\in T} \frac{1}{1-E(w))}</script><script type="math/tex; mode=display">原式=\prod_{u\in G}\left(1-E(u)\right) \times \sum_{T}\prod_{v\in T}\frac{E(v)}{1-E(v)}</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=n;++j)&#123; <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;G[i][j]); <span class="keyword">if</span>(G[i][j]==<span class="number">1</span>) G[i][j]-=eps;&#125;</span><br><span class="line"><span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;i;++j) res*=<span class="number">1</span>-G[i][j];</span><br><span class="line"><span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=n;++j) <span class="keyword">if</span>(i!=j) G[i][j]/=(<span class="number">1</span>-G[i][j]),G[i][i]+=G[i][j],G[i][j]=-G[i][j];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.10lf\n&quot;</span>,res*<span class="built_in">determinant</span>(G,n<span class="number">-1</span>));</span><br></pre></td></tr></table></figure>
<h3 id="P4208-JSOI2008-最小生成树计数"><a href="#P4208-JSOI2008-最小生成树计数" class="headerlink" title="P4208 [JSOI2008]最小生成树计数"></a><a href="https://www.luogu.com.cn/problem/P4208">P4208 [JSOI2008]最小生成树计数</a></h3><blockquote>
<p>给出一个简单无向加权图，求这个图中有多少不同的最小生成树</p>
</blockquote>
<p>结论题：<strong>所有最小生成树中，边权相等的边数量相同，且删去这些边后，图连通性不变</strong></p>
<p>给出<del>草率的</del>证明：</p>
<p>从 $\text{Kruskal}$ 的过程开始，吧加入相同权值的边看作一个阶段，每次加边加至图中会形成环为止，然后进行下一阶段。把之前已经被较小边权的边连通的连通块看作一个点，那么就是在这些点间随便连边。如果会形成环，可以选择不加入该边或者删去一条边并加入该边，对连通性和生成树中该种边权的边的条数没有影响</p>
<p>求最小生成树的个数，仍然把相同权值的比看成阶段，那么就是求每个阶段连边方案数的积，那么先求一次最小生成树，再跑一次 $\text{Kruskal}$ ，对于每个阶段，将原先最小生成树中除该阶段的边的其他边连进图中，并查集将图缩点，在缩点后的图中加入该阶段所有边，其实新图的生成树方案中每一种都对应原图中该阶段的一种加边方案，矩阵树定理求生成树即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e3</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">31011</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">bool</span> used[N];</span><br><span class="line"><span class="keyword">int</span> fa[N],n,m;</span><br><span class="line"><span class="keyword">int</span> u[N],v[N],w[N],r[N],tot;</span><br><span class="line">ld K[N][N];</span><br><span class="line"><span class="keyword">int</span> ind[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123; <span class="keyword">return</span> u==fa[u] ? u : fa[u]=<span class="built_in">find</span>(fa[u]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> _u,<span class="keyword">int</span> _v,<span class="keyword">int</span> _w)</span></span>&#123; u[++tot]=_u,v[tot]=_v,w[tot]=_w;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a,<span class="keyword">const</span> <span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">return</span> w[a]&lt;w[b];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ld <span class="title">determinant</span><span class="params">(ld (*A)[N],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,c=<span class="number">1</span>,j;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=c;j&lt;=n &amp;&amp; <span class="built_in">fabs</span>(A[j][i])&lt;eps;++j);</span><br><span class="line">        <span class="keyword">if</span>(j==n+<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        s-=s;</span><br><span class="line">        <span class="keyword">for</span>(rei k=<span class="number">1</span>;k&lt;=n;++k) <span class="built_in">swap</span>(A[c][k],A[j][k]);</span><br><span class="line">        <span class="keyword">for</span>(j=c+<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(A[j][i])&gt;eps)&#123;</span><br><span class="line">                ld t=A[j][i]/A[c][i];</span><br><span class="line">                <span class="keyword">for</span>(rei k=i;k&lt;=n;++k) A[j][k]-=A[c][k]*t;</span><br><span class="line">            &#125;</span><br><span class="line">        ++c;</span><br><span class="line">    &#125;</span><br><span class="line">    ld ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) ans*=A[i][i];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MST&#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add_edge</span><span class="params">(<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x=ind[<span class="built_in">find</span>(u[idx])],y=ind[<span class="built_in">find</span>(v[idx])];</span><br><span class="line">        ++K[x][x],++K[y][y];</span><br><span class="line">        --K[x][y],--K[y][x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) fa[i]=i;</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=m;++i) r[i]=i;</span><br><span class="line">        <span class="built_in">sort</span>(r+<span class="number">1</span>,r+m+<span class="number">1</span>,cmp);</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">            rei x=r[i];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(u[x])!=<span class="built_in">find</span>(v[x]))&#123;</span><br><span class="line">                fa[ <span class="built_in">find</span>(u[x]) ]=<span class="built_in">find</span>(v[x]);</span><br><span class="line">                used[x]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> idx)</span></span>&#123; <span class="keyword">if</span>(<span class="built_in">find</span>(u[idx])!=<span class="built_in">find</span>(v[idx])) fa[ <span class="built_in">find</span>(u[idx]) ]=<span class="built_in">find</span>(v[idx]);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Build_Graph</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">        rei tot=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=n;++j) K[i][j]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) fa[i]=i;</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=m;++i) <span class="keyword">if</span>(used[ r[i] ] &amp;&amp; (i&lt;L || i&gt;R)) <span class="built_in">merge</span>(r[i]);</span><br><span class="line">        <span class="built_in">memset</span>(ind,<span class="number">0</span>,<span class="keyword">sizeof</span> ind);</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>(!ind[ <span class="built_in">find</span>(i) ]) ind[ <span class="built_in">find</span>(i) ]=++tot;</span><br><span class="line">        <span class="keyword">for</span>(rei i=L;i&lt;=R;++i) <span class="built_in">Add_edge</span>(r[i]);</span><br><span class="line">        <span class="keyword">return</span> tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Kruskal_cal</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        rei ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(rei L=<span class="number">1</span>,R=<span class="number">1</span>;R&lt;=m;L=R)&#123;</span><br><span class="line">            <span class="keyword">bool</span> ok=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span>(w[ r[L] ]==w[ r[R] ] &amp;&amp; R&lt;=m) <span class="keyword">if</span>(used[ r[R++] ]) ok=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(!ok) <span class="keyword">continue</span>;</span><br><span class="line">            rei tot=<span class="built_in">Build_Graph</span>(n,m,L,R<span class="number">-1</span>);</span><br><span class="line">            ans=(ll) ans*(<span class="keyword">int</span>) <span class="built_in">round</span>(<span class="built_in">determinant</span>(K,tot<span class="number">-1</span>))%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,uu,vv,ww;i&lt;=m;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;uu,&amp;vv,&amp;ww),<span class="built_in">add</span>(uu,vv,ww);</span><br><span class="line">    MST::<span class="built_in">Kruskal</span>(n,m);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,MST::<span class="built_in">Kruskal_cal</span>(n,m));</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="best-定理"><a href="#best-定理" class="headerlink" title="best 定理"></a>best 定理</h2><h3 id="定理及证明"><a href="#定理及证明" class="headerlink" title="定理及证明"></a>定理及证明</h3><p>对于一个有向欧拉图，设点 $i$ 的出度为 $out_i$ ，那么其从点 $s$ 出发的欧拉回路个数为：</p>
<script type="math/tex; mode=display">T_s (G)\times (out_s!)\times \prod_{u\in V,u\not =s}(out_u-1)!</script><p>其中 $T_u (G)$ 为图 $G$ 以 $u$ 为根的内向生成树个数</p>
<p>式子的含义为：</p>
<p>除去点 $s$ ，每个点指定一条出边作为树边，$s$ 的所有出边任意指定一个顺序，除了 $s$ 的点，把其非树边出边任意指定顺序</p>
<p>如此得到的一个指定顺序的内向树与所有从 $s$ 出发的欧拉路径一一对应</p>
<p>整个有向图 $G$ 的欧拉回路数量为，随意指定一点 $s$ ：</p>
<script type="math/tex; mode=display">T_s(G) \prod_{i\in V} (out_i-1)!</script><p>谔谔，证明都被猫吃掉了 $\rightarrow$ (o=^•ェ•)o</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>矩阵树定理</tag>
      </tags>
  </entry>
  <entry>
    <title>确实不会的多项式</title>
    <url>/2021/05/05/%E7%A1%AE%E5%AE%9E%E4%B8%8D%E4%BC%9A%E7%9A%84%E5%A4%9A%E9%A1%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="写总结的地方"><a href="#写总结的地方" class="headerlink" title="写总结的地方"></a>写总结的地方</h2><ul>
<li>将式子转化为卷积形式: $\displaystyle{\sum_{i=1}^n A_i B_{n-i}}$</li>
</ul>
<h3 id="P3338-ZJOI2014-力"><a href="#P3338-ZJOI2014-力" class="headerlink" title="P3338 [ZJOI2014]力"></a><a href="https://www.luogu.com.cn/problem/P3338">P3338 [ZJOI2014]力</a></h3><ul>
<li><p>题意：<br>求 $E_j=\displaystyle{\sum_{i=1}^{j-1}\frac{q_j}{\left(i-j\right)^2} - \sum_{i=j+1}^n \frac{q_j}{\left(i-j\right)^2}}$</p>
<p>$q_i被消掉了qwq$</p>
</li>
<li><p>解：</p>
<ul>
<li><p>先简化数据范围</p>
<script type="math/tex; mode=display">\sum_{i=1}^{j-1} \Rightarrow \sum_{i=0}^{j}</script></li>
<li><p>化成能算的样子</p>
<p>设 $f[i]=q_j \ , f’[i]=f[n-i] \ , \ g[i]=\frac{1}{i^2}$</p>
<script type="math/tex; mode=display">\begin{aligned}
原式
&=\underbrace{\sum_{i=1}^j f[i] \cdot g[j-i]}_{\rm 已经是卷积形式} - \sum_{i=j}^n f[i] \cdot g[i-j] \\
&=\sum_{i=1}^j f[i] \cdot g[j-i] - \underbrace{\sum_{i=0}^{n-j} f[i+j] \cdot g[i]}_{\rm 然而还不能算} \\
&设 t=n-j \\
&=\sum_{i=1}^j f[i] \cdot g[j-i] - \sum_{i=0}^t f'[t-i] \cdot g[i] \\
\end{aligned}</script></li>
</ul>
<p>$\bf{Trick:}$ <strong>翻转数列</strong> </p>
<p>&amp;&amp; 把函数设成数组以看起来更好算</p>
</li>
</ul>
<h3 id="P3723-AH2017-HNOI2017-礼物"><a href="#P3723-AH2017-HNOI2017-礼物" class="headerlink" title="P3723 [AH2017/HNOI2017]礼物"></a><a href="https://www.luogu.com.cn/problem/P3723">P3723 [AH2017/HNOI2017]礼物</a></h3><ul>
<li><p>题意：</p>
<p>给定两个序列 $a,b$ ，顺序可以移动，求 $\displaystyle{\sum_{i=1}^n \left(a_i-b_i+c \right)^2}$ 最小值</p>
</li>
<li><p>解：</p>
<script type="math/tex; mode=display">原式=\underbrace{\sum_{i=1}^n a_i^2+\sum_{i=1}^n b_i^2}_{\rm [一]可以预处理} - \underbrace{\sum_{i=1}^n a_ib_i}_{\rm [二]见下面} + \underbrace{nc^2 + 2c\left(\sum_{i=1}^na_i - \sum_{i=1}^nb_i \right)}_{\rm [三]关于 c 的二次函数}</script><p>由题：要取 $\displaystyle{\sum_{i=1}^n a_ib_i}$ 的最大值</p>
<p>考虑移动 $k$ 位时：</p>
<p>先把环 $b$ 变为链 $\Rightarrow$ $b[i+n]=b[i]$</p>
<p>转化为考虑 $\displaystyle{\sum_{i=1}^n a_ib_{i+k} }$</p>
<p>翻转 $a$ 得 $\displaystyle{\sum_{i=1}^n b_{i+k} \cdot a_{n-i+1}}$ ， 符合卷积形式</p>
<p>$\therefore \tt{FFT}\left(a_{reserved}\right),\tt{FFT}(b)$</p>
<p>$\bf{Trick:}$ 由于 $c$ 是整数，用二次函数对称轴来算 [式三],比枚举 $-100\leq c \geq 100$ 更好</p>
<p>算出$\left\lfloor -\frac{a}{b} \right\rfloor$ 和 $\left\lceil -\frac{a}{b} \right\rceil$ ， 取 $\min$</p>
</li>
</ul>
<h3 id="P5488-差分与前缀和"><a href="#P5488-差分与前缀和" class="headerlink" title="P5488 差分与前缀和"></a><a href="https://www.luogu.com.cn/problem/P5488">P5488 差分与前缀和</a></h3><ul>
<li><p>题意：</p>
<p>求数列 $a$ 的 $k$ 维前缀和或差分</p>
</li>
<li><p>解：</p>
<p>设 $\displaystyle{F(x)=\sum_{i=0}^\infty a_ix^i }$</p>
<ul>
<li><p>前缀和</p>
<p>比较前缀和与卷积</p>
<p>$\displaystyle{a_i=\sum_{j=1}^i a_j \qquad \And\And \qquad S_i=\sum_{j=1}^i A_j B_{i-j}}$</p>
<p>发现需要卷一个系数都为 $1$ 的多项式 $G(x)$</p>
<p>以样例为例：</p>
<script type="math/tex; mode=display">\begin{aligned}
&F(x)*G(x) \\
&=(1+9x+2x^2+6x^3+0x^4+8x^6+7x^7) \cdot (1+x+x^2+x^3+x^4+ \cdots +x^{\infty}) \\
&=1+\underbrace{9x^1 + \underbrace{2x^2 + \underbrace{6x^3 + \underbrace{0x^4 + \underbrace{8x^6 + \underbrace{7x^7}_{\rm 系数+8}}_{\rm 系数+0}}_{\rm 系数+6}}_{\rm 系数+2}}_{\rm 系数+9}}_{\rm 系数+1}
\end{aligned}</script></li>
</ul>
</li>
</ul>
<pre><code>发现 $F(x)\cdot G(x)$ 所得多项式就是 $F$ 的一阶前缀和

$\displaystyle&#123;\therefore 显然有 G(x)=\frac&#123;1&#125;&#123;1-x&#125;&#125;$

$\displaystyle&#123;\therefore k阶前缀和 \Rightarrow
 F(x) \cdot \frac&#123;1&#125;&#123;\left(1-x \right)^k&#125;&#125;$

$\displaystyle&#123;\frac&#123;1&#125;&#123;\left(1-x \right)^k&#125; 的第 n 项系数就是 \dbinom&#123;n+k-1&#125;&#123;k-1&#125; &#125;$

$\displaystyle&#123;\therefore a_i=\sum_&#123;j=1&#125;^&#123;i-1&#125;\dbinom&#123;j+k-1&#125;&#123;k-1&#125; \cdot a_&#123;i-j&#125; &#125;$

设组合数递推式 $g_i=\dbinom&#123;i+k-1&#125;&#123;k-1&#125;$

$$\begin&#123;aligned&#125;
\therefore
g_i
&amp;=\frac&#123;g_&#123;i-1&#125;\times (k+i-1)&#125;&#123;i&#125;\%p &amp;\text&#123;只会在计算中用到这个&#125;\\
&amp;=\left(\frac&#123;g_&#123;i-1&#125; &#125;&#123;i&#125;\%p \right)\times ((k+i-1)\%p) \\
&amp;=\left(\frac&#123;g_&#123;i-1&#125; &#125;&#123;i&#125;\%p \right)\times ((k\%p+i-1)\%p) \\ &amp;\text&#123;只是为了推 $k$ 可以取模&#125; \\
\end&#123;aligned&#125;$$
</code></pre><p>  $\therefore$ 可以对 $k$ 取模</p>
<ul>
<li><p>差分</p>
<p>易得 $F(x) \times (1-x)$ 所得的多项式就是差分后</p>
<p>  同理得 $\left(1-x\right)^k$</p>
<script type="math/tex; mode=display">\begin{aligned}
  B
  &=F(x) \cdot \left(1-x\right)^k \\
  &=F(x) \cdot \sum_{i=0}^{\infty} \dbinom{k}{i} \left(-x \right)^i \\
&=F(x) \cdot \sum_{i=0}^{\infty} \left(-1 \right)^i \cdot \dbinom{k}{i} x^i \\
  \end{aligned}</script><p>  看组合数递推式: $\dbinom{k}{i}$</p>
<script type="math/tex; mode=display">\dbinom{k}{0}=1</script><script type="math/tex; mode=display">\dbinom{k}{1}=\frac{k!}{(k-1)!}=k</script><script type="math/tex; mode=display">\dbinom{k}{2}=\frac{k!}{2!(k-2)!}=\frac{k(k-1)}{2}</script><script type="math/tex; mode=display">\dbinom{k}{3}=\frac{k!}{3!(k-3)!}=\frac{k(k-1)(k-2)}{2\times 3}</script><script type="math/tex; mode=display">\dbinom{k}{i}=\dbinom{k}{i-1} \cdot \frac{k-i+1}{i} \qquad\text{用这个递推}</script></li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>笛卡尔树笔记</title>
    <url>/2021/09/23/%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91/</url>
    <content><![CDATA[<h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p>对于相匹配的两种键值作为点对 $(x_i,y_i)$ 放到二叉树上，满足：</p>
<ul>
<li>对于 $x_i$ ：满足 $\text{BST}$ 性质，即中序遍历有序</li>
<li>对于 $y_i$ ：满足大根/小根二叉堆性质，即父节点的 $y$ 值 $\geq /\leq$ 所有子节点的 $y$ 值</li>
</ul>
<p>保证 $x$ 有序的条件下，单调栈能做到 $O(n)$ 建树：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">    <span class="keyword">while</span>(top &amp;&amp; a[ stk[top] ]&gt;a[i]) son[i][<span class="number">0</span>]=stk[top--];</span><br><span class="line">    <span class="keyword">if</span>(stk[top]) son[ stk[top] ][<span class="number">1</span>]=i;</span><br><span class="line">    stk[++top]=i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.luogu.com.cn/problem/P5854">板子</a></p>
<h2 id="性质-以小根笛卡尔树为例"><a href="#性质-以小根笛卡尔树为例" class="headerlink" title="性质(以小根笛卡尔树为例)"></a>性质(以小根笛卡尔树为例)</h2><ul>
<li>以点 $u$ 为根的子树是一段连续极长区间，$y_u$ 是区间的最小值，区间在保证最小值不变的情况下不能再向两边延伸</li>
<li>区间 $[a,b]$ 的最小值为 $y_{\text{lca}_{a,b}}$</li>
<li>对于互不相同的 $x,y$ ，所得到的笛卡尔树结构唯一</li>
<li>对于有序数列 $x$ 及随机排列 $y$ ，笛卡尔树的期望高度为 <a href="https://noone40404.github.io/2021/09/07/AGC028/">$E(depth_i)=H(i)+H(n-i+1)-1$</a> ，其中调和级数 $H(n)$ 与 $\log n$ 同阶，故期望高度 $\log n$</li>
<li>$\text{treap}$ 是满足性质 $4$ 的特殊笛卡尔树，那么可以通过 $\text{treap}$ 的操作动态维护笛卡尔树</li>
</ul>
<p><strong>笛卡尔树主要解决最大/最小值问题，以及(通过记录时间)关于插入删除的问题</strong></p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="HDU-柱状图最大子矩阵"><a href="#HDU-柱状图最大子矩阵" class="headerlink" title="HDU 柱状图最大子矩阵"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1506">HDU 柱状图最大子矩阵</a></h3><blockquote>
<p>$n$ 个宽度为 $1$ ，高度不同的矩阵，求其最大子矩阵</p>
</blockquote>
<p>不难发现，下标限制区间， $h$ 限制最大值，那么以 $(下标，h)$ 构建笛卡尔树</p>
<p>根据大根笛卡尔树的性质，最长区间就是子树大小，故节点 $u$ 的最大子矩阵就是 $Size_u\times h_u$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> ans,a[N],son[N][<span class="number">2</span>],Size[N];</span><br><span class="line"><span class="keyword">int</span> n,stk[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	Size[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(son[x][<span class="number">0</span>]) <span class="built_in">dfs</span>(son[x][<span class="number">0</span>]),Size[x]+=Size[ son[x][<span class="number">0</span>] ];</span><br><span class="line">	<span class="keyword">if</span>(son[x][<span class="number">1</span>]) <span class="built_in">dfs</span>(son[x][<span class="number">1</span>]),Size[x]+=Size[ son[x][<span class="number">1</span>] ];</span><br><span class="line">	ans=ans&gt;a[x]*Size[x] ? ans : a[x]*Size[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n))&#123;</span><br><span class="line">		<span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]),son[i][<span class="number">0</span>]=son[i][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">		rei top=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">			<span class="keyword">while</span>(top &amp;&amp; a[ stk[top] ]&gt;a[i]) son[i][<span class="number">0</span>]=stk[top--];</span><br><span class="line">			<span class="keyword">if</span>(top) son[ stk[top] ][<span class="number">1</span>]=i;</span><br><span class="line">			stk[++top]=i;</span><br><span class="line">		&#125;</span><br><span class="line">		ans=<span class="number">0</span>; <span class="built_in">dfs</span>(stk[<span class="number">1</span>]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="AGC028-B"><a href="#AGC028-B" class="headerlink" title="AGC028 B"></a><a href="https://atcoder.jp/contests/agc028/tasks/agc028_b">AGC028 B</a></h3><p><a href="https://noone40404.github.io/2021/09/07/AGC028/">戳我</a></p>
<hr>
<h3 id="P1377-TJOI2011-树的序"><a href="#P1377-TJOI2011-树的序" class="headerlink" title="P1377 [TJOI2011]树的序"></a><a href="https://www.luogu.com.cn/problem/P1377">P1377 [TJOI2011]树的序</a></h3><p>另一个板板题</p>
<p>显然满足题干条件的就是笛卡尔树，构建后先序遍历出 $x$ 值即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],son[N][<span class="number">2</span>],stk[N],top;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!u) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,u);</span><br><span class="line">    <span class="built_in">print</span>(son[u][<span class="number">0</span>]),<span class="built_in">print</span>(son[u][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,x;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x),a[x]=i;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">while</span>(top &amp;&amp; a[ stk[top] ]&gt;a[i]) son[i][<span class="number">0</span>]=stk[top--];</span><br><span class="line">		<span class="keyword">if</span>(top) son[ stk[top] ][<span class="number">1</span>]=i;</span><br><span class="line">		stk[++top]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	rei x; <span class="keyword">while</span>(top) x=stk[top--];</span><br><span class="line">	<span class="built_in">print</span>(x);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="SP3734-PERIODNI-Periodni"><a href="#SP3734-PERIODNI-Periodni" class="headerlink" title="SP3734 PERIODNI - Periodni"></a><a href="https://www.luogu.com.cn/problem/SP3734">SP3734 PERIODNI - Periodni</a></h3><blockquote>
<p>给出 $N$ 列表格，表格高度不同，向其中填入 $k$ 个数，要求不能有两个数相邻，其中相邻指能通过一条直线到达且中间路程均有格子，求填法方案数</p>
</blockquote>
<p>由题，两个不同列的数是否相互影响取决于中间有没有一个高度小于两者的矩形将它们隔开，也就是说，关键值受矩形高度最小值影响，那么以 $(数列编号i,h)$ 构建小根笛卡尔树，将不规则图形拆成若干矩形</p>
<p>考虑每个矩形内的答案：树形 $\text{dp}$</p>
<p>对于点 $u$ ，将左右两颗子树对应区间里的棋盘分成两块，$\min \{h\}$ 下面的共有块$B$ ， $\min\{h\}$ 上面的高低不一的块 $A$</p>
<p>对于块 $A$ ，设 $f_{u,x}$ 表示 $u$ 的子树中，切掉 $fa_u$ 的长度后，放 $x$ 个物品的方案数</p>
<p>那么对于当前 $u$ ，对 $son_{u,0} , son_{u,1}$ 的 $f$ 做卷积即可得 $f_u$</p>
<p>对于块 $B$ ，要考虑底层的 $A$ 对其影响，对于点 $u$ ,当前有 $a_u-a_{fa_u}$ 行，$Size_u$ 列</p>
<p>对于 $f_{u,i}$ ，设在块 $B$ 中选择了 $j$ 个，此时 $A$ 中的 $i-j$ 个占据了 $B$ 的列，故 $B$ 的方案数为：$\binom{a_u-a_{fa_u}}{j}\times \binom{Size_u-(i-j)}{j}\times j!$ ，即选 $j$ 行和 $j$ 列并两两配对的方案数</p>
<p>最后把 $AB$ 的结果做卷积即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>,M=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,k,a[N],Size[N],dp[N][N],tmp[N];</span><br><span class="line"><span class="keyword">int</span> fac[M],inv[M],fac_inv[M];</span><br><span class="line"><span class="keyword">int</span> son[N][<span class="number">2</span>],stk[N],top,rt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fac[<span class="number">0</span>]=fac[<span class="number">1</span>]=fac_inv[<span class="number">0</span>]=fac_inv[<span class="number">1</span>]=inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;M;++i)&#123;</span><br><span class="line">		fac[i]=(ll) fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">		inv[i]=(ll) inv[mod%i]*(mod-mod/i)%mod;</span><br><span class="line">		fac_inv[i]=(ll) fac_inv[i<span class="number">-1</span>]*inv[i]%mod;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(m&gt;n || m&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> (ll) fac[n]*fac_inv[m]%mod*fac_inv[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">	stk[++top]=<span class="number">1</span>; rt=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]&lt;a[ stk[<span class="number">1</span>] ])&#123;</span><br><span class="line">			son[i][<span class="number">0</span>]=stk[<span class="number">1</span>]; rt=i;</span><br><span class="line">			<span class="keyword">while</span>(top) stk[top--]=<span class="number">0</span>; stk[++top]=i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">while</span>(top &amp;&amp; a[ stk[top] ]&gt;a[i]) son[i][<span class="number">0</span>]=stk[top--];</span><br><span class="line">			<span class="keyword">if</span>(stk[top]) son[ stk[top] ][<span class="number">1</span>]=i;</span><br><span class="line">			stk[++top]=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa_u)</span></span>&#123;</span><br><span class="line">	Size[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(son[u][<span class="number">0</span>]) <span class="built_in">dfs</span>(son[u][<span class="number">0</span>],a[u]),Size[u]+=Size[ son[u][<span class="number">0</span>] ];</span><br><span class="line">	<span class="keyword">if</span>(son[u][<span class="number">1</span>]) <span class="built_in">dfs</span>(son[u][<span class="number">1</span>],a[u]),Size[u]+=Size[ son[u][<span class="number">1</span>] ];</span><br><span class="line">	<span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="keyword">sizeof</span> tmp);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;=Size[u];++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;=i;++j) tmp[i]=((ll) tmp[i]+dp[ son[u][<span class="number">0</span>] ][j]*dp[ son[u][<span class="number">1</span>] ][i-j]%mod)%mod;<span class="comment">//左右儿子的卷积</span></span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;=Size[u];++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;=i;++j) dp[u][i]=((ll) dp[u][i]+tmp[i-j]*<span class="built_in">get_C</span>(a[u]-fa_u,j)%mod *<span class="built_in">get_C</span>(Size[u]-i+j,j)%mod *fac[j]%mod)%mod;<span class="comment">//AB卷积</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">	<span class="built_in">init</span>(); <span class="built_in">build</span>();</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>; <span class="built_in">dfs</span>(rt,<span class="number">0</span>);</span><br><span class="line">	<span class="comment">// printf(&quot;%d\n&quot;,rt);</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,dp[rt][k]);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="P4755-Beautiful-Pair"><a href="#P4755-Beautiful-Pair" class="headerlink" title="P4755 Beautiful Pair"></a><a href="https://www.luogu.com.cn/problem/P4755">P4755 Beautiful Pair</a></h3><blockquote>
<p>给定数列 $A$ ，当一个数对 $(i,j) \ , \ (i\leq j)$ 满足 $a_i,a_j$ 的积不大于 $\max\{a_i,…a_j\}$ ，认为这个数对是美丽的，求出美丽的数对的数量</p>
</blockquote>
<p>笛卡尔树上做启发式合并就好了qwq</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],dd[N],ra[N];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="keyword">int</span> son[N][<span class="number">2</span>],rt,stk[N],top;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_rk</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">upper_bound</span>(dd+<span class="number">1</span>,dd+<span class="number">1</span>+n,x)-dd<span class="number">-1</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">discrease</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) dd[i]=a[i]; <span class="built_in">sort</span>(dd+<span class="number">1</span>,dd+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) ra[i]=<span class="built_in">get_rk</span>(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) a[i]=-a[i];</span><br><span class="line">    stk[++top]=<span class="number">1</span>,rt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;a[ stk[<span class="number">1</span>] ])&#123;</span><br><span class="line">            rt=i; son[i][<span class="number">0</span>]=stk[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span>(top) stk[top--]=<span class="number">0</span>;</span><br><span class="line">            stk[++top]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(top &amp;&amp; a[ stk[top] ]&gt;a[i]) son[i][<span class="number">0</span>]=stk[top--];</span><br><span class="line">            <span class="keyword">if</span>(stk[top]) son[ stk[top] ][<span class="number">1</span>]=i;</span><br><span class="line">            stk[++top]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) a[i]=-a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BIT&#123;</span><br><span class="line">    <span class="keyword">int</span> t[::N];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x&amp;(-x);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123; <span class="keyword">for</span>(;pos&lt;=n;pos+=<span class="built_in">lowbit</span>(pos)) ++t[pos];&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> ans=<span class="number">0</span>)</span></span>&#123; <span class="keyword">for</span>(;pos;pos^=<span class="built_in">lowbit</span>(pos)) ans+=t[pos]; <span class="keyword">return</span> ans;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!now) <span class="keyword">return</span> ;</span><br><span class="line">    rei cur=<span class="number">0</span>;<span class="comment">//跨点now的答案</span></span><br><span class="line">    <span class="keyword">if</span>(now-l&gt;r-now)&#123;<span class="comment">//右边小</span></span><br><span class="line">        <span class="keyword">for</span>(rei i=now;i&lt;=r;++i)&#123;</span><br><span class="line">            rei lim=<span class="built_in">get_rk</span>(a[now]/a[i]);</span><br><span class="line">            cur-=BIT::<span class="built_in">query</span>(lim);<span class="comment">//去重</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(son[now][<span class="number">0</span>],l,now<span class="number">-1</span>);</span><br><span class="line">        BIT::<span class="built_in">add</span>(ra[now]);</span><br><span class="line">        <span class="keyword">for</span>(rei i=now;i&lt;=r;++i)&#123;</span><br><span class="line">            rei lim=<span class="built_in">get_rk</span>(a[now]/a[i]);</span><br><span class="line">            cur+=BIT::<span class="built_in">query</span>(lim);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(son[now][<span class="number">1</span>],now+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(rei i=l;i&lt;=now;++i)&#123;</span><br><span class="line">            rei lim=<span class="built_in">get_rk</span>(a[now]/a[i]);</span><br><span class="line">            cur-=BIT::<span class="built_in">query</span>(lim);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(son[now][<span class="number">1</span>],now+<span class="number">1</span>,r);</span><br><span class="line">        BIT::<span class="built_in">add</span>(ra[now]);</span><br><span class="line">        <span class="keyword">for</span>(rei i=l;i&lt;=now;++i)&#123;</span><br><span class="line">            rei lim=<span class="built_in">get_rk</span>(a[now]/a[i]);</span><br><span class="line">            cur+=BIT::<span class="built_in">query</span>(lim);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(son[now][<span class="number">0</span>],l,now<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ans+=cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n); <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="built_in">discrease</span>();</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">dfs</span>(rt,<span class="number">1</span>,n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="P2611-ZJOI2012-小蓝的好友"><a href="#P2611-ZJOI2012-小蓝的好友" class="headerlink" title="P2611 [ZJOI2012]小蓝的好友"></a><a href="https://www.luogu.com.cn/problem/P2611">P2611 [ZJOI2012]小蓝的好友</a></h3><blockquote>
<p>一块 $R\times C$ 的地上会生成 $n$ 个资源点，第 $i$ 个位于 $x_i,y_i$ ，计算至少包含一个资源点区域的数量</p>
</blockquote>
<p>$\text{FHQtreap}$ 动态维护笛卡尔树</p>
<p>显然容斥为：总子矩形个数-内部没有资源点的子矩形个数</p>
<p><strong>这类问题的 $\text{trick}$ 是扫描线：枚举子矩形的下边界，从上到下扫描，并考虑维护一些东西</strong></p>
<p>维护序列 $S_{p,i}$ 表示每一列的比 $i$ 小且最靠近 $i$ 的资源点的纵坐标</p>
<p>设 $M_p(a,b)$ 表示 $S_p$ 的区间 $[a,b]$ 中的最大值，每条扫描线的贡献为 $\displaystyle{\sum_{i,j\in[1,c],i\leq j} p-M_p(i,j)=\frac{c(c+1)}{2}p-\sum M[i,j]}$</p>
<p>对 $S_{p,i}$ 计算其贡献，即，对每个横坐标计算其作为最大值的最大区间长度，笛卡尔树即可</p>
<p>以 $(下标v，该列上点行数的最大值w)$ 构建关于 $S_p$ 的大根笛卡尔树，在每个节点统计贡献，即，对于每个 $S_p$ ，其贡献为 $\displaystyle{\frac{c(c+1)}{2}p-\sum_u w_u\times (son_{u,0}+1)\times (son_{u,1}+1)}$ ，其中考虑到自身贡献，故加 $1$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k,tot,root;</span><br><span class="line"><span class="keyword">int</span> son[N][<span class="number">2</span>],val[N],Size[N];</span><br><span class="line">ll ans,key[N],sum[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FHQ&#123;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		Size[x]=Size[ son[x][<span class="number">0</span>] ]+Size[ son[x][<span class="number">1</span>] ]+<span class="number">1</span>;</span><br><span class="line">		sum[x]=sum[ son[x][<span class="number">0</span>] ]+sum[ son[x][<span class="number">1</span>] ]+key[x]*(Size[ son[x][<span class="number">0</span>] ]+<span class="number">1</span>)*(Size[ son[x][<span class="number">1</span>] ]+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">		rei mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		x=++tot; Size[x]=<span class="number">1</span>,val[x]=mid;</span><br><span class="line">		<span class="keyword">if</span>(l&lt;mid) <span class="built_in">build</span>(l,mid<span class="number">-1</span>,son[x][<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">if</span>(r&gt;mid) <span class="built_in">build</span>(mid+<span class="number">1</span>,r,son[x][<span class="number">1</span>]);</span><br><span class="line">		<span class="built_in">pushup</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> &amp;p,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!x || !y) <span class="keyword">return</span> p=x+y,<span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">		key[x]&gt;key[y] ? (p=x,<span class="built_in">merge</span>(son[p][<span class="number">1</span>],son[p][<span class="number">1</span>],y)) : (p=y,<span class="built_in">merge</span>(son[p][<span class="number">0</span>],x,son[p][<span class="number">0</span>]));</span><br><span class="line">		<span class="built_in">pushup</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> k,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!p) <span class="keyword">return</span> x=y=<span class="number">0</span>,<span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">		val[p]&lt;=k ? (x=p,<span class="built_in">split</span>(son[p][<span class="number">1</span>],k,son[p][<span class="number">1</span>],y)) : (y=p,<span class="built_in">split</span>(son[p][<span class="number">0</span>],k,x,son[p][<span class="number">0</span>]));</span><br><span class="line">		<span class="built_in">pushup</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		rei x,y,z; <span class="built_in">split</span>(root,k,x,y),<span class="built_in">split</span>(x,k<span class="number">-1</span>,x,z);</span><br><span class="line">		key[z]=v; <span class="built_in">pushup</span>(z);</span><br><span class="line">		<span class="built_in">merge</span>(x,x,z),<span class="built_in">merge</span>(root,x,y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">	FHQ::<span class="built_in">build</span>(<span class="number">1</span>,m,root);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>,x,y;i&lt;=k;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y),v[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(rei j=<span class="number">0</span>,sz=v[i].<span class="built_in">size</span>();j&lt;sz;++j) FHQ::<span class="built_in">modify</span>(v[i][j],i);</span><br><span class="line">		ans+=(ll) i*m*(m+<span class="number">1</span>)/<span class="number">2</span>-sum[root];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(ll) n*(n+<span class="number">1</span>)/<span class="number">2</span>*m*(m+<span class="number">1</span>)/<span class="number">2</span>-ans);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>启发式合并</tag>
        <tag>笛卡尔树</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流基础</title>
    <url>/2021/10/13/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p><del>速通网络流的代价就是忘的巨快</del></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>网络流中常出现边与点的转化</strong></p>
<p>具体的，拆点以表示点必需的信息，边中插入点以表示边必需的信息</p>
<p><a href="https://www.cnblogs.com/victorique/p/8560656.html#autoid-1-3-3">这里有一些建模，有时间去看看</a></p>
<span id="more"></span>
<h2 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h2><h3 id="理论："><a href="#理论：" class="headerlink" title="理论："></a>理论：</h3><p>$\text{bfs}$ 找 $S$ 到每个点的经过最少边的路径，并对残量网络分层，根据层次反复做 $\text{dfs}$ 每次找到一条增广路并更新</p>
<p>对于每一条从 $x$ 出发并处理完毕的边都不需要重复只用，用 $\text{cur[x]}$ 表示上次处理 $x$ 时遍历的最后一条边($x$ 的当前弧)，每次 $\text{bfs}$ 后都应将 $\text{cur}$ 初始化为 $\text{head}$</p>
<p>尤其在稠密图中效果显著</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Webflow&#123;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> st,<span class="keyword">int</span> ed)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;N;++i) cur[i]=head[i],depth[i]=<span class="number">0</span>;<span class="comment">//emmm 这里注意点数不再是n了</span></span><br><span class="line">		he=<span class="number">1</span>,ta=<span class="number">0</span>; depth[st]=<span class="number">1</span>,que[++ta]=st;</span><br><span class="line">		<span class="keyword">while</span>(he&lt;=ta)&#123;</span><br><span class="line">			rei x=que[he++];</span><br><span class="line">			<span class="keyword">for</span>(rei i=head[x],y;i;i=Next[i])&#123;</span><br><span class="line">				<span class="keyword">if</span>(flow[i] &amp;&amp; !depth[ y=ver[i] ])&#123;</span><br><span class="line">					depth[y]=depth[x]+<span class="number">1</span>; que[++ta]=y;</span><br><span class="line">					<span class="keyword">if</span>(y==ed) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> T,<span class="keyword">int</span> left_flow)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!left_flow || x==T) <span class="keyword">return</span> left_flow;</span><br><span class="line">		rei tmp=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(rei i=cur[x],y,f;i;i=Next[i])&#123;</span><br><span class="line">			cur[x]=i;</span><br><span class="line">			<span class="keyword">if</span>(depth[ y=ver[i] ]==depth[x]+<span class="number">1</span> &amp;&amp; (f=<span class="built_in">dfs</span>(y,T,<span class="built_in">min</span>(left_flow-tmp,flow[i]))))&#123;</span><br><span class="line">				flow[i]-=f; flow[i^<span class="number">1</span>]+=f;</span><br><span class="line">				tmp+=f;</span><br><span class="line">				<span class="keyword">if</span>(!(left_flow-tmp)) <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> S,<span class="keyword">int</span> T)</span></span>&#123; maxflow=<span class="number">0</span>; <span class="keyword">while</span>(<span class="built_in">bfs</span>(S,T)) maxflow+=<span class="built_in">dfs</span>(S,T,INF);&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="P2891-USACO07OPEN-Dining-G-P1231-教辅的组成-P1402-酒店之王"><a href="#P2891-USACO07OPEN-Dining-G-P1231-教辅的组成-P1402-酒店之王" class="headerlink" title="P2891 [USACO07OPEN]Dining G / P1231 教辅的组成 / P1402 酒店之王"></a><a href="https://www.luogu.com.cn/problem/P2891">P2891 [USACO07OPEN]Dining G</a> / <a href="https://www.luogu.com.cn/problem/P1231">P1231 教辅的组成</a> / <a href="https://www.luogu.com.cn/problem/P1402">P1402 酒店之王</a></h4><p>三倍经验的三分图匹配，将两个要匹配 $n1,n2$ 的先分别与源汇点相连，再将用来匹配的一种点 $n$ 拆点以保证只选一次，再读入条件将匹配条件连边</p>
<p>$i:1\rightarrow n1\qquad$ <code>add(S,i,1),add(i,S,0);</code></p>
<p>$i:1\rightarrow n2\qquad$ <code>add(i+n1,T,1),add(T,i+n1,0);</code></p>
<p>$i:1\rightarrow n\ \ \qquad$ <code>add(i+n1+n2,i+n+n1+n2,1),add(i+n+n1+n2,i+n1+n2,0);</code></p>
<p>$u,v\in n1\ \ \qquad$ <code>add(v,u+n1+n2,1),add(u+n1+n2,v,0);</code></p>
<p>$u,v\in n2\ \ \qquad$ <code>add(u+n+n1+n2,v+n1,1),add(v+n1,u+n+n1+n2,0);</code></p>
<h2 id="有-无源汇上下界可行-最大流"><a href="#有-无源汇上下界可行-最大流" class="headerlink" title="有/无源汇上下界可行/最大流"></a>有/无源汇上下界可行/最大流</h2><h3 id="理论-无源汇上下界可行流"><a href="#理论-无源汇上下界可行流" class="headerlink" title="理论- 无源汇上下界可行流"></a>理论- <a href="https://loj.ac/p/115">无源汇上下界可行流</a></h3><p>对于边的上下界 $MAX,MIN$ ，一个简单的想法是整体向下偏移，将下界变为 $0$ ，上界变为 $MAX-MIN$ ，但如此的话并不满足流量守恒</p>
<p>设 $du_i=in_i-out_i$ ，即每个节点的入出之差</p>
<p>当 $du_i=0$ 那么对于该点，流量守恒</p>
<p>当 $du_i&gt;0$ ，从 $S$ 向 $i$ 连一条流量 $du_i$ 的边，当 $du_i&lt;0$ ，从 $i$ 向 $T$ 连一条 $-du_i$ 的边</p>
<p>那么求一次最大流，当所有附加的边均满流时(即，$du_i&lt;=0$) 有可行解</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(rei i=<span class="number">1</span>,u,v,MIN,MAX;i&lt;=m;++i)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;MIN,&amp;MAX);</span><br><span class="line">    <span class="built_in">add</span>(u,v,MAX-MIN,i),<span class="built_in">add</span>(v,u,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    du[u]-=MIN,du[v]+=MIN;</span><br><span class="line">    ori[i]=MIN;</span><br><span class="line">&#125;</span><br><span class="line">S=n+<span class="number">1</span>,T=S+<span class="number">1</span>,ori_tot=tot;</span><br><span class="line"><span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(du[i]&gt;<span class="number">0</span>) <span class="built_in">add</span>(S,i,du[i],<span class="number">0</span>),<span class="built_in">add</span>(i,S,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(du[i]&lt;<span class="number">0</span>) <span class="built_in">add</span>(i,T,-du[i],<span class="number">0</span>),<span class="built_in">add</span>(T,i,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">Webflow::<span class="built_in">Dinic</span>(S,T);</span><br><span class="line"><span class="keyword">bool</span> flag=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(rei i=head[S];i;i=Next[i]) <span class="keyword">if</span>(flow[i]&gt;<span class="number">0</span>)&#123; flag=<span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(!flag) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>),<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;=ori_tot;i+=<span class="number">2</span>) ans[ id[i] ]=flow[i^<span class="number">1</span>];<span class="comment">//id表示第i条边是原来输入的第几条</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=m;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]+ori[i]);</span><br></pre></td></tr></table></figure>
<h3 id="理论-有源汇上下界最大流"><a href="#理论-有源汇上下界最大流" class="headerlink" title="理论- 有源汇上下界最大流"></a>理论- <a href="https://loj.ac/p/116">有源汇上下界最大流</a></h3><p>其实题目的意思是：求一个流使源点总流入等于汇点总流出，其他点满足流量守恒，每条边满足上下界限制，求最大的总流量</p>
<p><del>而不是直接用上界跑最大流，这一定是出题人的语文问题</del></p>
<p>如何转化为无源汇：变成循环流即可，即从源点到汇点建一条流量无限的边</p>
<p>再建超级源点超级汇点，可行流的判断与上题一样</p>
<p>第一次跑的最大流是流满下界的流，图中还剩有 $s\rightarrow t$ 的自由流</p>
<p>那么再删去超级源点汇点以及与之相连的边，再跑 $s\rightarrow t$ 的最大流</p>
<p>答案就是 $流满下界的流+剩下的自由流的最大流$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(rei i=<span class="number">1</span>,u,v,MIN,MAX;i&lt;=m;++i)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;MIN,&amp;MAX);</span><br><span class="line">    <span class="built_in">add</span>(u,v,MAX-MIN,i),<span class="built_in">add</span>(v,u,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    du[u]-=MIN,du[v]+=MIN;</span><br><span class="line">&#125;</span><br><span class="line">S=n+<span class="number">1</span>,T=S+<span class="number">1</span>,ori_tot=tot;</span><br><span class="line"><span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(du[i]&gt;<span class="number">0</span>) <span class="built_in">add</span>(S,i,du[i],<span class="number">0</span>),<span class="built_in">add</span>(i,S,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(du[i]&lt;<span class="number">0</span>) <span class="built_in">add</span>(i,T,-du[i],<span class="number">0</span>),<span class="built_in">add</span>(T,i,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">add</span>(t,s,INF,<span class="number">0</span>),<span class="built_in">add</span>(s,t,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">Webflow::<span class="built_in">Dinic</span>(S,T);</span><br><span class="line"><span class="keyword">bool</span> flag=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(rei i=head[S];i;i=Next[i]) <span class="keyword">if</span>(flow[i]&gt;<span class="number">0</span>)&#123; flag=<span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(!flag) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;please go home to sleep&quot;</span>),<span class="number">0</span>;</span><br><span class="line">ans=flow[ head[t]^<span class="number">1</span> ]; <span class="comment">//跑完最大流后每条边的反向边的流量就为流过该边的流量。求流过t的流量</span></span><br><span class="line"><span class="comment">// printf(&quot;%d\n&quot;,ans);</span></span><br><span class="line"><span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=tot;++i) <span class="keyword">if</span>(!id[i]) flow[i]=<span class="number">0</span>;<span class="comment">//id等于0的边都是与st和ed相连的</span></span><br><span class="line">head[S]=head[T]=<span class="number">0</span>;</span><br><span class="line"><span class="comment">// S=s,T=t;</span></span><br><span class="line">Webflow::<span class="built_in">Dinic</span>(s,t);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans+maxflow);</span><br></pre></td></tr></table></figure>
<h3 id="理论-有源汇上下界最小流"><a href="#理论-有源汇上下界最小流" class="headerlink" title="理论- 有源汇上下界最小流"></a>理论- <a href="https://loj.ac/p/117">有源汇上下界最小流</a></h3><p>建立超级源点汇点之后跑一次最大流，$t\rightarrow s$ 建一条无限大的边，再跑一次最大流</p>
<p>答案就是无限大的边流过的流量：</p>
<p>由于整个图满足流量平衡，$t$ 的流入等于流出，由于其流出的只有无穷大的边，最小六就是使那条边流过的流量尽量小</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll MIN,MAX;</span><br><span class="line"><span class="keyword">for</span>(rei i=<span class="number">1</span>,u,v;i&lt;=m;++i)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld%lld&quot;</span>,&amp;u,&amp;v,&amp;MIN,&amp;MAX);</span><br><span class="line">    <span class="built_in">add</span>(u,v,MAX-MIN),<span class="built_in">add</span>(v,u,<span class="number">0</span>);</span><br><span class="line">    du[u]-=MIN,du[v]+=MIN;</span><br><span class="line">&#125;</span><br><span class="line">S=n+<span class="number">1</span>,T=S+<span class="number">1</span>,ori_tot=tot;</span><br><span class="line"><span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(du[i]&gt;<span class="number">0</span>) <span class="built_in">add</span>(S,i,du[i]),<span class="built_in">add</span>(i,S,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(du[i]&lt;<span class="number">0</span>) <span class="built_in">add</span>(i,T,-du[i]),<span class="built_in">add</span>(T,i,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">Webflow::<span class="built_in">Dinic</span>(S,T);</span><br><span class="line"><span class="built_in">add</span>(t,s,INF),<span class="built_in">add</span>(s,t,<span class="number">0</span>);</span><br><span class="line">Webflow::<span class="built_in">Dinic</span>(S,T);</span><br><span class="line"><span class="keyword">bool</span> flag=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(rei i=head[S];i;i=Next[i]) <span class="keyword">if</span>(flow[i]&gt;<span class="number">0</span>)&#123; flag=<span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(!flag) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;please go home to sleep&quot;</span>),<span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,flow[tot]);</span><br></pre></td></tr></table></figure>
<h2 id="最小割"><a href="#最小割" class="headerlink" title="最小割"></a>最小割</h2><h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><ul>
<li><p>最大流最小割定理：</p>
<p><strong>网络中最大流量等于最小割中割边的容量之和</strong></p>
<p>证略</p>
</li>
</ul>
<h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><h4 id="P4662-BalticOI-2008-黑手党"><a href="#P4662-BalticOI-2008-黑手党" class="headerlink" title="P4662 [BalticOI 2008]黑手党"></a><a href="https://www.luogu.com.cn/problem/P4662">P4662 [BalticOI 2008]黑手党</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">re_dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    vis[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=head[x],y;i;i=Next[i]) <span class="keyword">if</span>(flow[i]&gt;<span class="number">0</span> &amp;&amp; !vis[ y=ver[i] ]) <span class="built_in">re_dfs</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;S,&amp;T);</span><br><span class="line">    T+=n;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,x;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x),<span class="built_in">add</span>(i,i+n,x),<span class="built_in">add</span>(i+n,i,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,x,y;i&lt;=m;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y),<span class="built_in">add</span>(x+n,y,INF),<span class="built_in">add</span>(y,x+n,<span class="number">0</span>),<span class="built_in">add</span>(y+n,x,INF),<span class="built_in">add</span>(x,y+n,<span class="number">0</span>);</span><br><span class="line">    Webflow::<span class="built_in">Dinic</span>(S,T);</span><br><span class="line">    <span class="built_in">re_dfs</span>(S);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;tot;i+=<span class="number">2</span>) <span class="keyword">if</span>(vis[ ver[i^<span class="number">1</span>] ] &amp;&amp; !vis[ ver[i] ]) ans.<span class="built_in">push_back</span>(ver[i^<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>,SS=ans.<span class="built_in">size</span>()<span class="number">-1</span>;i&lt;=SS;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>,ans[i],i==SS ? <span class="number">10</span> : <span class="number">32</span>);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最大权闭合子图"><a href="#最大权闭合子图" class="headerlink" title="最大权闭合子图"></a>最大权闭合子图</h2><h3 id="理论-1"><a href="#理论-1" class="headerlink" title="理论"></a>理论</h3><p>对于一个有向连通图，每个点带有一个权值，建超级源点汇点，将所有正点权的点连到 $S$ 上，负点权的点连到 $T$ 上，边权为点权的绝对值</p>
<p>特殊的，点权为 $0$ 的点可以被忽略掉，而原图中的边权值设为 $INF$</p>
<p>该图有以下性质：</p>
<ul>
<li>关于 $S-T$ 的最小割是简单割，即，割集中所有边都与 $S,T$ 相连接</li>
<li>简单割产生的两个子图中，有点 $S$ 的图是闭合图，即，图中任一点的的出边指向的终点仍在该图中</li>
<li>最小割产生的 $图S、图T$ 中，$图S$ 为最大权闭合子图</li>
</ul>
<p>那么对于有点权的图，求解最大点权的闭合子图步骤为：</p>
<ul>
<li>记录整个图中所有正点权之和 $sum$</li>
<li>建立流网络，求 $S-T$ 最大流 $maxflow$</li>
<li>最大权闭合子图的权值和即为 $sum-maxflow$</li>
</ul>
<h3 id="P2805-NOI2009-植物大战僵尸"><a href="#P2805-NOI2009-植物大战僵尸" class="headerlink" title="P2805 [NOI2009] 植物大战僵尸"></a><a href="https://www.luogu.com.cn/problem/P2805">P2805 [NOI2009] 植物大战僵尸</a></h3><p>考虑题中的条件得：植物 $i$ 能被攻击当且仅当植物 $i+1$ 与保护 $i$ 的植物都被攻击</p>
<p>与最大权闭合子图中：每个点出边指向的点都属于闭合子图相仿</p>
<p>那么将图转置，所有能被攻击的植物构成一个闭合子图，</p>
<p>同时，注意拓扑判环删去无敌的点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1100</span>,M=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,S,T;</span><br><span class="line"><span class="keyword">int</span> que[N],he,ta;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],Next[M],flow[M],cur[M],tot=<span class="number">1</span>,depth[N];</span><br><span class="line"><span class="keyword">int</span> maxflow,sum;</span><br><span class="line"><span class="keyword">int</span> vis[N],in[N],score[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; out[N];</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_id</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123; <span class="keyword">return</span> i*<span class="number">31</span>+j;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">topsort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">        rei id=<span class="built_in">get_id</span>(i,j);</span><br><span class="line">        <span class="keyword">if</span>(!in[id]) q.<span class="built_in">push</span>(id),vis[id]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        rei x=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">0</span>,SS=**out**[x].<span class="built_in">size</span>()<span class="number">-1</span>;i&lt;=SS;++i)&#123;</span><br><span class="line">            rei y=out[x][i];</span><br><span class="line">            --in[y];</span><br><span class="line">            <span class="keyword">if</span>(!vis[y] &amp;&amp; !in[y]) q.<span class="built_in">push</span>(y),vis[y]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;1.in&quot;,&quot;r&quot;,stdin); freopen(&quot;1.ans&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    S=N<span class="number">-1</span>,T=N<span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">for</span>(rei j=<span class="number">1</span>,w;j&lt;=m;++j)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;score[ <span class="built_in">get_id</span>(i,j) ],&amp;w);</span><br><span class="line">        <span class="keyword">for</span>(rei k=<span class="number">1</span>,r,c;k&lt;=w;++k)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;r,&amp;c),++r,++c;</span><br><span class="line">            out[ <span class="built_in">get_id</span>(i,j) ].<span class="built_in">push_back</span>(<span class="built_in">get_id</span>(r,c));</span><br><span class="line">            ++in[ <span class="built_in">get_id</span>(r,c) ];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;m)&#123;</span><br><span class="line">            out[ <span class="built_in">get_id</span>(i,j+<span class="number">1</span>) ].<span class="built_in">push_back</span>(<span class="built_in">get_id</span>(i,j));</span><br><span class="line">            ++in[ <span class="built_in">get_id</span>(i,j) ];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">topsort</span>();</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!in[ <span class="built_in">get_id</span>(i,j) ])&#123;</span><br><span class="line">            rei id=<span class="built_in">get_id</span>(i,j);</span><br><span class="line">            <span class="keyword">if</span>(!vis[id]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(score[id]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">add</span>(S,id,score[id]),<span class="built_in">add</span>(id,S,<span class="number">0</span>);</span><br><span class="line">                sum+=score[id];</span><br><span class="line">                <span class="comment">// printf(&quot;%d\n&quot;,sum);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">add</span>(id,T,-score[id]),<span class="built_in">add</span>(T,id,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(rei k=<span class="number">0</span>,SS=out[id].<span class="built_in">size</span>()<span class="number">-1</span>;k&lt;=SS;++k)&#123;</span><br><span class="line">                rei y=out[id][k];</span><br><span class="line">                <span class="keyword">if</span>(vis[y]) <span class="built_in">add</span>(y,id,INF),<span class="built_in">add</span>(id,y,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Webflow::<span class="built_in">Dinic</span>(S,T);</span><br><span class="line">    <span class="comment">// printf(&quot;%lld %lld %lld\n&quot;,sum,maxflow,sum-maxflow);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum-maxflow);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P4174-NOI2006-最大获利-CF1082G-Petya-and-Graph"><a href="#P4174-NOI2006-最大获利-CF1082G-Petya-and-Graph" class="headerlink" title="P4174 [NOI2006] 最大获利 / CF1082G Petya and Graph"></a><a href="https://www.luogu.com.cn/problem/P4174">P4174 [NOI2006] 最大获利</a> / <a href="https://www.luogu.com.cn/problem/CF1082G">CF1082G Petya and Graph</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m); S=n+m+<span class="number">1</span>,T=S+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,p;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p),<span class="built_in">add</span>(i,T,p),<span class="built_in">add</span>(T,i,<span class="number">0</span>);<span class="comment">//投入连T</span></span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,a,b,c;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c); sum+=c;</span><br><span class="line">        <span class="built_in">add</span>(S,n+i,c),<span class="built_in">add</span>(n+i,S,<span class="number">0</span>);<span class="comment">//S连收益</span></span><br><span class="line">        <span class="built_in">add</span>(n+i,a,INF),<span class="built_in">add</span>(a,n+i,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">add</span>(n+i,b,INF),<span class="built_in">add</span>(b,n+i,<span class="number">0</span>);<span class="comment">//中间的边不能被删去</span></span><br><span class="line">    &#125;</span><br><span class="line">    Webflow::<span class="built_in">Dinic</span>(S,T);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,sum-maxflow);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ZKW费用流"><a href="#ZKW费用流" class="headerlink" title="ZKW费用流"></a>ZKW费用流</h2><h3 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> ZKW&#123;</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> S,<span class="keyword">int</span> T,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dis,INF,<span class="keyword">sizeof</span> dis); <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis); <span class="built_in">memset</span>(level,<span class="number">0</span>,<span class="keyword">sizeof</span> level);</span><br><span class="line">        <span class="comment">//dis维护到终点最短距离，level分层图</span></span><br><span class="line">        dis[S]=<span class="number">0</span>,level[S]=<span class="number">1</span>,vis[S]=<span class="literal">true</span>;</span><br><span class="line">        deque&lt;<span class="keyword">int</span>&gt; q; q.<span class="built_in">push_back</span>(S);<span class="comment">//SLF 优化</span></span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">            rei x=q.<span class="built_in">front</span>(); q.<span class="built_in">pop_front</span>(); vis[x]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(rei i=head[x],y;i;i=Next[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(dis[ y=ver[i] ]&gt;dis[x]+cost[i] &amp;&amp; flow[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    dis[y]=dis[x]+cost[i];</span><br><span class="line">                    level[y]=level[x]+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(!vis[y])&#123;</span><br><span class="line">                        vis[y]=<span class="number">1</span>;</span><br><span class="line">                        (q.<span class="built_in">size</span>() &amp;&amp; dis[y]&lt;dis[ q.<span class="built_in">front</span>() ]) ? q.<span class="built_in">push_front</span>(y) : q.<span class="built_in">push_back</span>(y);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dis[T]!=dis[n+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> T,<span class="keyword">int</span> t,ll &amp;fflow,ll &amp;ccost)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==T) <span class="keyword">return</span> fflow+=t,flag=<span class="number">1</span>,t;</span><br><span class="line">        rei num=<span class="number">0</span>,newflow=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(rei i=head[x],y;i;i=Next[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(t==num) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(dis[x]+cost[i]==dis[ y=ver[i] ] &amp;&amp; level[x]+<span class="number">1</span>==level[y] &amp;&amp; flow[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                newflow=<span class="built_in">dfs</span>(y,T,<span class="built_in">min</span>(t-num,flow[i]),fflow,ccost);</span><br><span class="line">                num+=newflow; ccost+=newflow*cost[i];</span><br><span class="line">                flow[i]-=newflow; flow[i^<span class="number">1</span>]+=newflow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">costflow</span><span class="params">(<span class="keyword">int</span> S,<span class="keyword">int</span> T,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">SPFA</span>(S,T,n))&#123;</span><br><span class="line">            flag=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">                flag=<span class="number">0</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(S,T,INF,maxflow,mincost);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P4452-国家集训队-航班安排"><a href="#P4452-国家集训队-航班安排" class="headerlink" title="P4452 [国家集训队]航班安排"></a><a href="https://www.luogu.com.cn/problem/P4452">P4452 [国家集训队]航班安排</a></h3><blockquote>
<p>$K$ 架飞机，$N$ 个机场，$M$ 个要求，请求在 $s$ 时刻从 $a$ 起飞，$t$ 时刻降落到 $b$ ，获利 $c$ ，求总收益最大</p>
</blockquote>
<p>最大费用最大流，存负边权即可</p>
<p>考虑建模对象：点或请求</p>
<p>以点来建边的话需要对时间讨论，不如选择请求建边，可以处理请求与请求的关系</p>
<ul>
<li><p>对于源点</p>
<p>判断从起始点 $1$ 是否能直达请求的起点，建流量 $INF$ ，费用 $w_{1,qa}$，有</p>
<p><code>if(q[i].s&gt;=t[1][ q[i].a ]) add(Fake_S,i,INF,w[1][ q[i].a ]),add(i,Fake_S,0,-w[1][ q[i].a ]);</code></p>
<p>由于 $k$ 架飞机，再建真正的源点，向 $1$ 连边，流量 $k$ 费用 $0$</p>
<p><code>add(S,Fake_S,k,0),add(Fake_S,S,0,0);</code></p>
</li>
<li><p>对于汇点</p>
<p>判断请求结束后能不能再规定时间内回到 $1$ ，有</p>
<p><code>if(q[i].t+t[ q[i].b ][1]&lt;=tim) add(i+m,T,INF,w[ q[i].b ][1]),add(T,i+m,0,-w[ q[i].b ][1]);</code></p>
</li>
<li><p>请求的转移</p>
<p>对于每个请求的结束地 $qi_b$，枚举所有的请求，找是否有从结束点 $qi_a$ 赶到起始点 $qj_a$ 后能赶上的情况</p>
<p><code>for(rei j=1;j&lt;=m;++j) if(i!=j &amp;&amp; q[i].t+t[ q[i].b ][ q[j].a ]&lt;=q[j].s) add(i+m,j,INF,w[ q[i].b ][ q[j].a ]),add(j,i+m,0,-w[ q[i].b ][ q[j].a ]);</code></p>
</li>
<li><p>注意每个请求只能进行一次</p>
<p>套路的对进行请求拆点，流量设为 $1$</p>
<p><code>add(i,i+m,1,-q[i].c),add(i+m,i,0,q[i].c);</code></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">S=<span class="number">0</span>,T=<span class="number">2</span>*m+<span class="number">2</span>,Fake_S=T<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=n;++j) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t[i][j]);</span><br><span class="line"><span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=n;++j) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i][j]);</span><br><span class="line"><span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=m;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>,&amp;q[i].a,&amp;q[i].b,&amp;q[i].s,&amp;q[i].t,&amp;q[i].c),++q[i].a,++q[i].b;</span><br><span class="line"><span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">    <span class="built_in">add</span>(i,i+m,<span class="number">1</span>,-q[i].c),<span class="built_in">add</span>(i+m,i,<span class="number">0</span>,q[i].c);<span class="comment">//拆点，控制只能由一次收益</span></span><br><span class="line">    <span class="keyword">if</span>(q[i].t+t[ q[i].b ][<span class="number">1</span>]&lt;=tim) <span class="built_in">add</span>(i+m,T,INF,w[ q[i].b ][<span class="number">1</span>]),<span class="built_in">add</span>(T,i+m,<span class="number">0</span>,-w[ q[i].b ][<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// else continue;</span></span><br><span class="line">    <span class="keyword">if</span>(q[i].s&gt;=t[<span class="number">1</span>][ q[i].a ]) <span class="built_in">add</span>(Fake_S,i,INF,w[<span class="number">1</span>][ q[i].a ]),<span class="built_in">add</span>(i,Fake_S,<span class="number">0</span>,-w[<span class="number">1</span>][ q[i].a ]);</span><br><span class="line">    <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=m;++j) <span class="keyword">if</span>(i!=j &amp;&amp; q[i].t+t[ q[i].b ][ q[j].a ]&lt;=q[j].s) <span class="built_in">add</span>(i+m,j,INF,w[ q[i].b ][ q[j].a ]),<span class="built_in">add</span>(j,i+m,<span class="number">0</span>,-w[ q[i].b ][ q[j].a ]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">add</span>(S,Fake_S,k,<span class="number">0</span>),<span class="built_in">add</span>(Fake_S,S,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">ZKW::<span class="built_in">costflow</span>();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/2021/01/04/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="背包9讲（大概"><a href="#背包9讲（大概" class="headerlink" title="背包9讲（大概"></a>背包9讲（大概</h1><h2 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0/1背包"></a>0/1背包</h2><ul>
<li><p>模型</p>
<p>多种物品,每种物品只有一个.求能获得的最大总价值.</p>
</li>
<li><p>思路</p>
<p>不选择第 $i$ 件物品,就相当用 $i-1$ 件物品,填充了体积为 $v$ 的背包.</p>
<p>选择第 $i$ 件物品，相当于对 $i-1$ 件物品填充得到的体积为  $v-c[i]$ 的背包,再填充第 $i$ 个物品得到体积为 $v$ 的背包.</p>
</li>
<li><p>转移方程</p>
<script type="math/tex; mode=display">f[i][v]=\max(f[i-1][v],f[i-1][v-c[i]]+w[i])</script><p>$f[i][v]$ 代表用 $i$ 件物品填充为体积为 $v$ 的背包得到的最大价值.</p>
</li>
<li><p>注</p>
<p>一般考虑倒序枚举</p>
<p>这样 $f_i$ 不会被 $i$ 以前的状态影响,更新也不会影响其他位置的状态.</p>
</li>
</ul>
<p>-代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//枚举物品</span></span><br><span class="line">	<span class="keyword">for</span>(rei j=V;j&gt;=c[i];j--)<span class="comment">//枚举体积</span></span><br><span class="line">		f[j]=<span class="built_in">max</span>(f[j],f[j-c[i]]+w[i]);<span class="comment">//状态转移方程.</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><ul>
<li><p>模型</p>
<p>每种物品有无限多个,可重复选取.</p>
</li>
</ul>
<p><del>- 思路没有了（与0/1类似（逃</del></p>
<ul>
<li><p>转移方程</p>
<script type="math/tex; mode=display">f[i][v]=\max(f[i-1][v],f[i-1][j-k\ast c[i]]+k\ast w[i])</script></li>
<li><p>注</p>
<p>顺序枚举</p>
<p><a href="https://www.luogu.com.cn/blog/RPdreamer/post-01-bei-bao-yu-wan-quan-bei-bao-di-mei-ju-shun-xu-di-fou-tong-chu">01背包与完全背包的枚举顺序的不同处</a></p>
</li>
<li><p>代码</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//枚举物品</span></span><br><span class="line">	<span class="keyword">for</span>(rei j=c[i];j&lt;=V;j++)<span class="comment">//枚举体积</span></span><br><span class="line">		f[j]=<span class="built_in">max</span>(f[j],f[j-c[i]]]+w[i]);<span class="comment">//状态转移.</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><ul>
<li><p>模型</p>
<p>有了个数的限制</p>
</li>
</ul>
<p><del>- 思路不想写了</del></p>
<pre><code>朴素做法就是把每种物品都拆成 size 个物品跑0/1背包
</code></pre><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul>
<li><p>二进制拆分</p>
<p>易知 $size_i=2^0+2^1+2^2+2^3…+2^x+y$</p>
<p>其 $k$ 是任意数，$y$ 是一个不为2的整数次幂的数</p>
<p>所以在多重背包中，可以将个数的限制如此分解</p>
<p>每个分解看成一个物品</p>
<p>(如： $2^2$ 看成 $1$ 个物品，该物品 $val=4\cdot val_i \space, \space w=4\cdot w_i$)</p>
<p>如此进行后就是 $\log (size)$</p>
<ul>
<li><p>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Good</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,w;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Good&gt; g;</span><br><span class="line"></span><br><span class="line">···</span><br><span class="line"><span class="comment">//对每个读入的v,w,s</span></span><br><span class="line"><span class="keyword">for</span>(rei k=<span class="number">1</span>;k&lt;=s;k*=<span class="number">2</span>)&#123;</span><br><span class="line">    s-=k;</span><br><span class="line">    g.<span class="built_in">push_back</span>(&#123;v*k,w*k&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(s) g.<span class="built_in">push_back</span>(&#123;v*s,w*s&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//总dp</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> good:g)&#123;</span><br><span class="line">    <span class="keyword">for</span>(rei j=m;j&gt;=good.v;--j)&#123;</span><br><span class="line">        f[j]=<span class="built_in">max</span>(f[j],f[j-good.v]+good.w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>单调队列优化</p>
<p>这是一个最基本的转移式子</p>
<p>$f[i][j]=\max\left(f[i−1][j],f[i−1][j−k\ast c[i]]+k\ast w[i]\right)$</p>
<p>其中 $k \in \left[1,\min\left(\left\lfloor\frac{V}{c[i]}\right\rfloor,num[i]\right)\right]$</p>
<p>下面用 $lim$ 表示 $\min\left(\left\lfloor\frac{V}{c[i]}\right\rfloor,num[i]\right)$</p>
<p>易得 $f[i][j−k\cdot c[i]]$ 会被 $f[i][j−(k+1)\cdot c[i]]$ 影响</p>
<p>(体积为 $c[i]$ 的物品填充体积为 $j−(k+1)\cdot c[i]$ 的背包,会得到体积为 $j−k\cdot c[i]$ 的背包)</p>
<p>$f[i][j]$ 将会影响 $f[i][j+k\cdot c[i]]　\left(j+k\cdot c[i]\leq V\right)$</p>
<p>注意这里影响的传导，往取模上想</p>
<p>所以我们可以根据对 $c[i]$ 取模得到的余数进行分组.</p>
<p>即可分为 $0,1,2,3…c[i]−1$ 共 $c[i]$ 组</p>
<p>每组之间的状态互相没有影响</p>
<p>且每组中位置靠后的受前面的影响</p>
<ul>
<li><p>进行一些推导</p>
<p>注： $\left\lfloor \frac{j}{c[i]} \right\rfloor即是全选状态下的物品个数$</p>
<script type="math/tex; mode=display">\because j=\left\lfloor \frac{j}{c[i]} \right\rfloor \ \cdot \ c[i] \ +\ j\% c[i]</script><script type="math/tex; mode=display">\begin{aligned}
j−k∗c[i]&=\left\lfloor \frac{j}{c[i]} \right\rfloor\cdot c[i] \ +\ j\% c[i] \ −\ k\cdot c[i] \\
&=\left(\left\lfloor \frac{j}{c[i]} \right\rfloor \ −\ k\right)\cdot c[i]+j \% c[i]
\end{aligned}</script><p>令 $\left(\left\lfloor \frac{j}{c[i]} \right\rfloor−k\right)=k^{‘}$</p>
<p>最原始的状态转移方程中第二状态 :</p>
<p>$f[i][j−k\cdot c[i]\ ]+k\cdot w[i]$ 代表选择 $k$ 个当前 $i$ 物品</p>
<p>根据单步容斥 ：全选−不选=选</p>
<p>因此 $\left\lfloor \frac{j}{c[i]} \right\rfloor \ −\ \left(\left\lfloor \frac{j}{c[i]} \right\rfloor−k\right)=k$</p>
<script type="math/tex; mode=display">\because \left(\left\lfloor \frac{j}{c[i]} \right\rfloor−k\right)=k^{'}</script><script type="math/tex; mode=display">\therefore f[i][j]=\max\left( \ f[i−1][\ k^{'}\cdot c[i]+j \% c[i] \ ] \ + \ \left\lfloor \frac{j}{c[i]} \right\rfloor\cdot w[i]−k^{'}\cdot w[i]\right)</script><p>而其中 $\left\lfloor \frac{j}{c[i]} \right\rfloor\cdot w[i]$ 为一个常量(因为 $\left\lfloor \frac{j}{c[i]} \right\rfloor$ 已知)</p>
<p>要求的状态变为</p>
<script type="math/tex; mode=display">f[i][j]=\max\left(f[i−1][ \ k^{'}\cdot c[i]+j\% c[i] \ ]−k^{'}\cdot w[i]\right)+\left\lfloor \frac{j}{c[i]} \right\rfloor\cdot w[i]</script><script type="math/tex; mode=display">\because k \in [1,lim]</script><script type="math/tex; mode=display">\therefore k^{'} \in \left[\left\lfloor \frac{j}{c[i]} \right\rfloor−k,\left\lfloor \frac{j}{c[i]} \right\rfloor\right]</script><p>当前的 $f[i][j]$ 求解的就是为 $lim+1$ 个数对应的 $f[i−1][k^{‘}\cdot c[i]+j\% c[i] \ ]−k^{‘}\cdot w[i]$ 的最大值.</p>
<p>(之所以为 $lim+1$ 个数,是包括当前这个 $j$ ,还有前面的物品数量)</p>
<p>将 $f[i][j]$ 前面所有的 $f[i−1][k^{‘}\cdot c[i]+j\% c[i]\ ]−k^{‘}\cdot w[i]$ 放入一个队列.</p>
<p>问题转化为求这个最长为 $lim+1$ 的队列的最大值 $+\left\lfloor \frac{j}{c[i]} \right\rfloor\cdot w[i]$</p>
</li>
<li><p>代码</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">//枚举物品种类</span></span><br><span class="line">    cin&gt;&gt;c[i]&gt;&gt;w[i]&gt;&gt;num[i];<span class="comment">//c,w,num分别对应 体积,价值,个数</span></span><br><span class="line">    <span class="keyword">if</span>(V/c[i] &lt; num[i]) num[i]=V/c[i];<span class="comment">//求lim</span></span><br><span class="line">    <span class="keyword">for</span>(rei p=<span class="number">0</span>;p&lt;c[i];p++)&#123;<span class="comment">//枚举余数</span></span><br><span class="line">        head=tail=<span class="number">0</span>;<span class="comment">//队列初始化</span></span><br><span class="line">        <span class="keyword">for</span>(rei k=<span class="number">0</span>;k&lt;=(V-p)/c[i];k++)&#123;</span><br><span class="line">            rei x=k;</span><br><span class="line">            rei y=f[k*c[i]+p]-k*w[i];</span><br><span class="line">            <span class="keyword">while</span>(head&lt;tail &amp;&amp; q[head].pos&lt;k-num) ++head;<span class="comment">//限制长度</span></span><br><span class="line">            <span class="keyword">while</span>(head&lt;tail &amp;&amp; q[tail<span class="number">-1</span>].value&lt;=y) --tail;</span><br><span class="line">            q[tail].value=y,q[tail].pos=x;</span><br><span class="line">            ++tail;</span><br><span class="line">            f[k*c[i]+p]=q[head].value+k*w[i];</span><br><span class="line">            <span class="comment">//单调队列维护的是前i-1种的状态最大值.</span></span><br><span class="line">            <span class="comment">//因此这里加上k*w[i].</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="混合背包"><a href="#混合背包" class="headerlink" title="混合背包"></a>混合背包</h2></li>
<li><p>思路</p>
<p>拆开分别算即可</p>
</li>
<li><p>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">    rei v,w,s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;v,&amp;w,&amp;s);</span><br><span class="line">    <span class="keyword">if</span>(s&lt;<span class="number">0</span>) things.<span class="built_in">push_back</span>(&#123;<span class="number">-1</span>,v,w&#125;);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!s) things.<span class="built_in">push_back</span>(&#123;<span class="number">0</span>,v,w&#125;);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(rei k=<span class="number">1</span>;k&lt;=s;k*=<span class="number">2</span>)&#123;</span><br><span class="line">            s-=k;</span><br><span class="line">            things.<span class="built_in">push_back</span>(&#123;<span class="number">-1</span>,v*k,w*k&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s&gt;<span class="number">0</span>) things.<span class="built_in">push_back</span>(&#123;<span class="number">-1</span>,v*s,w*s&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> thing : things)&#123;</span><br><span class="line">    <span class="keyword">if</span>(thing.kind&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(rei j=m;j&gt;=thing.v;--j)</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-thing.v]+thing.w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(rei j=thing.v;j&lt;=m;++j)</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-thing.v]+thing.w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="二维费用背包"><a href="#二维费用背包" class="headerlink" title="二维费用背包"></a>二维费用背包</h2><ul>
<li><p>模型</p>
<p>有容量 $v$ 与重量 $w$ 两个限制</p>
</li>
<li><p>思路</p>
<p>限制扩展到二维即可</p>
</li>
<li><p>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">    rei a,b,c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    <span class="keyword">for</span>(rei j=v;j&gt;=a;--j)</span><br><span class="line">        <span class="keyword">for</span>(rei k=m;k&gt;=b;--k)</span><br><span class="line">            f[j][k]=<span class="built_in">max</span>(f[j][k],f[j-a][k-b]+c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h2><ul>
<li><p>模型</p>
<p>每组若干个物品，每个物品组内的物品互斥（只能选一个）</p>
</li>
<li><p>转移方程</p>
<script type="math/tex; mode=display">f[k][v]=\max(f[k-1][v],f[k-1][v-c[i]]+w[i])</script></li>
<li><p>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//每一组</span></span><br><span class="line">    rei s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;s);</span><br><span class="line">    <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;s;++j) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;v[j],&amp;w[j]);</span><br><span class="line">    <span class="keyword">for</span>(rei j=m;j&gt;=<span class="number">0</span>;--j)<span class="comment">//枚举体积</span></span><br><span class="line">        <span class="keyword">for</span>(rei k=<span class="number">0</span>;k&lt;s;++k)<span class="comment">//枚举物品</span></span><br><span class="line">            <span class="keyword">if</span>(j&gt;=v[k])</span><br><span class="line">                f[j]=<span class="built_in">max</span>(f[j],f[j-v[k]]+w[k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="有依赖的背包"><a href="#有依赖的背包" class="headerlink" title="有依赖的背包"></a>有依赖的背包</h2><ul>
<li><p>模型</p>
<p>物品间有依赖关系，且依赖关系组成一棵树</p>
<p>为选取某节点，必须选取该节点的父节点</p>
<p>eg:<strong>选课问题</strong></p>
</li>
<li><p>思路</p>
<p>对每个点，$\text{dfs}$ 其子节点再 $\text{dp}$</p>
<p>特别注意子节点 $\text{dp}$ 体积时要给父节点留下空间</p>
<p>详见代码</p>
</li>
<li><p>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(rei i=head[u];i!=<span class="number">-1</span>;i=Next[i])&#123;</span><br><span class="line">        rei son=ver[i];</span><br><span class="line">        <span class="built_in">dfs</span>(son);</span><br><span class="line">        <span class="keyword">for</span>(rei j=m-v[u];j&gt;=<span class="number">0</span>;--j)<span class="comment">//注意，这里要留出当前点的体积再去dp其子节点</span></span><br><span class="line">            <span class="keyword">for</span>(rei k=<span class="number">0</span>;k&lt;=j;++k)</span><br><span class="line">                f[u][j]=<span class="built_in">max</span>(f[u][j],f[u][j-k]+f[son][k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=m;i&gt;=v[u];--i) f[u][i]=f[u][i-v[u]]+w[u];<span class="comment">//加上当前点</span></span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;v[u];++i) f[u][i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title>超几何分布中的期望</title>
    <url>/2021/07/18/%E8%B6%85%E5%87%A0%E4%BD%95%E5%88%86%E5%B8%83%E4%B8%AD%E7%9A%84%E6%9C%9F%E6%9C%9B/</url>
    <content><![CDATA[<h2 id="超几何分布"><a href="#超几何分布" class="headerlink" title="超几何分布"></a>超几何分布</h2><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>对于 $N=N_1+N_2$ 个外表相同的物品，从中抽取 $n$ 个物品，每个物品抽取等概率随机</p>
<hr>
<h3 id="n-个中有-x-个-N-1-类物品的概率"><a href="#n-个中有-x-个-N-1-类物品的概率" class="headerlink" title="$n$ 个中有 $x$ 个 $N_1$ 类物品的概率"></a>$n$ 个中有 $x$ 个 $N_1$ 类物品的概率</h3><p>首先，若 $x&gt;N_1$ 概率为 $0$ ，故不需考虑</p>
<p>对于所取的 $n$ 个数，若满足条件：</p>
<p>- 从 $N_1$ 个中抽 $x$ 个 ， 有 $\displaystyle{\binom{N_1}{x}}$ 种</p>
<p>- 从 $N_2$ 个中抽 $n-x$ 个 ， 有 $\displaystyle{\binom{N_2}{n-x}}$ 种</p>
<p>所以总合法取法有 $\displaystyle{\binom{N_1}{x} \binom{N_2}{n-x}}$ 种 ， 而总取法有 $\displaystyle{\binom{N}{n}}$</p>
<script type="math/tex; mode=display">\therefore P(X=x)= \frac{\binom{N_1}{x} \binom{N_2}{n-x}}{\binom{N}{n}}</script><hr>
<h3 id="抽出-x-个-N-1-的期望"><a href="#抽出-x-个-N-1-的期望" class="headerlink" title="抽出 $x$ 个 $N_1$ 的期望"></a>抽出 $x$ 个 $N_1$ 的期望</h3><script type="math/tex; mode=display">E(x)=\sum_{x=0}^{N_1} x\times P(X=x) =\sum_{x=1}^{N_1} x\times P(X=x)</script><p>由组合数公式 $\displaystyle{\binom{N}{n}=\frac{N}{n} \binom{N-1}{n-1}}$ 得</p>
<script type="math/tex; mode=display">\begin{aligned}原式

&=\sum_{x=1}^{N_1} x\times \frac{ \frac{N_1}{x} \binom{N_1-1}{x-1} \binom{N_2}{n-x} }{ \frac{N}{n} \binom{N-1}{n-1}} \\

&=\frac{n\times N_1}{N} \sum_{x=1}^{N_1} \frac{ \binom{N_1-1}{x-1} \binom{N_2}{n-x}}{ \binom{N-1}{n-1}} \\

&=\frac{n\times N_1}{N} \sum_{x=1}^{N_1} \frac{ \binom{N_1-1}{x-1} \binom{N_2}{(n-1)-(x-1)}}{ \binom{N-1}{n-1}} \\

&=\frac{n\times N_1}{N} \sum_{x=1}^{N_1} P(X=x-1)

\end{aligned}</script><script type="math/tex; mode=display">\because \sum_{x=1}^{N_1} P(X=x-1) 的含义为：n 中有 x-1 个 N_1 的概率和</script><script type="math/tex; mode=display">\therefore \sum_{x=1}^{N_1} P(X=x-1)=1</script><script type="math/tex; mode=display">\therefore 原式=\frac{n\times N_1}{N}</script>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代加深</title>
    <url>/2021/04/07/%E8%BF%AD%E4%BB%A3%E5%8A%A0%E6%B7%B1/</url>
    <content><![CDATA[<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><ul>
<li><p>答案求最小步数</p>
</li>
<li><p>在某步数内一定可以完成 或 超出某步数认为无解</p>
</li>
</ul>
<hr>
<h3 id="随便写点注意事项"><a href="#随便写点注意事项" class="headerlink" title="随便写点注意事项"></a>随便写点注意事项</h3><ul>
<li><p>注意估值函数的选取</p>
<p>一般为 <strong>当前状态到最终状态的最短步数+已走的步数</strong>  是否大于 <strong>枚举的深度</strong></p>
<ul>
<li>在[ $flood \ it$ ] 中：定义了专门的求估值函数（好像就变成IDA*了</li>
</ul>
</li>
<li><p>$\text{dfs}(now+1)$ 失败后及时回复现场</p>
<ul>
<li><p>$eg$ : [ $八数码难题$ ] 中：<strong>通过两数交换</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">swap</span>(sta[nx][ny],sta[x][y]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">test</span>(step)) <span class="built_in">A</span>(step+<span class="number">1</span>,nx,ny,i);</span><br><span class="line"></span><br><span class="line"><span class="built_in">swap</span>(sta[nx][ny],sta[x][y]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>$eg$ : [ $骑士精神$ ] 中：<strong>毫无可读性的两数交换</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a[x][y]^=a[xx][yy],a[xx][yy]^=a[x][y],a[x][y]^=a[xx][yy];<span class="comment">//什么是swap</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> flag=<span class="built_in">dfs</span>(step+<span class="number">1</span>,maxstep,tmp,xx,yy,i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">a[x][y]^=a[xx][yy],a[xx][yy]^=a[x][y],a[x][y]^=a[xx][yy];<span class="comment">//回复现场</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>$eg$ : [ $flood \ it$ ] 中：<strong>通过对数组的交换</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(tmp,vis,<span class="keyword">sizeof</span> vis);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">fill</span>(i) &amp;&amp; <span class="built_in">dfs</span>(now+<span class="number">1</span>)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(vis,tmp,<span class="keyword">sizeof</span> vis);<span class="comment">//还原</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>在枚举每次状态改变时，注意及时的剪枝，即使是看起来并不重要的</p>
<ul>
<li><p>栗子 $1$：出界</p>
<p>好容易忘qwq（写总结的时候也忘了</p>
</li>
<li><p>栗子 $2$：当前移动恰与上一步相反</p>
<ul>
<li><p>剪枝方法：</p>
<p>仔细选取 $dx[ \ ],dy[ \ ]$</p>
<p>判断两次移动的方向和 $i+pre$</p>
</li>
<li><p>$eg$ : [ $骑士精神$ ] 中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">8</span>]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dy[<span class="number">8</span>]=&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如此保证两个相反的方向加和为7</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>栗子 $3$：当前步恰好完成,或通过估价函数得到当前步可行</p>
<ul>
<li><p>$eg$ : [$Power \ Calculus$] 中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(now==n || now&lt;&lt;(MAX-step)==n<span class="comment">/*题目背景可推断*/</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>$eg$ : [$flood \ it$] 中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">rei g=<span class="built_in">get_val</span>();</span><br><span class="line">···</span><br><span class="line"><span class="keyword">if</span>(!g) <span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>栗子 $4$：针对当前块的扩展问题，要得到周围与之相邻的块的编号（我不知道我在写什么</p>
<ul>
<li><p>剪枝方法：</p>
<p>开 $vis[ \ ]$ 数组并及时维护</p>
</li>
<li><p>$eg$ : [ $flood \ it$ ] 中：</p>
<p><del>自行读代码</del></p>
</li>
</ul>
</li>
<li><p>栗子 $5$：考虑答案的单调性</p>
<ul>
<li><p>$eg$ : [$Addition \ Chains$] 中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;now;++i)</span><br><span class="line">    <span class="keyword">for</span>(rei j=i;j&lt;now;++j)&#123;<span class="comment">//从i开始啊qwq</span></span><br><span class="line">        rei tmp=ans[i]+ans[j];</span><br><span class="line">        <span class="keyword">if</span>(tmp&gt;n) <span class="keyword">break</span>;<span class="comment">//ans单增</span></span><br><span class="line">        <span class="keyword">if</span>(tmp&lt;=ans[now<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        ans[now]=tmp;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(now+<span class="number">1</span>,MAX)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>注意一下开始 $\text{dfs}$ 的深度为 $0/1$</p>
<p>关系到答案输出是 $MAX$ 还是 $MAX-1$</p>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>迭代加深</tag>
      </tags>
  </entry>
  <entry>
    <title>2-SAT</title>
    <url>/2021/10/26/2-SAT/</url>
    <content><![CDATA[<h2 id="text-k-SAT"><a href="#text-k-SAT" class="headerlink" title="$\text{k-SAT}$"></a>$\text{k-SAT}$</h2><p>给定 $n$ 个 $\text{bool}$ 变量和 $m$ 个约束条件，每个条件形如 $x_1\oplus x_2\oplus … \oplus x_k=0/1$ (此处 $\oplus$ 表示一种 $bool$ 运算)，求是否有解并能构造，可证明当 $k&gt;2$ 时 $\text{k-SAT}$ 是 <a href="http://www.matrix67.com/blog/archives/105">$\text{NPC}$ 问题</a></p>
<h2 id="text-2-SAT"><a href="#text-2-SAT" class="headerlink" title="$\text{2-SAT}$"></a>$\text{2-SAT}$</h2><h3 id="建图"><a href="#建图" class="headerlink" title="建图"></a>建图</h3><p>由于每个点只有 $0/1$ 两种取值，那么对于每个点 $i$ ，拆成两点 $i,i+n$ 分别表示 $x_i=1,x_i=0$</p>
<p>对于约束关系，考虑建有向边 $x\rightarrow y$ 表示选 $x$ 则必须选 $y$</p>
<ul>
<li>当 $a_i\ \text{xor}\ a_j=1$ ，即 $i,j$ 不能同时选，则有 $i\rightarrow j+n,j\rightarrow i+n$</li>
<li>当 $a_i\ \text{xor}\ a_j=0$ ，即 $i,j$ 必须同时选，则有 $i\rightarrow j,j\rightarrow i$</li>
<li>当 $a_i\ \text{or}\ a_j=1$ ，即 $i,j$ 任选，则有 $i\rightarrow j+n,j+n\rightarrow i,j\rightarrow i+n,i+n\rightarrow j$</li>
<li>当 $a_i=1 \mid a_i\ \text{and}\ a_j=1$ ，即 $i$ 必须选，则有 $i+n\rightarrow i$</li>
</ul>
<p>考虑到若有 $i\rightarrow j$ ，由于原命题与逆否命题真假相同，则有 $inv_i\rightarrow inv_j$ ，那么有简化代码：</p>
<p><code>inline void insert(int u,int v)&#123; add(x,y),add(y&gt;n ? y-n : y+n,x&gt;n ? x-n : x+n)&#125;</code></p>
<h3 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h3><p>不妨转化为强连通分量问题，即若 $i,i+n$ 在同一强连通分量则无解，用 $\text{tarjan}$ 求解即可</p>
<p>具体的， $\text{tarjan}$ 所得的拓扑序是逆序的，即后求出的强连通分量可能到达先求出的强连通分量，而先求出的不能到达后求出的，那么若 $scc_i&lt;scc_{i+n}$ 则 $i$ 所在的强连通分量先求出，那么选 $i$</p>
<p><a href="https://www.luogu.com.cn/problem/P4782">P4782 【模板】2-SAT 问题</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,t;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[N&lt;&lt;<span class="number">1</span>],Next[N&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line"><span class="keyword">int</span> low[N&lt;&lt;<span class="number">1</span>],scc[N&lt;&lt;<span class="number">1</span>],scc_cnt,dfn_cnt;</span><br><span class="line"><span class="keyword">int</span> stk[N&lt;&lt;<span class="number">1</span>],top;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123; ver[++tot]=v,Next[tot]=head[u],head[u]=tot;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123; <span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v&gt;n ? v-n : v+n,u&gt;n ? u-n : u+n);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    stk[++top]=x; low[x]=++dfn_cnt; rei ori=low[x];</span><br><span class="line">    <span class="keyword">for</span>(rei i=head[x];i;i=Next[i])&#123;</span><br><span class="line">        rei y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(!low[y]) <span class="built_in">tarjan</span>(y),low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!scc[y]) low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low[x]==ori) <span class="keyword">for</span>(++scc_cnt;scc[stk[top]]=scc_cnt,stk[top--]!=x;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,u,a,v,b;i&lt;=m;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;u,&amp;a,&amp;v,&amp;b),<span class="built_in">insert</span>(a ? u+n : u,b ? v : v+n);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=(n&lt;&lt;<span class="number">1</span>);++i) <span class="keyword">if</span>(!low[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>(scc[i]==scc[i+n]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;IMPOSSIBLE&quot;</span>),<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;POSSIBLE&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>,scc[i]&lt;scc[i+n],i==n ? <span class="number">10</span> : <span class="number">32</span>);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="P4171-JSOI2010-满汉全席"><a href="#P4171-JSOI2010-满汉全席" class="headerlink" title="P4171 [JSOI2010] 满汉全席"></a><a href="https://www.luogu.com.cn/problem/P4171">P4171 [JSOI2010] 满汉全席</a></h4><p>没什么好说的板板题</p>
<h4 id="P5782-POI2001-和平委员会"><a href="#P5782-POI2001-和平委员会" class="headerlink" title="P5782 [POI2001] 和平委员会"></a><a href="https://www.luogu.com.cn/problem/P5782">P5782 [POI2001] 和平委员会</a></h4><p>仍然是板板题，只不过数据输入方式对 $i\rightarrow i+n$ 建边方式并不友好</p>
<h4 id="P3825-NOI2017-游戏"><a href="#P3825-NOI2017-游戏" class="headerlink" title="P3825 [NOI2017] 游戏"></a><a href="https://www.luogu.com.cn/problem/P3825">P3825 [NOI2017] 游戏</a></h4><blockquote>
<p><del>题面好长不想写</del></p>
</blockquote>
<ul>
<li><p>对于 $d=0$</p>
<p>即没有 <code>x</code> 的赛场，可以发现这就是裸的 $\text{2-SAT}$</p>
<p>对于给定的四元组，分类讨论：</p>
<ul>
<li>第 $i$ 场不能用 $h_i$ : 不管该四元组</li>
<li>第 $j$ 场不能用 $h_j$ : 那么第 $i$ 场不能用 $h_i$</li>
<li>正常连边即可</li>
</ul>
<p>通过字典序大小关系建边，输出方案时只有两种可能的赛车，那么仍按照字典序大小关系输出即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_num</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[k]==<span class="string">&#x27;a&#x27;</span>) <span class="keyword">return</span> ch==<span class="string">&#x27;B&#x27;</span> ? k : k+n;</span><br><span class="line">    <span class="keyword">return</span> ch==<span class="string">&#x27;A&#x27;</span> ? k : k+n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;d); <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>); <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="comment">// puts(&quot;here&quot;);</span></span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,pos1,pos2;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %s %d %s&quot;</span>,&amp;pos1,ss+<span class="number">1</span>,&amp;pos2,tt+<span class="number">1</span>);</span><br><span class="line">        flag1=ss[<span class="number">1</span>],flag2=tt[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// printf(&quot;%d %c %d %c\n&quot;,pos1,flag1,pos2,flag2);</span></span><br><span class="line">        <span class="keyword">if</span>(s[pos1]==flag1+<span class="number">32</span>) <span class="keyword">continue</span>;<span class="comment">//大写</span></span><br><span class="line">        pos1=<span class="built_in">get_num</span>(pos1,flag1),pos2=<span class="built_in">get_num</span>(pos2,flag2);</span><br><span class="line">        <span class="keyword">if</span>(s[pos2]==flag2+<span class="number">32</span>) <span class="built_in">add</span>(pos1,pos1&gt;n ? pos1-n : pos1+n);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(pos1,pos2),<span class="built_in">add</span>(pos2&gt;n ? pos2-n : pos2+n,pos1&gt;n ? pos1-n : pos1+n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=(n&lt;&lt;<span class="number">1</span>);++i) <span class="keyword">if</span>(!low[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>(scc[i]==scc[i+n]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>),<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;a&#x27;</span>) <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,scc[i]&lt;scc[i+n] ? <span class="string">&#x27;B&#x27;</span> : <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;b&#x27;</span>) <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,scc[i]&lt;scc[i+n] ? <span class="string">&#x27;A&#x27;</span> : <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,scc[i]&lt;scc[i+n] ? <span class="string">&#x27;A&#x27;</span> : <span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>再考虑全部的分</p>
<p>发现地图类型 <code>x</code> 的最多只有 $8$ 个，可以考虑枚举该地图</p>
<p>枚举三种地图的复杂度是 $O(3^8 \times (n+m))$ ，不能接受</p>
<p>考虑仅枚举 <code>A</code> <code>B</code> 的情况，那么仍遍历了当前位上的三种选择情况，复杂度降至 $O(2^8 \times (n+m))$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">4e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,d;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[N&lt;&lt;<span class="number">1</span>],Next[N&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line"><span class="keyword">int</span> scc[N&lt;&lt;<span class="number">1</span>],low[N&lt;&lt;<span class="number">1</span>],scc_cnt,dfn_cnt;</span><br><span class="line"><span class="keyword">int</span> stk[N],top;</span><br><span class="line"><span class="keyword">char</span> s[N],flag1,flag2,ss[<span class="number">10</span>],tt[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> I[N][<span class="number">2</span>]; <span class="keyword">char</span> h[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> pos_x[<span class="number">10</span>],cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123; ver[++tot]=v,Next[tot]=head[u],head[u]=tot;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_num</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[k]==<span class="string">&#x27;a&#x27;</span>) <span class="keyword">return</span> ch==<span class="string">&#x27;B&#x27;</span> ? k : k+n;</span><br><span class="line">    <span class="keyword">return</span> ch==<span class="string">&#x27;A&#x27;</span> ? k : k+n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    low[x]=++dfn_cnt; stk[++top]=x; rei ori=dfn_cnt;</span><br><span class="line">    <span class="keyword">for</span>(rei i=head[x];i;i=Next[i])&#123;</span><br><span class="line">        rei y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(!low[y]) <span class="built_in">tarjan</span>(y),low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!scc[y]) low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low[x]==ori) <span class="keyword">for</span>(++scc_cnt; scc[ stk[top] ]=scc_cnt,stk[top--]!=x;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span> head); <span class="built_in">memset</span>(scc,<span class="number">0</span>,<span class="keyword">sizeof</span> scc); <span class="built_in">memset</span>(low,<span class="number">0</span>,<span class="keyword">sizeof</span> low); <span class="built_in">memset</span>(stk,<span class="number">0</span>,<span class="keyword">sizeof</span> stk);</span><br><span class="line">    tot=scc_cnt=dfn_cnt=top=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,pos1,pos2;i&lt;=m;++i)&#123;</span><br><span class="line">        pos1=I[i][<span class="number">1</span>],pos2=I[i][<span class="number">2</span>],flag1=h[i][<span class="number">1</span>],flag2=h[i][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[pos1]==flag1+<span class="number">32</span>) <span class="keyword">continue</span>;</span><br><span class="line">        rei num1=<span class="built_in">get_num</span>(pos1,flag1),num2=<span class="built_in">get_num</span>(pos2,flag2);</span><br><span class="line">        <span class="keyword">if</span>(s[pos2]==flag2+<span class="number">32</span>) <span class="built_in">add</span>(num1,num1&gt;n ? num1-n : num1+n);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(num1,num2),<span class="built_in">add</span>(num2&gt;n ? num2-n : num2+n,num1&gt;n ? num1-n : num1+n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=(n&lt;&lt;<span class="number">1</span>);++i) <span class="keyword">if</span>(!low[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>(scc[i]==scc[i+n]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(step&gt;d) <span class="keyword">return</span> <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;=<span class="number">1</span>;++i)&#123;</span><br><span class="line">        s[ pos_x[step] ]=<span class="string">&#x27;a&#x27;</span>+i;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(step+<span class="number">1</span>)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;d); <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>); <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>(s[i]==<span class="string">&#x27;x&#x27;</span>) pos_x[++cnt]=i;</span><br><span class="line">    <span class="comment">// puts(&quot;here&quot;);</span></span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,pos1,pos2;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %s %d %s&quot;</span>,&amp;pos1,ss+<span class="number">1</span>,&amp;pos2,tt+<span class="number">1</span>);</span><br><span class="line">        flag1=ss[<span class="number">1</span>],flag2=tt[<span class="number">1</span>];</span><br><span class="line">        I[i][<span class="number">1</span>]=pos1,I[i][<span class="number">2</span>]=pos2; h[i][<span class="number">1</span>]=flag1,h[i][<span class="number">2</span>]=flag2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">dfs</span>(<span class="number">1</span>)) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>),<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;a&#x27;</span>) <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,scc[i]&lt;scc[i+n] ? <span class="string">&#x27;B&#x27;</span> : <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;b&#x27;</span>) <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,scc[i]&lt;scc[i+n] ? <span class="string">&#x27;A&#x27;</span> : <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,scc[i]&lt;scc[i+n] ? <span class="string">&#x27;A&#x27;</span> : <span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="前缀优化建图-例题"><a href="#前缀优化建图-例题" class="headerlink" title="前缀优化建图 例题"></a>前缀优化建图 例题</h3><p><del>快跑</del></p>
<h4 id="P6378-PA2010-Riddle"><a href="#P6378-PA2010-Riddle" class="headerlink" title="P6378 [PA2010] Riddle"></a><a href="https://www.luogu.com.cn/problem/P6378">P6378 [PA2010] Riddle</a></h4><blockquote>
<p>$n$ 点 $m$ 条边的有向图分成 $k$ 个部分，选择一些关键点使每一部分恰有一个关键点且每条边至少有一个端点是关键点</p>
</blockquote>
<p>由点仅有两种状态不难想到用 $\text{2-SAT}$ 解决</p>
<p>暴力的方法是，对于每一部分中的每个点，让选该点的状态向其他点不选的状态连边，由此有 $O(n^2)$</p>
<p>考虑在每一块中用<strong>前缀优化</strong></p>
<p>具体的，设 $pre_i$ 表示在当前块 $\{w_1,w_2,…,w_{\lim}\}$ 中，前 $x$ 个点 $\{w_1,w_2,….,i\}$ 中有一个关键点的状态</p>
<p>那么有建边：</p>
<ul>
<li>对于边 $(a_i,a_j)$ ，有 $inv_{a_i}\rightarrow a_j,inv_{a_j}\rightarrow a_i$ ，即，每条边只能有一个，一个不选时另一个必选</li>
<li>$a_i\rightarrow pre_{a_i},pre’_{a_i}\rightarrow a’_i$ ，即，若自己是关键点，则状态 $\{前面的点及自己\}$ 中有一个关键点</li>
<li>$pre_{a_{i-1}}\rightarrow pre_{a_i},pre’_{a_i}\rightarrow pre’_{a_{i-1}}$ ，即，若点 $a_i$ 前面的点已经有关键点，则状态 $\{前面的点及自己\}$ 一定有关键点</li>
<li>$a_i\rightarrow pre’_{a_{i-1}},pre_{a_{i-1}}\rightarrow a’_i$ ，即，若点 $a_i$ 是关键点，则块中其前面的一定不能有关键点</li>
</ul>
<p>由此能满足题目要求，边数降至 $O(n)$ 级别，<del>虽然多了2倍的常数</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">inv</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x+n;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x+<span class="number">2</span>*n;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,a,b;i&lt;=m;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b),<span class="built_in">add</span>(<span class="built_in">inv</span>(a),b),<span class="built_in">add</span>(<span class="built_in">inv</span>(b),a);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,w;i&lt;=k;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w);</span><br><span class="line">        <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=w;++j) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[j]),<span class="built_in">add</span>(a[j],<span class="built_in">pre</span>(a[j])),<span class="built_in">add</span>(<span class="built_in">pre</span>(<span class="built_in">inv</span>(a[j])),<span class="built_in">inv</span>(a[j]));</span><br><span class="line">        <span class="keyword">for</span>(rei j=<span class="number">2</span>;j&lt;=w;++j)&#123;<span class="comment">//这里从2开始</span></span><br><span class="line">            <span class="built_in">add</span>(<span class="built_in">pre</span>(a[j<span class="number">-1</span>]),<span class="built_in">pre</span>(a[j])),<span class="built_in">add</span>(<span class="built_in">pre</span>(<span class="built_in">inv</span>(a[j])),<span class="built_in">pre</span>(<span class="built_in">inv</span>(a[j<span class="number">-1</span>])));</span><br><span class="line">            <span class="built_in">add</span>(a[j],<span class="built_in">pre</span>(<span class="built_in">inv</span>(a[j<span class="number">-1</span>]))),<span class="built_in">add</span>(<span class="built_in">pre</span>(a[j<span class="number">-1</span>]),<span class="built_in">inv</span>(a[j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=(n&lt;&lt;<span class="number">2</span>);++i) <span class="keyword">if</span>(!low[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>(scc[i]==scc[ <span class="built_in">inv</span>(i) ] || scc[ <span class="built_in">pre</span>(i) ]==scc[ <span class="built_in">pre</span>(<span class="built_in">inv</span>(i)) ]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;NIE&quot;</span>),<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;TAK&quot;</span>);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CF1215F-Radio-Stations"><a href="#CF1215F-Radio-Stations" class="headerlink" title="CF1215F Radio Stations"></a><a href="https://www.luogu.com.cn/problem/solution/CF1215F">CF1215F Radio Stations</a></h4><blockquote>
<p>$n$ 个电台，第 $i$ 个波段在 $[l_i,r_i]$ ,在 $[1,m]$ 中选择主频 $f$ ，仅当 $f\in[l_r,r_i]$ 时电台 $i$ 可以使用。给定若干组限制 $(x,y)$ 表示电台 $x,y$ 至少启用一个/最多启动一个</p>
<p>求 $f$ 及构造方案</p>
</blockquote>
<p>对电台的若干限制显然，即：</p>
<ul>
<li>对于至少一个，有 $x’\rightarrow y,y’\rightarrow x$</li>
<li>对于最多一个，有 $x\rightarrow y’,y\rightarrow x’$</li>
</ul>
<p>再考虑如何确定主频 $f$ ：</p>
<p>对于区间 $[l_i,r_i]$ ,考虑用前缀，分别考虑区间 $[1,l_i-1],[1,r_i]$ ：</p>
<ul>
<li>$f\not\in [1,l_i-1]\ ,\ f\not\in [1,r_i]$ ，$i$ 不能启用</li>
<li>$f\not\in [1,l_i-1]\ ,\ f\in [1,r_i]$ ，$i$ 能启用</li>
<li>$f\in [1,l_i-1]\ ,\ f\in [1,r_i]$ ，$i$ 不能启用</li>
<li>$f\in [1,l_i-1]\ ,\ f\not\in [1,r_i]$ ， 不存在该情况</li>
</ul>
<p>设 $pre_i$ 表示有 $[f\leq l_i]$ ，那么有建边：</p>
<ul>
<li>$pre_i\rightarrow pre_{i+1} , pre’_{i+1}\rightarrow pre’_{i}$</li>
</ul>
<p>上面的 $4$ 种情况可以简化为一下 $3$ 个性质并用以建边：</p>
<ul>
<li>$i\rightarrow pre’_{l_i},i\rightarrow pre_{r_i+1}$ ，即，若电台 $i$ 启用则 $f\in[l_i,r_i]$</li>
<li>$pre_{l_i}\rightarrow i’$ ，即，若满足 $f\in[1,l_i-1]$ 则 $i$ 不能用</li>
<li>$pre_{r_i+1}’\rightarrow i’$ ，即，不满足 $f\in[1,r_i]$ 则 $i$ 不能用</li>
</ul>
<p>跑 $\text{2-SAT}$ ，然后枚举找主频</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[N&lt;&lt;<span class="number">1</span>],Next[N&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line"><span class="keyword">int</span> scc[N&lt;&lt;<span class="number">1</span>],low[N&lt;&lt;<span class="number">1</span>],scc_cnt,dfn_cnt;</span><br><span class="line"><span class="keyword">int</span> stk[N],top;</span><br><span class="line"><span class="keyword">int</span> n,m,all,lim1,lim2,l,r;</span><br><span class="line"><span class="keyword">int</span> ans[N],k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123; ver[++tot]=v,Next[tot]=head[u],head[u]=tot;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123; <span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v&gt;all ? v-all : v+all,u&gt;all ? u-all : u+all);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x+n;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">inv</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x+all;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    stk[++top]=x; low[x]=++dfn_cnt; rei ori=low[x];</span><br><span class="line">    <span class="keyword">for</span>(rei i=head[x];i;i=Next[i])&#123;</span><br><span class="line">        rei y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(!low[y]) <span class="built_in">tarjan</span>(y),low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!scc[y]) low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ori==low[x]) <span class="keyword">for</span>(++scc_cnt;scc[ stk[top] ]=scc_cnt,stk[top--]!=x;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;lim1,&amp;n,&amp;m,&amp;lim2); all=n+m;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,x,y;i&lt;=lim1;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y),<span class="built_in">insert</span>(<span class="built_in">inv</span>(x),y);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r); <span class="built_in">insert</span>(i,<span class="built_in">pre</span>(r));</span><br><span class="line">        <span class="keyword">if</span>(--l) <span class="built_in">insert</span>(i,<span class="built_in">pre</span>(<span class="built_in">inv</span>(l)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">add</span>(all&lt;&lt;<span class="number">1</span>,all);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;all-n;++i) <span class="built_in">insert</span>(<span class="built_in">pre</span>(i),<span class="built_in">pre</span>(i+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,x,y;i&lt;=lim2;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y),<span class="built_in">insert</span>(x,<span class="built_in">inv</span>(y));</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=(all&lt;&lt;<span class="number">1</span>);++i) <span class="keyword">if</span>(!low[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=all;++i) <span class="keyword">if</span>(scc[i]==scc[i+all]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>),<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>(scc[i]&lt;scc[i+all]) ans[++k]=i;</span><br><span class="line">    rei tmp=n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;scc[tmp]&gt;scc[tmp+all];++tmp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,k,tmp-n);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=k;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>,ans[i],i==k ? <span class="number">10</span> : <span class="number">32</span>);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CF587D-Duff-in-Mafia"><a href="#CF587D-Duff-in-Mafia" class="headerlink" title="CF587D Duff in Mafia"></a><a href="https://www.luogu.com.cn/problem/CF587D">CF587D Duff in Mafia</a></h4><blockquote>
<p>$n$ 点 $m$ 边无向图，每条边有颜色和权值，选出一些边使它们是一个匹配，剩下的边的每种颜色也是一个匹配。其中，匹配表示其中的任意两条边均没有公共点</p>
<p>最小化选出的边的权值最大值并输出方案</p>
</blockquote>
<p>对于最小化最大值，显然需要二分最大值 $MAX$ ，并不选择任何权值 $&gt;MAX$ 的边</p>
<p>考虑 $\text{2-SAT}$ 维护边是否选择，具体的，需要有：</p>
<ul>
<li>$i\rightarrow i’$ ，当且仅当边 $i$ 的权值大于二分值</li>
<li>对于任意点 $x$ 有 $lim$ 条满足条件的边，$i\rightarrow j’$ 其中 $i,j\in [1,lim],i\not ={j}$</li>
<li>对于任意点 $x$ 有 $lim$ 条相同颜色的边，$i’\rightarrow j$ ，其中 $i,j\in[1,lim],i\not ={j}$</li>
</ul>
<p>不难发现后两种情况的建图是 $O(m^2)$ 的复杂度，考虑用前缀优化，具体的：</p>
<p>设 $pre_i$ 表示对于当前节点的每一条边中，前 $i$ 条是否有一个被选，以第二种情况为例易得转移：</p>
<ul>
<li>$pre_{i-1}\rightarrow pre_i,pre’_i\rightarrow pre_{i-1}’$ 转移前缀</li>
<li>$i\rightarrow pre_i,pre’_i\rightarrow i’$ 当前元素更新前缀</li>
<li>$pre_{i-1}\rightarrow i’,i\rightarrow pre’_{i-1}$ 前缀约束当前元素</li>
</ul>
<p>然而在码的时候我才意识到，对于已经建好的图，每次二分的时候第一种是重新建边的，而二三种的边不需要重新连接，这对邻接表建图并不友好，只能换成 <code>vector</code> 了qwq</p>
<p>然后由于边的编号问题不能直接加上常数得到 $pre$ ,所以换用 <code>all</code> 计数来解决</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LIM=<span class="number">15e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="comment">// int head[N],ver[N&lt;&lt;1],Next[N&lt;&lt;1],tot;</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; mp[N],g[N];</span><br><span class="line"><span class="keyword">int</span> low[N&lt;&lt;<span class="number">1</span>],scc[N&lt;&lt;<span class="number">1</span>],scc_cnt,dfn_cnt,stk[N],top;</span><br><span class="line"><span class="keyword">int</span> lim,a[N]; <span class="keyword">int</span> l,r=<span class="number">1e9</span>,mid;</span><br><span class="line"><span class="keyword">int</span> n,m,col[N],t[N],all;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inline void add(int u,int v)&#123; ver[++tot]=v,Next[tot]=head[u],head[u]=tot;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123; g[u].<span class="built_in">push_back</span>(v); g[v&gt;LIM ? v-LIM : v+LIM].<span class="built_in">push_back</span>(u&gt;LIM ? u-LIM : u+LIM);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">return</span> col[x]&lt;col[y];&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">inv</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x+LIM;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	low[x]=++dfn_cnt; stk[++top]=x; rei ori=low[x];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> y:g[x])&#123;</span><br><span class="line">		<span class="keyword">if</span>(!low[y]) <span class="built_in">tarjan</span>(y),low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(!scc[y]) low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(low[x]==ori) <span class="keyword">for</span>(++scc_cnt;scc[ stk[top] ]=scc_cnt,stk[top--]!=x;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> MAX)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(low,<span class="number">0</span>,<span class="keyword">sizeof</span> low); <span class="built_in">memset</span>(scc,<span class="number">0</span>,<span class="keyword">sizeof</span> scc); dfn_cnt=scc_cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=m;++i) <span class="keyword">if</span>(t[i]&gt;MAX) g[i].<span class="built_in">push_back</span>( <span class="built_in">inv</span>(i) );</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=all;++i)&#123; <span class="keyword">if</span>(!low[i]) <span class="built_in">tarjan</span>(i); <span class="keyword">if</span>(!low[ <span class="built_in">inv</span>(i) ]) <span class="built_in">tarjan</span>( <span class="built_in">inv</span>(i) );&#125;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=m;++i) <span class="keyword">if</span>(t[i]&gt;MAX) g[i].<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=all;++i) <span class="keyword">if</span>(scc[i]==scc[ <span class="built_in">inv</span>(i) ]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m),all=m;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>,u,v;i&lt;=m;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;col[i],&amp;t[i]),mp[u].<span class="built_in">push_back</span>(i),mp[v].<span class="built_in">push_back</span>(i);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		lim=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> x:mp[i]) a[++lim]=x;<span class="comment">//点i的每一条边</span></span><br><span class="line">		<span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+lim,cmp); a[lim+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=lim;++j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j&gt;<span class="number">1</span>) <span class="built_in">insert</span>(a[j],<span class="built_in">inv</span>(all)),<span class="built_in">insert</span>(all,all+<span class="number">1</span>);</span><br><span class="line">			<span class="built_in">insert</span>(a[j],++all);</span><br><span class="line">			<span class="keyword">if</span>(col[ a[j] ]==col[ a[j<span class="number">-1</span>] ])&#123;</span><br><span class="line">				<span class="keyword">if</span>(col[ a[j] ]==col[ a[j+<span class="number">1</span>] ]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>),<span class="number">0</span>;</span><br><span class="line">				<span class="built_in">insert</span>(<span class="built_in">inv</span>(a[j<span class="number">-1</span>]),a[j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">check</span>(r)) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>),<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">		rei mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">check</span>(mid) ? r=mid<span class="number">-1</span> : l=mid+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">check</span>(++r); <span class="built_in">printf</span>(<span class="string">&quot;Yes\n%d &quot;</span>,r);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=m;++i) <span class="keyword">if</span>(scc[i]&lt;scc[ <span class="built_in">inv</span>(i) ]) stk[++top]=i;<span class="comment">//废物利用了属于是</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,top);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=top;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>,stk[i],i==top ? <span class="number">10</span> : <span class="number">32</span>);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="P6965-NEERC2016-Binary-Code"><a href="#P6965-NEERC2016-Binary-Code" class="headerlink" title="P6965 [NEERC2016]Binary Code"></a><a href="https://www.luogu.com.cn/problem/P6965">P6965 [NEERC2016]Binary Code</a></h4><blockquote>
<p>$n$ 个 <code>01</code> 串，每个串至多有一位未知，求是否存在一种方案使任意一个字符串不是其他任意字符串的前缀，并输出具体方案</p>
</blockquote>
<p><del>为什么这题是紫的啊</del></p>
<p><del>一定是我太菜了</del></p>
<p>仍然可以由至多一位未知想到 $\text{2-SAT}$ ，而对于 <code>01</code> 串及前缀想到用 $\text{trie}$</p>
<p>那么将未知的拆成两个字符串，用 $\text{trie}$ 树维护并更新字符串之间的 <code>true/false</code> 关系</p>
<p>具体的：</p>
<p>对于没有 <code>?</code> 的字符串，一定能选到自己，即，</p>
<ul>
<li>$i’\rightarrow i$</li>
</ul>
<p>由题可以得到：<strong>$\text{trie}$ 树上任意一点到根节点的链上至多有一点被选中</strong>，对此用前缀优化，即</p>
<ul>
<li>$pre_{fa_i}\rightarrow pre_i$</li>
<li>$i\rightarrow pre’_{fa_i}$ ，即，前面没有</li>
<li>$i\rightarrow pre_i$ ，即，当前更新前缀</li>
</ul>
<p>再考虑对于每个结束点，只能有一个字符串在此结束，设 $loc[node]$ 表示每个终点位于点 $node$ 的字符串的编号，那么有：</p>
<ul>
<li>$pre_{i-1}\rightarrow pre_i$</li>
<li>$loc_{node,i}\rightarrow pre’_{i-1}$</li>
<li>$loc_{node,i}\rightarrow pre_i$</li>
</ul>
<p><del>含义显然</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">6e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[N&lt;&lt;<span class="number">1</span>],Next[N&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line"><span class="keyword">int</span> low[N&lt;&lt;<span class="number">1</span>],scc[N&lt;&lt;<span class="number">1</span>],stk[N&lt;&lt;<span class="number">1</span>],dfn_cnt,scc_cnt,top;</span><br><span class="line"><span class="keyword">int</span> ch[N][<span class="number">2</span>],cnt,fa[N];</span><br><span class="line">string s[N];</span><br><span class="line"><span class="keyword">int</span> wh[N],pos[N],n,lim;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; loc[N];<span class="comment">//对于点x，字符串终点在x的字符串的编号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123; ver[++tot]=v,Next[tot]=head[u],head[u]=tot; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123; <span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v^<span class="number">1</span>,u^<span class="number">1</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">tru</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x&lt;&lt;<span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">inv</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x+lim;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    low[x]=++dfn_cnt; stk[++top]=x; rei ori=low[x];</span><br><span class="line">    <span class="keyword">for</span>(rei i=head[x];i;i=Next[i])&#123;</span><br><span class="line">        rei y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(!low[y]) <span class="built_in">tarjan</span>(y),low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!scc[y]) low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low[x]==ori) <span class="keyword">for</span>(++scc_cnt; scc[ stk[top] ]=scc_cnt,stk[top--]!=x;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">trie_ins</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">    rei now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;s[i];++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!ch[now][ s[i]-<span class="string">&#x27;0&#x27;</span> ]) fa[ ch[now][ s[i]-<span class="string">&#x27;0&#x27;</span> ]=++cnt ]=now;</span><br><span class="line">        now=ch[now][ s[i]-<span class="string">&#x27;0&#x27;</span> ];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n); lim=<span class="built_in">inv</span>(n)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;s[i]; wh[i]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(rei j=<span class="number">0</span>,llim=s[i].<span class="built_in">size</span>()<span class="number">-1</span>;j&lt;=llim;++j) <span class="keyword">if</span>(s[i][j]==<span class="string">&#x27;?&#x27;</span>) wh[i]=j;</span><br><span class="line">        <span class="keyword">if</span>(wh[i]==<span class="number">-1</span>)&#123;</span><br><span class="line">            pos[ <span class="built_in">tru</span>(i) ]=pos[ <span class="built_in">inv</span>(i) ]=<span class="built_in">trie_ins</span>(s[i].<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="built_in">add</span>(<span class="built_in">inv</span>(i),<span class="built_in">tru</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            s[i][ wh[i] ]=<span class="string">&#x27;0&#x27;</span>,pos[ <span class="built_in">tru</span>(i) ]=<span class="built_in">trie_ins</span>(s[i].<span class="built_in">c_str</span>());</span><br><span class="line">            s[i][ wh[i] ]=<span class="string">&#x27;1&#x27;</span>,pos[ <span class="built_in">inv</span>(i) ]=<span class="built_in">trie_ins</span>(s[i].<span class="built_in">c_str</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=cnt;++i) <span class="built_in">insert</span>( <span class="built_in">pre</span>(<span class="built_in">tru</span>(fa[i])) , <span class="built_in">pre</span>(<span class="built_in">tru</span>(i)) );</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(wh[i]==<span class="number">-1</span>)&#123;</span><br><span class="line">            rei pp=pos[ <span class="built_in">tru</span>(i) ];</span><br><span class="line">            loc[pp].<span class="built_in">push_back</span>(<span class="built_in">tru</span>(i));</span><br><span class="line">            <span class="built_in">insert</span>(<span class="built_in">tru</span>(i),<span class="built_in">pre</span>( <span class="built_in">inv</span>( fa[pp] ) ));</span><br><span class="line">            <span class="built_in">insert</span>(<span class="built_in">tru</span>(i),<span class="built_in">pre</span>( <span class="built_in">tru</span>(pp) ));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            rei pp1=pos[ <span class="built_in">tru</span>(i) ],pp2=pos[ <span class="built_in">inv</span>(i) ];</span><br><span class="line">            loc[pp1].<span class="built_in">push_back</span>(<span class="built_in">tru</span>(i));</span><br><span class="line">            <span class="built_in">insert</span>(<span class="built_in">tru</span>(i),<span class="built_in">pre</span>( <span class="built_in">inv</span>( fa[pp1] ) ));</span><br><span class="line">            <span class="built_in">insert</span>(<span class="built_in">tru</span>(i),<span class="built_in">pre</span>( <span class="built_in">tru</span>(pp1) ));</span><br><span class="line">            loc[pp2].<span class="built_in">push_back</span>(<span class="built_in">inv</span>(i));</span><br><span class="line">            <span class="built_in">insert</span>(<span class="built_in">inv</span>(i),<span class="built_in">pre</span>( <span class="built_in">inv</span>( fa[pp2] ) ));</span><br><span class="line">            <span class="built_in">insert</span>(<span class="built_in">inv</span>(i),<span class="built_in">pre</span>( <span class="built_in">tru</span>(pp2) ));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lim+=<span class="built_in">inv</span>(cnt)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=cnt;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(loc[i].<span class="built_in">empty</span>()) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(rei j=<span class="number">0</span>,llim=loc[i].<span class="built_in">size</span>()<span class="number">-1</span>;j&lt;=llim;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j)&#123;</span><br><span class="line">                <span class="built_in">insert</span>(<span class="built_in">pre</span>( <span class="built_in">tru</span>(j<span class="number">-1</span>) ),<span class="built_in">pre</span>( <span class="built_in">tru</span>(j) ));</span><br><span class="line">                <span class="built_in">insert</span>(loc[i][j],<span class="built_in">pre</span>( <span class="built_in">inv</span>(j<span class="number">-1</span>) ));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">insert</span>(loc[i][j],<span class="built_in">pre</span>( <span class="built_in">tru</span>(j) ));</span><br><span class="line">        &#125;</span><br><span class="line">        lim+=<span class="built_in">tru</span>(loc[i].<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;=lim;++i) <span class="keyword">if</span>(!low[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>(scc[ <span class="built_in">tru</span>(i) ]==scc[ <span class="built_in">inv</span>(i) ]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>),<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(wh[i]!=<span class="number">-1</span>) s[i][ wh[i] ]=scc[ <span class="built_in">tru</span>(i) ]&lt;scc[ <span class="built_in">inv</span>(i) ] ? <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        cout&lt;&lt;s[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>2-sat</tag>
      </tags>
  </entry>
  <entry>
    <title>burnside引理与polya定理</title>
    <url>/2021/11/01/burnside%E5%BC%95%E7%90%86%E4%B8%8Epolya%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<h2 id="text-Polya-定理"><a href="#text-Polya-定理" class="headerlink" title="$\text{Pólya 定理}$"></a>$\text{Pólya 定理}$</h2><h3 id="置换与群"><a href="#置换与群" class="headerlink" title="置换与群"></a>置换与群</h3><blockquote>
<p>给定一个长度为 $n$ 的环用 $k$ 种颜色染色，有多少种旋转意义下不同的方案</p>
<p>给一个正方形用 $k$ 种颜色染色，有多少种旋转意义下不同的方案</p>
</blockquote>
<p>可以统一表达为：给定一个方案集合 $A$ 和 一个变换集合 $S$ ，两个方案等价，如果存在一系列变换使其中一个方案变为另一个</p>
<p>对于这种<strong>本质不同</strong>的计数问题，通常用置换群来解决</p>
<h4 id="置换的定义"><a href="#置换的定义" class="headerlink" title="置换的定义"></a>置换的定义</h4><p>置换使一个双射 $f:\{1,2,..,n\}\rightarrow \{1,2,…,n\}$ 表示将 $i$ 替换为 $f(i)$ ,用记号:</p>
<script type="math/tex; mode=display">\sigma=\begin{pmatrix}
1 & 2 & 3 & ... & n \\
f(1) & f(2) & f(3) & ... & f(n) \\
\end{pmatrix}=(f_1,f_2,f_3,...,f_n)</script><p>置换也有<strong>合成</strong>运算，也称为置换的乘法，即：</p>
<script type="math/tex; mode=display">\sigma_1\sigma_2=\begin{pmatrix}
i \\ f_1(f_2(i))
\end{pmatrix}</script><h4 id="置换的性质"><a href="#置换的性质" class="headerlink" title="置换的性质"></a>置换的性质</h4><p>循环置换是特殊的置换，具体的，记：</p>
<script type="math/tex; mode=display">\begin{pmatrix}
i_1 & i_2 & ... & i_{n-1} & i_n \\
i_2 & i_3 & ... & i_n& i_1 \\
\end{pmatrix}
=(i_1,i_2,...,i_n)</script><p>两个循环置换中若没有相同元素则称它们是不相交的</p>
<p>有定理：<strong>任意置换都可以被分解称不相交循环的积</strong></p>
<ul>
<li><p>证明：</p>
<p>  将元素看作点，映射关系为有向边，每个点的出入度都为 $1$</p>
<p>  那么所得的图一定是若干环的集合，一个环即是一个循环置换</p>
</li>
</ul>
<h4 id="置换乘法的性质"><a href="#置换乘法的性质" class="headerlink" title="置换乘法的性质"></a>置换乘法的性质</h4><ul>
<li>结合律显然</li>
<li>单位元：有单位置换 $\sigma_1=\binom{i}{i}$</li>
<li>可逆性：对任意置换都能找到另一置换使其乘积为单位元</li>
<li>消去律：即 $\sigma_1 x=\sigma_1 y\Rightarrow x=y$</li>
</ul>
<h4 id="对换与置换的奇偶性"><a href="#对换与置换的奇偶性" class="headerlink" title="对换与置换的奇偶性"></a>对换与置换的奇偶性</h4><p>对换即是一个 $2$ 轮换，一个循环可以被拆成 $\text{环长-1}$ 个对换</p>
<p>一个 $n$ 轮换可以被拆成 $n-1$ 个对换的积：</p>
<script type="math/tex; mode=display">\begin{pmatrix}1&2&3 \\ 2&3&1\end{pmatrix}
=\begin{pmatrix}1&2 \\ 2&1\end{pmatrix}
\begin{pmatrix}1&3 \\ 3&1\end{pmatrix}</script><p>那么对于同一个置换，其有不同的对换分解，但各分解中奇偶性必然相同</p>
<p>定义置换的奇偶性为 $(-1)^{N(\sigma)}$ ，其中 $N(\sigma)$ 为置换能分解成的对换个数</p>
<h4 id="群"><a href="#群" class="headerlink" title="群"></a>群</h4><p>一个非空集合 $S$ 和定义在 $S$ 上的二元代数运算 $\circ$ 是群，当且仅当满足：</p>
<ul>
<li>封闭性：二元代数运算得到的结果仍在 $S$ 中</li>
<li>结合律</li>
<li>单位元，且单位元唯一</li>
<li>每个元素均有逆元，且每个元素的逆元唯一</li>
</ul>
<p>此时再去考虑开头的几个旋转变换：</p>
<ul>
<li><p>圆环旋转变换构成置换群</p>
<ul>
<li>运算封闭：旋转 $i^{\circ}$ 与旋转 $j^{\circ}$ 合成，即是旋转 $(i+j)^{\circ}$ 的变换</li>
<li>结合律显然</li>
<li>旋转 $0^{\circ}$ 即是单位元</li>
<li>旋转 $i^{\circ}$ 与旋转 $(360-i)^{\circ}$ 互为逆元</li>
</ul>
</li>
<li><p>正方形旋转变换构成置换群</p>
<ul>
<li>相当于旋转 $(90k)^{\circ}$，易证</li>
</ul>
</li>
</ul>
<h4 id="置换群的性质"><a href="#置换群的性质" class="headerlink" title="置换群的性质"></a>置换群的性质</h4><p><strong>性质：任何一个存在奇置换的置换群，奇置换与偶置换数量相等</strong></p>
<ul>
<li>证明：<ul>
<li>若置换群 $G$ 存在至少一个奇置换 $\sigma_0$ ,用这个奇置换左乘所有的偶置换，得到互异的奇置换，那么奇置换的个数不少于偶置换的个数</li>
<li>相反的，这个奇置换左乘所有的奇置换，得到互异的偶置换，因此奇置换和偶置换数量相等</li>
</ul>
</li>
</ul>
<h3 id="text-Burnside-引理"><a href="#text-Burnside-引理" class="headerlink" title="$\text{Burnside}$ 引理"></a>$\text{Burnside}$ 引理</h3><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><blockquote>
<p>对 $n$ 个对象 $v_1,v_2,…,v_n$ 按某种原则染上不同颜色，求本质不同方案数</p>
</blockquote>
<p>给定置换群 $G$ ，两个方案相同当且仅当存在一个 $\sigma\in G$ 使按 $\sigma$ 对节点做变换染色方案不变</p>
<p>不妨将染色方案看成集合：</p>
<script type="math/tex; mode=display">C=\{c=(c_1,c_2,..,c_n) | c_i表示颜色\}</script><p>定义置换与染色方案之间的乘法，表示对染色方案进行变换：</p>
<script type="math/tex; mode=display">\sigma \circ c=(c_{\sigma_1},c_{\sigma_2},...,c_{\sigma_n})</script><p>两个染色方案 $u,v\in C$ 相同，当且仅当存在 $\sigma\in G$ 使：</p>
<script type="math/tex; mode=display">\sigma\circ u=\sigma\circ v</script><h4 id="稳定核"><a href="#稳定核" class="headerlink" title="稳定核"></a>稳定核</h4><p>考虑将染色方案 $c_1$ 变换到 $c_2$ 的置换</p>
<p>若有 $\sigma_1\circ c_1=c_2,\sigma_2\circ c_1=c_2$ 则一定有 $(\sigma_2^{-1}\sigma_1) \circ c_1=c_1$</p>
<p>那么此时，所有能使 $\sigma\circ c=c$ 的置换 $\sigma$ 构成一个子群，检验：</p>
<ul>
<li>运算封闭：若 $\sigma_1,\sigma_2$ 均使 $c$ 不变，则 $\sigma_1\sigma_2$ 也使其不变</li>
<li>单位元显然存在</li>
<li>逆元：$\sigma_1\circ c=c$ 两边左乘 $\sigma^{-1}$ 即可得 $\sigma^{-1}\circ c=c$</li>
</ul>
<p>称这个子群 $\text{ker} \ c$ 为 $c$ 的稳定核</p>
<h4 id="陪集分解"><a href="#陪集分解" class="headerlink" title="陪集分解"></a>陪集分解</h4><p>对于子群 $c_1$ ,$\sigma_1\approx \sigma_2 \Leftrightarrow \sigma_2^{-1}\sigma_1\in \text{ker} \ c_1$ 是一个<strong>等价关系</strong></p>
<p>依靠这个等价关系能将 $C$ 集合划分出若干个等价类，其满足：</p>
<ul>
<li>自反性：单位元在子群中</li>
<li>传递性：若 $\sigma_3^{-1}\sigma_2\in \text{ker} \ c,\sigma_2^{-1}\sigma_1\in \text{ker} \ c$  ，由于运算封闭，有 $\sigma_3^{-1}\sigma_1\in \text{ker} \ c$</li>
<li>对称性：由于 $\text{ker}\ c$ 是子群， $\sigma_2^{-1}\sigma_1$ 的逆元 $\sigma_1^{-1}\sigma_2$ 也在该子群中</li>
</ul>
<p>每个划分块为子群 $c_1$ 的一个陪集</p>
<h4 id="陪集分解的性质"><a href="#陪集分解的性质" class="headerlink" title="陪集分解的性质"></a>陪集分解的性质</h4><p>考虑 $\text{ker} \ c$ 的每一个陪集 $B$ 的大小</p>
<p>若 $\sigma_1,\sigma_2\in B$ ，则一定有 $x\in \text{ker} \ c$ ,满足 $\sigma_2^{-1}\sigma_1=x\Leftrightarrow \sigma_1=\sigma_2\circ x$</p>
<p>那么用 $\sigma_2$ 右乘 $\text{ker} \ c$ 中的所有元素，得到 $|\text{ker} \ c|$ 个互异的元素</p>
<p>那么这恰好就是 $B$ ，即 $|B|=|\text{ker} \ c|$</p>
<p>那么，将 $c$ 变成 $c_2$ 的置换恰有 $|\text{ker} \ c|$ 种，那么与 $c$ 本质相同的染色方案数恰好为 $\displaystyle{\frac{|G|}{|\text{ker} \ c|}}$</p>
<p><del>我在写什么？</del></p>
<p>在写 $\text{burnside}$ 引理之前，看一下刚刚我写了什么</p>
<p>有染色方案 $C$，置换群 $\sigma$ ，其中染色方案 $c_1$ 是 $C$ 的一个子集，$\text{ker} \ c_1$ 是置换群 $\sigma$ 的一个子群，也是 $c_1$ 的稳定核，陪集 $B$ 是 $\text{ker} \ c$ 的一个子群</p>
<h4 id="text-burnside-引理"><a href="#text-burnside-引理" class="headerlink" title="$\text{burnside}$ 引理"></a>$\text{burnside}$ 引理</h4><p>每种颜色对于等价类个数的贡献，是其所在等价类的倒数，那么等价类的个数就是</p>
<script type="math/tex; mode=display">\sum_{c\in C}\frac{|\text{ker} \ c|}{|G|}=\frac{1}{|G|} \sum_{c\in C} |\text{ker} \ c|</script><p>那么，<strong>枚举染色方案对不动置换求和，恰是枚举置换方案并对染色方案求和</strong></p>
<p>设 $G$ 为置换群，$X(\sigma)$ 是在置换 $\sigma$ 下不变的染色方案数，那么本质不同的染色方案为</p>
<script type="math/tex; mode=display">|X/G|=\frac{1}{|G|}\sum_{\sigma\in G}|X(\sigma)|</script><h3 id="text-Polya-定理-1"><a href="#text-Polya-定理-1" class="headerlink" title="$\text{Pólya}$ 定理"></a>$\text{Pólya}$ 定理</h3><p>考虑更快的使用 $\text{burnside}$</p>
<p>对于求本质不同的问题中(即使用 $\text{burnside}$ 时)，要求不动点的数量</p>
<p>定义 $c(\sigma)$ 表示置换 $\sigma$ 的轮换数，那么有：</p>
<script type="math/tex; mode=display">|X/G|=\frac{1}{|G|}\sum_{\sigma\in G} m^{c(\sigma)}</script><p>$m$ 为可用颜色数</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><blockquote>
<p>两种颜色给 $2\times 2$ 正方形染色，本质不同的着色数</p>
</blockquote>
<p>考虑每个置换：</p>
<ul>
<li>旋转 $0^{\circ}$ ：不动的染色方案为 $2^4$ 种：显然任意染色即可</li>
<li>旋转 $90^{\circ}$ ：不动的染色方案为 $2$ 种：只有全染和全不染</li>
<li>旋转 $180^{\circ}$ ：不动的染色方案为 $2^2$ 种：全染全不染+染对角线</li>
<li>旋转 $270^{\circ}$ ：不动的染色方案为 $2$ 种：只有全染全不染</li>
</ul>
<p>那么共 $\frac{16+2+4+2}{4}=6$ 种</p>
<h3 id="P4980-【模板】Polya-定理"><a href="#P4980-【模板】Polya-定理" class="headerlink" title="P4980 【模板】Pólya 定理"></a><a href="https://www.luogu.com.cn/problem/P4980">P4980 【模板】Pólya 定理</a></h3><blockquote>
<p>长度为 $n$ 的圆环用 $m$ 种颜色染色，求旋转意义下本质不同方案数</p>
</blockquote>
<p>旋转对环的影响就相当于对 $n$ 个珠子进行一次 $\{f_1,f_2,…,f_n\}$ 的置换，所有的旋转方案构成大小为 $n$ 的置换群</p>
<p>根据 $\text{burnside}$ 引理，需要枚举每个置换，找其不动点的个数</p>
<ul>
<li><p>在置换情况下找染色后不动的点</p>
<p>此题中，将每种置换看成旋转 $x$ 个位置，该置换下不动的染色方案数，相当于对于每个 $i$ 都有 $c_i=(c_i+x-1)\ \text{mod}\  n+1$ ，$c_i$ 表示不旋转情况下第 $i$ 个珠子的染色情况</p>
</li>
<li><p>相同轮换内染同种颜色</p>
<p>将强制相同的珠子并为一个集合，相当于每个集合强制染同一种颜色，即，将这个置换分解为多个轮换，属于同一个轮换的染成同种颜色</p>
</li>
<li><p>一个轮换看成一个集合，所有集合组成新环，在新环上进行不考虑同构的染色</p>
<p>由线性同余方程可得，如此划分共有 $\gcd(x,n)$ 中集合，每个集合有 $\frac{n}{\gcd(x,n)}$ ，其中第 $i$ 个珠子属于第 $(i-1)\ \text{mod}\ \gcd(x,n)+1$ 个集合</p>
<p>那么此时，在第 $i$ 个集合中的珠子在原圆环上相邻的两个点分别属于第 $i-1,i+1$ 个集合，特别的，集合 $1$ 与 $\gcd(n,x)$ 也看做是相邻的</p>
<p>那么对相邻珠子染色的限制可以转移为<strong>对相邻集合的染色限制</strong>，那么不妨<strong>将这 $\gcd(n,x)$ 个集合看成一个长度 $\gcd(n,x)$ 的新环</strong></p>
</li>
</ul>
<p>那么答案就是：</p>
<script type="math/tex; mode=display">\frac{1}{n}\sum_{x=1}^{x=n} k^{\gcd(n,x)}</script><p><strong>枚举的 $d$ 不考虑循环同构，其实是枚举集合构成的环的大小</strong></p>
<p>化简后有：</p>
<script type="math/tex; mode=display">\begin{aligned}
原式&=\frac{1}{n}\sum_{d\mid n} m^d\sum_{d\mid x} \left[\gcd\left(\frac{n}{d},\frac{x}{d}\right)=1 \right] \\
&=\frac{1}{n}\sum_{d\mid n}m^d\sum_{k\leq \frac{n}{d}} \left[\gcd\left(\frac{n}{d},k\right)=1 \right] \\
&=\frac{1}{n}\sum_{d\mid n}m^d\varphi\left(\frac{n}{d} \right)
\end{aligned}</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fix</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123; x&gt;=mod ? x-=mod : <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(ll x,<span class="keyword">int</span> y,ll res=<span class="number">1</span>)</span></span>&#123; <span class="keyword">while</span>(y)&#123; <span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=res*x%mod; y&gt;&gt;=<span class="number">1</span>; x=x*x%mod;&#125; <span class="keyword">return</span> res;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_phi</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	rei res=x,tmp=x;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">2</span>;i*i&lt;=tmp;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!(x%i))&#123;</span><br><span class="line">			res=(ll) res*(i<span class="number">-1</span>)/i%mod;</span><br><span class="line">			<span class="keyword">while</span>(!(x%i)) x/=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;<span class="number">1</span>) res=(ll) res*(x<span class="number">-1</span>)/x%mod;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	rei T; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n); ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(rei i=<span class="number">1</span>;i*i&lt;=n;++i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(n%i) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">fix</span>(ans+=(ll) <span class="built_in">qpow</span>(n,i)*<span class="built_in">get_phi</span>(n/i)%mod);</span><br><span class="line">			<span class="keyword">if</span>(i*i!=n) <span class="built_in">fix</span>(ans+=(ll) <span class="built_in">qpow</span>(n,n/i)*<span class="built_in">get_phi</span>(i)%mod);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(ll) ans*<span class="built_in">qpow</span>(n,mod<span class="number">-2</span>)%mod);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P4916-MtOI2018-魔力环"><a href="#P4916-MtOI2018-魔力环" class="headerlink" title="P4916 [MtOI2018]魔力环"></a><a href="https://www.luogu.com.cn/problem/P4916">P4916 [MtOI2018]魔力环</a></h3><blockquote>
<p>$m$ 个黑珠子和 $n-m$ 个白珠子串成环，满足环上不会出现一段长度超过 $k$ 的连续黑珠子，求旋转环不相同的方案数</p>
</blockquote>
<p>设 $f(n,m)$ 表示 $m$ 个黑珠子和 $n-m$ 个白珠子串成一个环的方案数</p>
<p>那么套路的得答案为：</p>
<script type="math/tex; mode=display">\frac{1}{n}\sum_{d\mid n}\left[m\mid \frac{n}{d} \right] f\left(d,\frac{m}{\frac{n}{d}}\right)\varphi\left(\frac{n}{d} \right)</script><p>显然 $\displaystyle{\frac{m}{\frac{n}{d}}}$ 是 $m$ 在环中存在的个数 <del>这个很难描述</del></p>
<p>考虑求 $f(n,m)$ ：<strong>断环为链</strong></p>
<p>特殊的：当 $m\leq k$ 时 $f(n,m)=\binom{n}{m}$ ，即黑珠子任意放</p>
<p>处理环的特殊情况：枚举第一个白珠左边的黑珠数量与最后一个白珠右边的黑珠数量之和 $i$ ，显然有 $0\leq i\leq k$ ，对每个 $i$ ，有 $i+1$ 中摆放黑珠的方法</p>
<p>剩下的部分就可以被看作链上问题：即，将 $m-i$ 个黑珠插进 $n-m$ 个白珠的间隙； 转化为将 $m-i$ 个黑珠分成 $n-m-1$ 段，且每段的长度 $\leq k$ 的方案数</p>
<p>设 $g(n,m)$ 表示 $n$ 个珠子分成 $m$ 段，每段 $\leq k$ 的方案数，通过容斥，枚举有 $i$ 段的长度超过 $k$ ，得：</p>
<script type="math/tex; mode=display">g(n,m)=\sum_{i=0}^{\min\left(m,\left\lfloor\frac{n}{k+1} \right\rfloor\right)} (-1)^i \binom{m}{i}\binom{n-i*(k+1)+m-1}{m-1}</script><p>那么就能有：</p>
<script type="math/tex; mode=display">f(n,m)=
\begin{cases}
\binom{n}{m} &\text{ $m\leq k$ } \\
\sum_{i=0}^k g(m-i,n-m-1) &\text{ $m>k$ } \\
\end{cases}</script><p>$f$ 带回原式即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k,ans;</span><br><span class="line"><span class="keyword">int</span> phi[N],fac[N],inv[N],facinv[N];</span><br><span class="line"><span class="keyword">int</span> sie[N],prime[N],cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fix</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123; x&gt;=mod ? x-=mod : <span class="number">0</span>; x&lt;<span class="number">0</span> ? x+=mod : <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123; <span class="keyword">if</span>(n&lt;m || n&lt;<span class="number">0</span> || m&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">return</span> (ll) fac[n]*facinv[m]%mod *facinv[n-m]%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fac[<span class="number">0</span>]=facinv[<span class="number">0</span>]=inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&gt;<span class="number">1</span>) inv[i]=(ll) inv[mod%i]*(mod-mod/i)%mod;</span><br><span class="line">		fac[i]=(ll) fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">		facinv[i]=(ll) facinv[i<span class="number">-1</span>]*inv[i]%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	phi[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!sie[i]) prime[++cnt]=i,phi[i]=i<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=cnt &amp;&amp; (ll) prime[j]*i&lt;=n;++j)&#123;</span><br><span class="line">			rei x=prime[j]*i;</span><br><span class="line">			sie[x]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(!(i%prime[j]))&#123; phi[x]=phi[i]*prime[j]; <span class="keyword">break</span>;&#125;</span><br><span class="line">			<span class="keyword">else</span> phi[x]=phi[i]*(prime[j]<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_g</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">	rei res=<span class="number">0</span>,lim=<span class="built_in">min</span>(m,n/(k+<span class="number">1</span>));</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;=lim;++i)&#123;</span><br><span class="line">		rei tmp=(ll) <span class="built_in">get_C</span>(m,i)*<span class="built_in">get_C</span>(n-i*(k+<span class="number">1</span>)+m<span class="number">-1</span>,m<span class="number">-1</span>)%mod;</span><br><span class="line">		<span class="built_in">fix</span>(res+=(ll) tmp*(i&amp;<span class="number">1</span> ? mod<span class="number">-1</span> : <span class="number">1</span>)%mod);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_f</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(m&lt;=k) <span class="keyword">return</span> <span class="built_in">get_C</span>(n,m);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(n==m+<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	rei res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>,tmp=n-m<span class="number">-1</span>;i&lt;=k;++i) <span class="built_in">fix</span>(res+=(ll) (i+<span class="number">1</span>)*<span class="built_in">get_g</span>(m-i,tmp)%mod);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">	<span class="keyword">if</span>(n==m) <span class="keyword">return</span> <span class="built_in">puts</span>(k&gt;=n ? <span class="string">&quot;1&quot;</span> : <span class="string">&quot;0&quot;</span>),<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="keyword">for</span>(rei d=<span class="number">1</span>;d&lt;=n;++d) <span class="keyword">if</span>(!(n%d) &amp;&amp; !(m%(n/d)))</span><br><span class="line">		<span class="built_in">fix</span>(ans+=(ll) <span class="built_in">get_f</span>(d,m/(n/d))*phi[n/d]%mod);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(ll) ans*inv[n]%mod);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P3307-SDOI2013-项链"><a href="#P3307-SDOI2013-项链" class="headerlink" title="P3307 [SDOI2013]项链"></a><a href="https://www.luogu.com.cn/problem/P3307">P3307 [SDOI2013]项链</a></h3><blockquote>
<p>$n$ 个珠子串成一个环，每个珠子是一个正三棱柱，三个侧面刻有数字，每个数字 $x$ 满足 $1\leq x\leq a$ ，珠子上三个数字 $\gcd=1$ 。两个珠子相同当且仅当三棱柱通过旋转<strong>或</strong>翻转能使对应面数字相同，相邻两个珠子必须不同，</p>
<p>若两个项链能通过旋转变成一样的则认为两个项链相同，求不同的项链个数</p>
</blockquote>
<p>题中出现了两个本质不同：本质不同的珠子与 $\gcd$ 有关，用莫反解；本质不同的项链与旋转有关，用 $\text{burnside}$</p>
<ul>
<li><p>先考虑珠子</p>
<p>由 $\text{burnside}$ 引理：珠子的置换群共有 $6$ 个，每个置换下的不动点数就是将置换分解为 $k$ 个轮换后，最大公约数为 $1$ 的有序 $k$ 元组数量</p>
<p>置换群的方案即是：旋转 $0/1/2$ 格，按照第 $0/1/2$ 格翻转，每个置换的轮换数分别为 $3,1,1,2,2,2$</p>
<p>设 $S_i$ 表示有序 $i$ 元组的数量，那么珠子的个数即为</p>
<script type="math/tex; mode=display">\frac{2\times S_1+3\times S_2+S_3}{6}</script><p>显然 $S_1$ 只有一个 $(1,1,1)$</p>
<p>$S_2$ 是满足互质的二元组个数，即 $\sum_{i=1}^a\sum_{j=1}^a [\gcd(i,j)=1]$</p>
<p>通过<a href="https://noone40404.github.io/2021/01/06/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/">莫反</a>显然能得到：</p>
<script type="math/tex; mode=display">F(n)=\sum_{i=1}^a\sum_{j=1}^a[\gcd(i,j)=n]</script><script type="math/tex; mode=display">G(n)=\sum_{n\mid d}F(d)=\sum_{i=1}^a\sum_{j=1}^a[n\mid \gcd(i,j)]=\left[\frac{a}{n}\right]^2</script><script type="math/tex; mode=display">F(n)=\sum_{n\mid d}G(d)\times \mu\left(\frac{d}{n} \right)</script><p>那么所求即是 $F(1)=\sum_{i=1}^a G(i)\mu(i)=\sum_{i=1}^a \left[\frac{a}{i} \right]^2\mu(i)$</p>
<p>$S_3$ 同理可得 $\sum_{i=1}^a\left[\frac{a}{i} \right]^3 \mu(i)$</p>
</li>
<li><p>再考虑不同项链数</p>
<p>套路的，用 $\text{burnside}$ 得</p>
<script type="math/tex; mode=display">\frac{1}{n}\sum_{d\mid n}f(d)\varphi\left(\frac{n}{d} \right)</script><p>$f$ 为大小为 $d$ 个集合的环不考虑同构情况下的方案数</p>
<p>考虑 $f_n$ 的递推：插入第 $n$ 个珠子时，若 $1$ 与 $n-1$ 个珠子相同，则方案数为 $(m-1)f_{n-2}$ ，若不同，方案数为 $(m-2)f_{n-1}$</p>
<p>那么有 $f_n=(m-1)f_{n-2}+(m-2)f_{n-1}$ ，为方便计算，不妨设 $f_0=m,f_1=0$ ，那么就可以矩乘优化</p>
<p>但注意到这个形式恰是<a href="https://noone40404.github.io/2021/11/03/k%E9%98%B6%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%BD%90%E6%AC%A1-%E9%9D%9E%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8/">二阶常系数线性齐次递推式</a></p>
<p>具体的，可以列出 $\lambda^2-(m-2)\lambda-(m-1)=0$ 来求得两个特征根 $\lambda_1=-1,\lambda_2=m-1$</p>
<p>设 $c=f_1-\lambda_1f_0=m$</p>
<p>由于此时 $\lambda_1\not ={\lambda_2}$ ，由等比数列求和能解得：</p>
<script type="math/tex; mode=display">A=f_0-\frac{c}{\lambda_2-\lambda_1}=m-1</script><script type="math/tex; mode=display">B=\frac{c}{\lambda_2-\lambda_1}=1</script><p>那么有：</p>
<script type="math/tex; mode=display">f_n=Ax_1^n+Bx_2^n=(m-1)(-1)^n+(m-1)^n</script></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e7</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> ld EPS=<span class="number">0.5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod_2=mod*mod;</span><br><span class="line"><span class="keyword">const</span> ll inv6=<span class="number">833333345000000041ll</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> prime[N/<span class="number">10</span>],pri_cnt,mu[N];</span><br><span class="line">ll n,m,ans,limit;</span><br><span class="line"><span class="keyword">int</span> a,cnt;</span><br><span class="line">ll q_n[<span class="number">11</span>],q_a[<span class="number">11</span>];</span><br><span class="line">ll varphi[N/<span class="number">10</span>],num[N/<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fix</span><span class="params">(ll &amp;x)</span></span>&#123; x&gt;=mod_2 ? x-=mod_2 : <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">qmul</span><span class="params">(ll x,ll y)</span></span>&#123; <span class="keyword">return</span> (x*y-(ll) (((ld) x*y+EPS)/(ld) mod_2)*mod_2+mod_2)%mod_2;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">lpow</span><span class="params">(ll x,ll y,ll res=<span class="number">1</span>)</span></span>&#123; <span class="keyword">while</span>(y)&#123; <span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=<span class="built_in">qmul</span>(res,x); y&gt;&gt;=<span class="number">1</span>; x=<span class="built_in">qmul</span>(x,x);&#125; <span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">qpow</span><span class="params">(ll x,ll y,ll res=<span class="number">1</span>)</span></span>&#123; <span class="keyword">while</span>(y)&#123; <span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=res*x%mod; y&gt;&gt;=<span class="number">1</span>; x=x*x%mod;&#125; <span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">sqr</span><span class="params">(ll x)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">qmul</span>(x,x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">cub</span><span class="params">(ll x)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">qmul</span>(<span class="built_in">sqr</span>(x),x);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ll lim)</span></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;=lim;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) prime[++pri_cnt]=i,mu[i]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=pri_cnt &amp;&amp; i*prime[j]&lt;=lim;++j)&#123;</span><br><span class="line">            rei x=i*prime[j]; vis[x]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]) mu[x]=-mu[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=lim;++i) mu[i]+=mu[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">calc_pearl</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    ll S2=<span class="number">0</span>,S3=<span class="number">0</span>,S1=<span class="number">1</span>,res=<span class="number">0</span>; S1*=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,j;i&lt;=n;i=j+<span class="number">1</span>)&#123;</span><br><span class="line">        j=n/(n/i);</span><br><span class="line">        <span class="built_in">fix</span>(S3+=<span class="built_in">qmul</span>(<span class="built_in">cub</span>(n/i),(mu[j]-mu[i<span class="number">-1</span>]+mod_2)%mod_2));</span><br><span class="line">        <span class="built_in">fix</span>(S2+=<span class="built_in">qmul</span>(<span class="built_in">sqr</span>(n/i),(mu[j]-mu[i<span class="number">-1</span>]+mod_2)%mod_2));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fix</span>(res+=S3); <span class="built_in">fix</span>(res+=<span class="built_in">qmul</span>(S2,<span class="number">3</span>)); <span class="built_in">fix</span>(res+=S1);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">qmul</span>(res,inv6);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">get_f</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    ll res=<span class="built_in">lpow</span>(m<span class="number">-1</span>,n);</span><br><span class="line">    <span class="built_in">fix</span>(res+=n&amp;<span class="number">1</span> ? (mod_2-(m<span class="number">-1</span>))%mod_2 : m<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_phi</span><span class="params">(<span class="keyword">int</span> depth,ll d,ll phi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(depth==cnt+<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">fix</span>(ans+=<span class="built_in">qmul</span>(phi,<span class="built_in">get_f</span>(n/d)));</span><br><span class="line">    <span class="built_in">get_phi</span>(depth+<span class="number">1</span>,d,phi);</span><br><span class="line">    d*=varphi[depth]; phi*=varphi[depth]<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">get_phi</span>(depth+<span class="number">1</span>,d,phi);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;=num[depth];++i) d*=varphi[depth],phi*=varphi[depth],<span class="built_in">get_phi</span>(depth+<span class="number">1</span>,d,phi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rei T; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=T;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;q_n[i],&amp;q_a[i]),limit=<span class="built_in">max</span>(limit,<span class="built_in">max</span>( (ll) <span class="built_in">sqrt</span>(q_n[i]),q_a[i]));</span><br><span class="line">    <span class="built_in">init</span>(limit);</span><br><span class="line">    <span class="keyword">for</span>(rei ith=<span class="number">1</span>;ith&lt;=T;++ith)&#123;</span><br><span class="line">        n=q_n[ith],a=q_a[ith];</span><br><span class="line">        m=<span class="built_in">calc_pearl</span>(a);</span><br><span class="line">        cnt=ans=<span class="number">0</span>; ll x=n;</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=pri_cnt &amp;&amp; (ll) prime[i]*prime[i]&lt;=x;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x%prime[i]) <span class="keyword">continue</span>;</span><br><span class="line">            varphi[++cnt]=prime[i]; num[cnt]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!(x%prime[i])) ++num[cnt],x/=prime[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;<span class="number">1</span>) varphi[++cnt]=x,num[cnt]=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">get_phi</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!(n%mod)) ans=(ll) (ans/mod)*<span class="built_in">qpow</span>(n/mod,mod<span class="number">-2</span>)%mod;</span><br><span class="line">        <span class="keyword">else</span> ans=(ll) (ans%mod)*<span class="built_in">qpow</span>(n%mod,mod<span class="number">-2</span>)%mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P5564-Celeste-B-Say-Goodbye"><a href="#P5564-Celeste-B-Say-Goodbye" class="headerlink" title="P5564 [Celeste-B]Say Goodbye"></a><a href="https://www.luogu.com.cn/problem/P5564">P5564 [Celeste-B]Say Goodbye</a></h3>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>数数</tag>
        <tag>群论</tag>
      </tags>
  </entry>
  <entry>
    <title>动态dp</title>
    <url>/2021/09/27/%E5%8A%A8%E6%80%81dp/</url>
    <content><![CDATA[<h2 id="序列上动态-dp"><a href="#序列上动态-dp" class="headerlink" title="序列上动态 $dp$"></a>序列上动态 $dp$</h2><h3 id="引入-普通的序列上动态-dp"><a href="#引入-普通的序列上动态-dp" class="headerlink" title="引入-普通的序列上动态 $dp$"></a>引入-普通的序列上动态 $dp$</h3><blockquote>
<p><a href="https://www.luogu.com.cn/problem/SP6779">已知长度 $n$ 的序列 $A$ ，$q$ 组询问中每次给定 $L,R$ ，求 $\max_{L\leq l\leq r\leq R} \sum_{i=l}^r a_i$</a></p>
</blockquote>
<p>注：这是 $\text{WC2018}$ 猫锟的课件例题</p>
<p><del>可以用线段树 $(O(N+Q\log N))$ ，<a href="https://www.luogu.com.cn/blog/user7035/solution-sp1043">猫树 $O(N\log N+Q)$</a> ， 拓展 $\text{Tarjan}$ 离线 $(O(N+Q\log N))$ ，分块 $(O(N+Q\sqrt N))$ ，<a href="https://www.csie.ntu.edu.tw/~kmchao/seq06fall/RMSQ.pdf">论文 $O(N+Q)$</a> 求出 $M_RM_{R-1}…M_{L+1}$ 的值，并乘 $\begin{bmatrix}A_L \\ 0\end{bmatrix}$ 求出答案</del></p>
<p>这不是重点</p>
<p>对于序列 $a$ 上操作，有如下的贪心算法：</p>
<p>记录 $cur,ans$ ，有转移：</p>
<script type="math/tex; mode=display">\begin{cases}
cur_i=\max\{cur_{i-1}+a_i,a_i\} \\
ans_1=\max\{ans_{i-1},cur_i\} \\
\end{cases}</script><p>重新定义矩阵运算，乘法改为加法，加法改为取 $\max$ ：</p>
<script type="math/tex; mode=display">\begin{bmatrix}a_i & -\infin & a_i \\ a_i & 0 & a_i \\ -\infin & -\infin & 0\end{bmatrix}
\begin{bmatrix}cur_{i-1} \\ ans_{i-1} \\ 0\end{bmatrix}
\quad
=
\begin{bmatrix} \max\{a_i+cur_{i-1} , -\infin+ans_{i-1} , a_i+0 \} \\ \max\{a_i+cur_{i-1} , 0+ans_{i-1} , a_i+0\} \\ \max\{-\infin+cur_{i-1} , -\infin+ans_{i-1} , 0+0\}\end{bmatrix}
\quad
=
\quad
\begin{bmatrix}cur_i \\ ans_i \\ 0\end{bmatrix}</script><p>谔谔谔，<strong>注意 $mat_{1,2}$ 这个讨论了之前的 $cur,ans$ 都 $&lt;a_i$ 的情况</strong>，一般来说重新定义的矩阵乘法中能处理该问题，但再输出答案时需要对此进行取 $\max$</p>
<p>至此，最大子区间和中每一位的转移可以以矩阵的形式被表示，单点修改对应单个矩阵的修改</p>
<p><del>可能有人发现矩阵的式子和猫老师的不太一样，原因是wtcl，按猫老师的式子写不出来</del>＞﹏＜</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">2147483647</span>&gt;&gt;<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e4</span>+<span class="number">100</span>,M=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],n,m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> mat[M][M];</span><br><span class="line">    <span class="built_in">Matrix</span>()&#123; <span class="built_in">memset</span>(mat,<span class="number">0</span>,<span class="keyword">sizeof</span> mat);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;n;++i) mat[i][x]=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span>&#123; <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;M;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;M;++j) <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>,mat[i][j],j==M<span class="number">-1</span> ? <span class="number">10</span> : <span class="number">32</span>);&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line">		mat[<span class="number">0</span>][<span class="number">0</span>]=mat[<span class="number">0</span>][<span class="number">2</span>]=mat[<span class="number">1</span>][<span class="number">0</span>]=mat[<span class="number">1</span>][<span class="number">2</span>]=a[l];</span><br><span class="line">		mat[<span class="number">0</span>][<span class="number">1</span>]=mat[<span class="number">2</span>][<span class="number">0</span>]=mat[<span class="number">2</span>][<span class="number">1</span>]=-INF;</span><br><span class="line">		mat[<span class="number">1</span>][<span class="number">1</span>]=mat[<span class="number">2</span>][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123; mat[<span class="number">0</span>][<span class="number">0</span>]=mat[<span class="number">0</span>][<span class="number">2</span>]=mat[<span class="number">1</span>][<span class="number">0</span>]=mat[<span class="number">1</span>][<span class="number">2</span>]=val;&#125;</span><br><span class="line">	<span class="keyword">friend</span> Matrix <span class="keyword">operator</span> *(<span class="keyword">const</span> Matrix a,<span class="keyword">const</span> Matrix b)&#123;</span><br><span class="line">		Matrix c;</span><br><span class="line">		<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;M;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;M;++j) c.mat[i][j]=-INF;</span><br><span class="line">		<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;M;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;M;++j) <span class="keyword">for</span>(rei k=<span class="number">0</span>;k&lt;M;++k)</span><br><span class="line">			c.mat[i][j]=<span class="built_in">max</span>(c.mat[i][j],a.mat[i][k]+b.mat[k][j]);</span><br><span class="line">		<span class="keyword">return</span> c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;sum[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> ST&#123;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123; sum[now]=sum[now&lt;&lt;<span class="number">1</span>]*sum[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l==r) <span class="keyword">return</span> sum[now].<span class="built_in">init</span>(l),<span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">		rei mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">build</span>(now&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">build</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">		<span class="built_in">pushup</span>(now);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> pos,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l==r) <span class="keyword">return</span> sum[now].<span class="built_in">change</span>(val);</span><br><span class="line">		rei mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		pos&lt;=mid ? <span class="built_in">change</span>(now&lt;&lt;<span class="number">1</span>,l,mid,pos,val) : <span class="built_in">change</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,pos,val);</span><br><span class="line">		<span class="built_in">pushup</span>(now);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Matrix <span class="title">query</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l&gt;=L &amp;&amp; r &lt;= R) <span class="keyword">return</span> sum[now];</span><br><span class="line">		rei mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(L&lt;=mid&amp;&amp;R&gt;mid)</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">query</span>(now&lt;&lt;<span class="number">1</span>,l,mid,L,R)*<span class="built_in">query</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,L ,R);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(L&lt;=mid)</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">query</span>(now&lt;&lt;<span class="number">1</span>,l,mid,L,R);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,L,R);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">	ST::<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		rei op,x,y; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;op,&amp;x,&amp;y);</span><br><span class="line">		<span class="keyword">if</span>(op)&#123;</span><br><span class="line">			Matrix ans=ST::<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,x,y);</span><br><span class="line">            ans.<span class="built_in">debug</span>();</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">max</span>(ans.mat[<span class="number">1</span>][<span class="number">0</span>],ans.mat[<span class="number">1</span>][<span class="number">2</span>]));<span class="comment">//唔，就是这里，对应上面的注意</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> ST::<span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,x,y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="更复杂一点的序列上动态-dp"><a href="#更复杂一点的序列上动态-dp" class="headerlink" title="更复杂一点的序列上动态 $dp$"></a>更复杂一点的序列上动态 $dp$</h3><p><a href="https://www.luogu.com.cn/problem/CF750E">CF750E New Year and Old Subsequence</a></p>
<blockquote>
<p>给定一个数字序列，每次询问一个区间，求区间内至少删去几个字符可以是该串包含子序列 $2017$ ，且不包含 $2016$</p>
</blockquote>
<p><del>好吧猫老师还有需要支持单点修改的</del></p>
<p><del>没有删除操作的话就不怎么算是动态dp了（</del></p>
<p>首先由题得，这里的矩阵乘法中加法将被定义为取 $\min$</p>
<p>用 $0/1/2/3/4$ 替代 $\varnothing/2/20/201/2017$</p>
<p>设 $f_{i,0/1/2/3/4}$ 表示最少需要删去多少个字符才能在 $[1,i]$ 中包含 $\varnothing/2/20/201/2017$</p>
<p>有转移：</p>
<script type="math/tex; mode=display">\begin{cases}
f_{i,0}=f_{i-1,0}+[s_i==2] \\
f_{i,1}=\min\{f_{i-1,1}+[s_i=0],f_{i-1,0}[s_i=2]\} \\
f_{i,2}=\min\{f_{i-1,2}+[s_i=1],f_{i-1,1}[s_i=0]\} \\
f_{i,3}=\min\{f_{i-1,3}+[s_i=7\lor s_i=6],f_{i-1,2}[s_i=1]\} \\
f_{i,4}=\min\{f_{i-1,4}+[s_i=6],f_{i-1,3}[s_i=7]\} \\
\end{cases}</script><p>注意不成立的时候值应设为 $INF$</p>
<p>如此<strong>常系数齐次线性递推式</strong>可以变成矩阵形式</p>
<p>同上，线段树维护一下矩阵乘即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line">		<span class="built_in">memset</span>(mat,INF,<span class="keyword">sizeof</span> mat);</span><br><span class="line">		<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;M;++i) mat[i][i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(s[l]==<span class="string">&#x27;2&#x27;</span>) mat[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>,mat[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(s[l]==<span class="string">&#x27;0&#x27;</span>) mat[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>,mat[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(s[l]==<span class="string">&#x27;1&#x27;</span>) mat[<span class="number">2</span>][<span class="number">2</span>]=<span class="number">1</span>,mat[<span class="number">2</span>][<span class="number">3</span>]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(s[l]==<span class="string">&#x27;7&#x27;</span>) mat[<span class="number">3</span>][<span class="number">3</span>]=<span class="number">1</span>,mat[<span class="number">3</span>][<span class="number">4</span>]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(s[l]==<span class="string">&#x27;6&#x27;</span>) mat[<span class="number">3</span>][<span class="number">3</span>]=<span class="number">1</span>,mat[<span class="number">4</span>][<span class="number">4</span>]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">friend</span> Matrix <span class="keyword">operator</span> *(<span class="keyword">const</span> Matrix a,<span class="keyword">const</span> Matrix b)&#123;</span><br><span class="line">		Matrix c;</span><br><span class="line">		<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;M;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;M;++j) c.mat[i][j]=INF;</span><br><span class="line">		<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;M;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;M;++j) <span class="keyword">for</span>(rei k=<span class="number">0</span>;k&lt;M;++k)</span><br><span class="line">			c.mat[i][j]=<span class="built_in">min</span>(c.mat[i][j],a.mat[i][k]+b.mat[k][j]);</span><br><span class="line">		<span class="keyword">return</span> c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;sum[N&lt;&lt;<span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<h2 id="树上动态-dp"><a href="#树上动态-dp" class="headerlink" title="树上动态 $dp$"></a>树上动态 $dp$</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>树上动态 $dp$ 指一类支持树上单点修改全局查询题，一些信息可以通过暴力的线性树形 $dp$ 求出，一些问题需要支持子树或链上询问 $dp$ 值</p>
<h4 id="转化"><a href="#转化" class="headerlink" title="转化"></a>转化</h4><p>显然这类问题无法继续套用序列上的算法，而一种思路就是将其转化为序列问题—<strong>树链剖分</strong>—每一条重链都是一个序列上的问题</p>
<p>对于每一个节点的 $dp$ 值，如果其儿子都计算完毕，则可以计算该点的 $dp$ 值。于是可以选择任意符合该条件的顺序进行 $dp$</p>
<p>与之类似的，如果一条重链 $A$ 的顶端节点的父亲在重链 $B$ 中，就令 $A$ 的父亲重链为 $B$ ，由此能得到一颗<code>重链树</code></p>
<p>如果按照重链树的顺序，且每条重链从下往上计算，则是合法的，因为每个儿子不是某条子重链的顶端(轻儿子)，就是重儿子</p>
<ul>
<li>为什么是重链剖分<ul>
<li>重链至多 $\log n$条，时间复杂度不劣</li>
<li>一条重链在 $dfn$ 上的区间连续</li>
<li>重链的链尾都是叶子节点，易于处理起始状态</li>
</ul>
</li>
</ul>
<h4 id="转移"><a href="#转移" class="headerlink" title="转移"></a>转移</h4><p>对于一条重链上的问题</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/2gpetnpw.png" alt="来自猫老师的PPT"></p>
<p>轻儿子的 $dp$ 值已经被计算，和节点本身的值可一起被视作<code>输入</code></p>
<p>而修改的时候，按照重链树形一条一条往上改，每次会单点修改重链上一个点的本身或者轻边的信息</p>
<p>由此，问题被转化为了 $\log n$ 条重链上做序列动态 $dp$ 问题</p>
<h3 id="例题-单点修改，区间询问"><a href="#例题-单点修改，区间询问" class="headerlink" title="例题-单点修改，区间询问"></a>例题-单点修改，区间询问</h3><h4 id="P4719-【模板】”动态-DP”-amp-动态树分治"><a href="#P4719-【模板】”动态-DP”-amp-动态树分治" class="headerlink" title="P4719 【模板】”动态 DP”&amp;动态树分治"></a><a href="https://www.luogu.com.cn/problem/P4719">P4719 【模板】”动态 DP”&amp;动态树分治</a></h4><blockquote>
<p>给出一棵树，每个点有点权，要求支持单点点权修改，查询以 $1$ 为根的一颗子树的最大权独立集</p>
</blockquote>
<p>最大权独立集：相连的点不同时选得到的权值最大的点集</p>
<p>首先考虑弱化版，即没有修改操作</p>
<p>暴力 $dp$ ：设 $f_{i,c}$ 表示以 $i$ 为根的子树中满足 $c=[i 在所选独立集中]$ 的最大独立集，有转移：</p>
<script type="math/tex; mode=display">f_{i,c}=a_i\times c+\sum_{p\in son_i} \max\{f_{p,0},f_{p,1}-\infin\times c\}</script><p>再考虑完整的问题：怎样再重链里快速修改并查询该链的 $dp$ 值</p>
<p>不妨设点 $i$ 的编号就是 $i$ ，$g_{i,0/1}$ 表示点 $i$ 的轻儿子可取可不取/都不取的最大权独立集，那么有：</p>
<script type="math/tex; mode=display">g_{i,c}=\sum_{p\in son_i-\{i+1\}} \max\{f_{p,0},f_{p,1}-\infin\times c \}</script><p>由此易得，在重链上：</p>
<script type="math/tex; mode=display">f_{i,c}=a_i\times c+g_{i,c}+\max\{f_{i+1,0},f_{i+1,1}-\infin\times c\}</script><p>观察式子不难发现，前两项看作输入的一部分，仅有最后一项和 $f_{i+1,<em>}$ 有关，这里着重说明<em>*如何构造矩阵的转移</em></em>：</p>
<p>首先发现 $c=1$ 时 $g_{i,1},a_i$ 都仅与 $i$ 有关，考虑如何合并：更改 $g_{i,0/1}$ 的定义为： $i$ 号点只考虑轻儿子取自己的最大权独立集</p>
<p>那么式子变为 $f_{i,c}=g_{i,c}+\max\{f_{i+1,0},f_{i+1,1}-\infin\times c\}$</p>
<p>先将 $f$ 的转移方程拆开并变形：</p>
<script type="math/tex; mode=display">\begin{cases}
f_{i,0}=\max\{f_{j,0}+g_{i,0},f_{j,1}+g_{i,0}\} \\
f_{i,1}=\max\{f_{j,0}+g_{i,1},-\infin\} \\
\end{cases}</script><p>然后把已知状态和要转移的状态写在一起：</p>
<script type="math/tex; mode=display">\begin{bmatrix}f_{j,0} & f_{j,1}\end{bmatrix}
\begin{bmatrix}|X|\end{bmatrix}
\quad=\quad
\begin{bmatrix}f_{i,0} & f_{i,1}\end{bmatrix}</script><p>$1\times 2$ 的矩阵形成了 $1\times 2$ 的矩阵，那么矩阵 $X$ 为 $2\times 2$</p>
<p>把位置对应上去有：</p>
<script type="math/tex; mode=display">\begin{cases}
f_{i,0}=\max\{f_{j,0}+X_{0,0},f_{j,1}+X_{1,0}\} \\
f_{i,1}=\max\{f_{j,0}+X_{0,1},f_{j,1}+X_{1,1}\} \\
\end{cases}</script><p>那么有：</p>
<script type="math/tex; mode=display">X
\quad=\quad
\begin{bmatrix}g_{i,0} & g_{i,1} \\ g_{i,0} & -\infin\end{bmatrix}</script><p>再考虑矩阵乘法的顺序：初始信息位于叶子节点，即链尾处，由于 $dfn$ ，链尾在区间右端，链头在左端，所以矩阵乘法应是转移矩阵在前，要维护的在后，即：</p>
<script type="math/tex; mode=display">\begin{bmatrix}g_{i,0} & g_{i,0} \\ g_{i,1} & -\infin\end{bmatrix}
\begin{bmatrix}f_{j,0} \\ f_{j,1}\end{bmatrix}
\quad=\quad
\begin{bmatrix}f_{i,0} \\ f_{i,1}\end{bmatrix}</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x7F7F7F7F</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> head[N],Next[N&lt;&lt;<span class="number">1</span>],ver[N&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line"><span class="keyword">int</span> A[N];</span><br><span class="line"><span class="keyword">int</span> fa[N],Size[N],depth[N],dfn[N],top[N],id[N],son[N],End[N],cnt;</span><br><span class="line"><span class="keyword">int</span> dp[N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123; ver[++tot]=y; Next[tot]=head[x];head[x]=tot;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> mat[M][M];</span><br><span class="line">    <span class="built_in">Matrix</span>()&#123; <span class="built_in">memset</span>(mat,<span class="number">0</span>,<span class="keyword">sizeof</span> mat);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;n;++i) mat[i][x]=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span>&#123; <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;M;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;M;++j) <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>,mat[i][j],j==M<span class="number">-1</span> ? <span class="number">10</span> : <span class="number">32</span>);&#125;</span><br><span class="line">	<span class="comment">// inline void init(int l)&#123;</span></span><br><span class="line">	<span class="comment">// 	mat[0][0]=mat[0][2]=mat[1][0]=mat[1][2]=a[l];</span></span><br><span class="line">	<span class="comment">// 	mat[0][1]=mat[2][0]=mat[2][1]=-INF;</span></span><br><span class="line">	<span class="comment">// 	mat[1][1]=mat[2][2]=0;</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	<span class="comment">// inline void change(int val)&#123; mat[0][0]=mat[0][2]=mat[1][0]=mat[1][2]=val;&#125;</span></span><br><span class="line">	<span class="keyword">friend</span> Matrix <span class="keyword">operator</span> *(<span class="keyword">const</span> Matrix a,<span class="keyword">const</span> Matrix b)&#123;</span><br><span class="line">		Matrix c;</span><br><span class="line">		<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;M;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;M;++j) c.mat[i][j]=-INF;</span><br><span class="line">		<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;M;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;M;++j) <span class="keyword">for</span>(rei k=<span class="number">0</span>;k&lt;M;++k)</span><br><span class="line">			c.mat[i][j]=<span class="built_in">max</span>(c.mat[i][j],a.mat[i][k]+b.mat[k][j]);</span><br><span class="line">		<span class="keyword">return</span> c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;sum[N&lt;&lt;<span class="number">2</span>],val[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> ST&#123;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123; sum[now]=sum[now&lt;&lt;<span class="number">1</span>]*sum[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l==r) <span class="keyword">return</span> sum[now]=val[ dfn[l] ],<span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">		rei mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">build</span>(now&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">build</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">		<span class="built_in">pushup</span>(now);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l==r) <span class="keyword">return</span> sum[now]=val[ dfn[pos] ],<span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">		rei mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		pos&lt;=mid ? <span class="built_in">change</span>(now&lt;&lt;<span class="number">1</span>,l,mid,pos) : <span class="built_in">change</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,pos);</span><br><span class="line">		<span class="built_in">pushup</span>(now);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Matrix <span class="title">query</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l&gt;=L &amp;&amp; r &lt;= R) <span class="keyword">return</span> sum[now];</span><br><span class="line">		rei mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(L&lt;=mid &amp;&amp; R&gt;mid) <span class="keyword">return</span> <span class="built_in">query</span>(now&lt;&lt;<span class="number">1</span>,l,mid,L,R)*<span class="built_in">query</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,L ,R);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(L&lt;=mid) <span class="keyword">return</span> <span class="built_in">query</span>(now&lt;&lt;<span class="number">1</span>,l,mid,L,R);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,L,R);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fath)</span></span>&#123;</span><br><span class="line">    Size[x]=<span class="number">1</span>; depth[x]=depth[fath]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=head[x];i;i=Next[i])&#123;</span><br><span class="line">        rei y=ver[i]; <span class="keyword">if</span>(y==fath) <span class="keyword">continue</span>;</span><br><span class="line">        fa[y]=x; <span class="built_in">dfs1</span>(y,x);</span><br><span class="line">        Size[x]+=Size[y];</span><br><span class="line">        <span class="keyword">if</span>(Size[y]&gt;Size[ son[x] ] || !son[x]) son[x]=y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> anc=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">    id[x]=++cnt; dfn[cnt]=x; top[x]=anc;</span><br><span class="line">    End[anc]=<span class="built_in">max</span>(End[anc],cnt);</span><br><span class="line">    dp[x][<span class="number">0</span>]=<span class="number">0</span>; dp[x][<span class="number">1</span>]=A[x];</span><br><span class="line">    val[x].mat[<span class="number">0</span>][<span class="number">0</span>]=val[x].mat[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    val[x].mat[<span class="number">1</span>][<span class="number">0</span>]=A[x];</span><br><span class="line">    <span class="keyword">if</span>(son[x]!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">dfs2</span>(son[x],anc);</span><br><span class="line">        dp[x][<span class="number">0</span>]+=<span class="built_in">max</span>(dp[ son[x] ][<span class="number">0</span>],dp[son[x]][<span class="number">1</span>]);</span><br><span class="line">        dp[x][<span class="number">1</span>]+=dp[ son[x] ][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=head[x];i;i=Next[i])&#123;</span><br><span class="line">        rei y=ver[i]; <span class="keyword">if</span>(y==fa[x]||y==son[x]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(y,y);</span><br><span class="line">        dp[x][<span class="number">0</span>]+=<span class="built_in">max</span>(dp[y][<span class="number">0</span>],dp[y][<span class="number">1</span>]); dp[x][<span class="number">1</span>]+=dp[y][<span class="number">0</span>];</span><br><span class="line">        val[x].mat[<span class="number">0</span>][<span class="number">0</span>]+=<span class="built_in">max</span>(dp[y][<span class="number">0</span>],dp[y][<span class="number">1</span>]);<span class="comment">//子儿子可选可不选的最大独立集</span></span><br><span class="line">        val[x].mat[<span class="number">0</span>][<span class="number">1</span>]=val[x].mat[<span class="number">0</span>][<span class="number">0</span>];<span class="comment">//同上</span></span><br><span class="line">        val[x].mat[<span class="number">1</span>][<span class="number">0</span>]+=dp[y][<span class="number">0</span>];<span class="comment">//子儿子不能选</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update_path</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    val[x].mat[<span class="number">1</span>][<span class="number">0</span>]+=z-A[x];<span class="comment">//还存有子儿子不能选的值,不能直接赋值为z</span></span><br><span class="line">    A[x]=z;<span class="comment">//更新对应点的值</span></span><br><span class="line">    Matrix last,now;</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">        last=ST::<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[ top[x] ],End[ top[x] ]);</span><br><span class="line">        ST::<span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[x]);<span class="comment">//找到需要更改的地方，进行更新</span></span><br><span class="line">        now=ST::<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[ top[x] ],End[ top[x] ]);</span><br><span class="line">        x=fa[ top[x] ];<span class="comment">//一直找重链，直到顶端</span></span><br><span class="line">        val[x].mat[<span class="number">0</span>][<span class="number">0</span>]+=<span class="built_in">max</span>(now.mat[<span class="number">0</span>][<span class="number">0</span>],now.mat[<span class="number">1</span>][<span class="number">0</span>])-<span class="built_in">max</span>(last.mat[<span class="number">0</span>][<span class="number">0</span>],last.mat[<span class="number">1</span>][<span class="number">0</span>]); <span class="comment">//之前可选可不选-现在可选可不选</span></span><br><span class="line">        val[x].mat[<span class="number">0</span>][<span class="number">1</span>]=val[x].mat[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        val[x].mat[<span class="number">1</span>][<span class="number">0</span>]+=now.mat[<span class="number">0</span>][<span class="number">0</span>]-last.mat[<span class="number">0</span>][<span class="number">0</span>]; <span class="comment">//之前不选-现在不选</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;A[i]);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,x,y;i&lt;n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y),<span class="built_in">add</span>(x,y),<span class="built_in">add</span>(y,x);</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>); <span class="built_in">dfs2</span>(<span class="number">1</span>);</span><br><span class="line">    ST::<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,x,y;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="built_in">update_path</span>(x,y);</span><br><span class="line">        Matrix ans=ST::<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[<span class="number">1</span>],End[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">max</span>(ans.mat[<span class="number">0</span>][<span class="number">0</span>],ans.mat[<span class="number">1</span>][<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="P5024-NOIP2018-提高组-保卫王国"><a href="#P5024-NOIP2018-提高组-保卫王国" class="headerlink" title="P5024 [NOIP2018 提高组] 保卫王国"></a><a href="https://www.luogu.com.cn/problem/P5024">P5024 [NOIP2018 提高组] 保卫王国</a></h4><blockquote>
<p>一棵树，有点权，要求最小权覆盖集，其中每组询问指定两个点的状态(选/不选)</p>
</blockquote>
<p>最小权覆盖集=全集-最大权独立集</p>
<p>强制选择/不选相当于把该点权值改为 $\pm INF$</p>
<p>参考模板题即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rei long long</span></span><br><span class="line"><span class="comment">// #define int long long</span></span><br><span class="line"><span class="comment">// #define int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">2</span>;</span><br><span class="line"><span class="comment">// const ll INF=LONG_LONG_MAX;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> head[N],Next[N&lt;&lt;<span class="number">1</span>],ver[N&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line">ll a[N],sigma;</span><br><span class="line"><span class="keyword">int</span> fa[N],Size[N],depth[N],dfn[N],top[N],id[N],son[N],End[N],cnt;</span><br><span class="line">ll dp[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">char</span> buff[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123; ver[++tot]=y; Next[tot]=head[x];head[x]=tot;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> mat[M][M];</span><br><span class="line">    <span class="built_in">Matrix</span>()&#123; <span class="built_in">memset</span>(mat,-INF,<span class="keyword">sizeof</span> mat);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;n;++i) mat[i][x]=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span>&#123; <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;M;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;M;++j) <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>,mat[i][j],j==M<span class="number">-1</span> ? <span class="number">10</span> : <span class="number">32</span>);&#125;</span><br><span class="line">	<span class="comment">// inline void init(int l)&#123;</span></span><br><span class="line">	<span class="comment">// 	mat[0][0]=mat[0][2]=mat[1][0]=mat[1][2]=a[l];</span></span><br><span class="line">	<span class="comment">// 	mat[0][1]=mat[2][0]=mat[2][1]=-INF;</span></span><br><span class="line">	<span class="comment">// 	mat[1][1]=mat[2][2]=0;</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	<span class="comment">// inline void change(int val)&#123; mat[0][0]=mat[0][2]=mat[1][0]=mat[1][2]=val;&#125;</span></span><br><span class="line">	<span class="keyword">friend</span> Matrix <span class="keyword">operator</span> *(<span class="keyword">const</span> Matrix a,<span class="keyword">const</span> Matrix b)&#123;</span><br><span class="line">		Matrix c;</span><br><span class="line">		<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;M;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;M;++j) c.mat[i][j]=-INF;</span><br><span class="line">		<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;M;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;M;++j) <span class="keyword">for</span>(rei k=<span class="number">0</span>;k&lt;M;++k)</span><br><span class="line">			c.mat[i][j]=<span class="built_in">max</span>(c.mat[i][j],a.mat[i][k]+b.mat[k][j]);</span><br><span class="line">		<span class="keyword">return</span> c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;sum[N&lt;&lt;<span class="number">2</span>],val[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> ST&#123;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123; sum[now]=sum[now&lt;&lt;<span class="number">1</span>]*sum[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l==r) <span class="keyword">return</span> sum[now]=val[ dfn[l] ],<span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">		rei mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">build</span>(now&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">build</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">		<span class="built_in">pushup</span>(now);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l==r) <span class="keyword">return</span> sum[now]=val[ dfn[pos] ],<span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">		rei mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		pos&lt;=mid ? <span class="built_in">change</span>(now&lt;&lt;<span class="number">1</span>,l,mid,pos) : <span class="built_in">change</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,pos);</span><br><span class="line">		<span class="built_in">pushup</span>(now);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Matrix <span class="title">query</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l&gt;=L &amp;&amp; r &lt;= R) <span class="keyword">return</span> sum[now];</span><br><span class="line">		rei mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(L&lt;=mid &amp;&amp; R&gt;mid) <span class="keyword">return</span> <span class="built_in">query</span>(now&lt;&lt;<span class="number">1</span>,l,mid,L,R)*<span class="built_in">query</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,L ,R);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(L&lt;=mid) <span class="keyword">return</span> <span class="built_in">query</span>(now&lt;&lt;<span class="number">1</span>,l,mid,L,R);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,L,R);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fath)</span></span>&#123;</span><br><span class="line">    Size[x]=<span class="number">1</span>; depth[x]=depth[fath]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=head[x];i;i=Next[i])&#123;</span><br><span class="line">        rei y=ver[i]; <span class="keyword">if</span>(y==fath) <span class="keyword">continue</span>;</span><br><span class="line">        fa[y]=x; <span class="built_in">dfs1</span>(y,x);</span><br><span class="line">        Size[x]+=Size[y];</span><br><span class="line">        <span class="keyword">if</span>(Size[y]&gt;Size[ son[x] ] || !son[x]) son[x]=y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> anc=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">    id[x]=++cnt; dfn[cnt]=x; top[x]=anc;</span><br><span class="line">    End[anc]=<span class="built_in">max</span>(End[anc],cnt);</span><br><span class="line">    dp[x][<span class="number">0</span>]=<span class="number">0</span>; dp[x][<span class="number">1</span>]=a[x];</span><br><span class="line">    val[x].mat[<span class="number">0</span>][<span class="number">0</span>]=val[x].mat[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    val[x].mat[<span class="number">1</span>][<span class="number">0</span>]=a[x];</span><br><span class="line">    <span class="keyword">if</span>(son[x]!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">dfs2</span>(son[x],anc);</span><br><span class="line">        dp[x][<span class="number">0</span>]+=<span class="built_in">max</span>(dp[ son[x] ][<span class="number">0</span>],dp[son[x]][<span class="number">1</span>]);</span><br><span class="line">        dp[x][<span class="number">1</span>]+=dp[ son[x] ][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=head[x];i;i=Next[i])&#123;</span><br><span class="line">        rei y=ver[i]; <span class="keyword">if</span>(y==fa[x]||y==son[x]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(y,y);</span><br><span class="line">        dp[x][<span class="number">0</span>]+=<span class="built_in">max</span>(dp[y][<span class="number">0</span>],dp[y][<span class="number">1</span>]); dp[x][<span class="number">1</span>]+=dp[y][<span class="number">0</span>];</span><br><span class="line">        val[x].mat[<span class="number">0</span>][<span class="number">0</span>]+=<span class="built_in">max</span>(dp[y][<span class="number">0</span>],dp[y][<span class="number">1</span>]);<span class="comment">//子儿子可选可不选的最大独立集</span></span><br><span class="line">        val[x].mat[<span class="number">0</span>][<span class="number">1</span>]=val[x].mat[<span class="number">0</span>][<span class="number">0</span>];<span class="comment">//同上</span></span><br><span class="line">        val[x].mat[<span class="number">1</span>][<span class="number">0</span>]+=dp[y][<span class="number">0</span>];<span class="comment">//子儿子不能选</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update_path</span><span class="params">(<span class="keyword">int</span> x,ll z)</span></span>&#123;</span><br><span class="line">    val[x].mat[<span class="number">1</span>][<span class="number">0</span>]+=z;</span><br><span class="line">    Matrix last,now;</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">        last=ST::<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[ top[x] ],End[ top[x] ]);</span><br><span class="line">        ST::<span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[x]);<span class="comment">//找到需要更改的地方，进行更新</span></span><br><span class="line">        now=ST::<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[ top[x] ],End[ top[x] ]);</span><br><span class="line">        x=fa[ top[x] ];<span class="comment">//一直找重链，直到顶端</span></span><br><span class="line">        val[x].mat[<span class="number">0</span>][<span class="number">0</span>]+=<span class="built_in">max</span>(now.mat[<span class="number">0</span>][<span class="number">0</span>],now.mat[<span class="number">1</span>][<span class="number">0</span>])-<span class="built_in">max</span>(last.mat[<span class="number">0</span>][<span class="number">0</span>],last.mat[<span class="number">1</span>][<span class="number">0</span>]); <span class="comment">//之前可选可不选-现在可选可不选</span></span><br><span class="line">        val[x].mat[<span class="number">0</span>][<span class="number">1</span>]=val[x].mat[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        val[x].mat[<span class="number">1</span>][<span class="number">0</span>]+=now.mat[<span class="number">0</span>][<span class="number">0</span>]-last.mat[<span class="number">0</span>][<span class="number">0</span>]; <span class="comment">//之前不选-现在不选</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%s&quot;</span>,&amp;n,&amp;m,buff);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]),sigma+=a[i];</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,x,y;i&lt;n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;x,&amp;y),<span class="built_in">add</span>(x,y),<span class="built_in">add</span>(y,x);</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>),<span class="built_in">dfs2</span>(<span class="number">1</span>);</span><br><span class="line">    ST::<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,x,y,v1,v2;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld&quot;</span>,&amp;x,&amp;v1,&amp;y,&amp;v2);</span><br><span class="line">        <span class="keyword">if</span>(!v1 &amp;&amp; !v2 &amp;&amp; (fa[x]==y || fa[y]==x))&#123; <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="built_in">update_path</span>(x,v1 ? -INF : INF),<span class="built_in">update_path</span>(y,v2 ? -INF : INF);</span><br><span class="line">        sigma+=(!v1 ? INF : <span class="number">0</span>)+(!v2 ? INF : <span class="number">0</span>);</span><br><span class="line">        Matrix ans=ST::<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[<span class="number">1</span>],End[<span class="number">1</span>]);</span><br><span class="line">        ll res=sigma-<span class="built_in">max</span>(ans.mat[<span class="number">0</span>][<span class="number">0</span>],ans.mat[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        sigma-=(!v1 ? INF : <span class="number">0</span>)+(!v2 ? INF : <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">update_path</span>(x,v1 ? INF : -INF),<span class="built_in">update_path</span>(y,v2 ? INF : -INF);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="P3781-SDOI2017-切树游戏"><a href="#P3781-SDOI2017-切树游戏" class="headerlink" title="P3781 [SDOI2017]切树游戏"></a><a href="https://www.luogu.com.cn/problem/P3781">P3781 [SDOI2017]切树游戏</a></h4><blockquote>
<p>给定一颗有点权无根树，一颗树的价值为其所有点权值的异或和，支持两种操作：单点修改，查询有多少棵树满足价值为 $k$</p>
</blockquote>
<p>照例先考虑暴力 $dp$ ：</p>
<p>设 $f_{i,j}$ 表示深度最小点(最高点)异或和为 $j$ 的连通块个数，答案即为 $\sum_{i=1}^n f_{i,k}$</p>
<p>易得转移为：$\displaystyle{f_{u,k}=\sum_{i\oplus j=k} f_{u,i}\times f_{v,j}+f_{u,k}}$</p>
<p>枚举 $i,j$ 有复杂度 $O(nm\times 128^2)$</p>
<p>观察到式子的<strong>下标是异或卷积的形式</strong>，$FWT$ 显然能优化到 $O(nm\times 128\log 128)$ ，但可以一直使用 $FWT$ 的数组计算，仅在开始结尾做 $FWT$ 的转化，时间复杂度可被简化为 $O((n+\log 128)\times 128)$</p>
<p>注意：如此后异或卷积 $a=b*c$ 为 $FWT_a=FWT_b · FWT_c$ ，即逐位相乘</p>
<p>考虑额外记录 $h_{i,k}$ 表示 $i$ 子树中 $f_{i,k}$ 的和，使 $dp$ 有子树的阶段性</p>
<p>再考虑到易于转移(过于简洁)的 $dp$ 式子，发现这是一个支持单点修改，查询的树上动态 $dp$ ，具体过程见上面，这里略</p>
<p>再从生成函数(多项式？) 的角度来更好的表达 $dp$ 过程：</p>
<p>对于每个节点 $u$ 上的所有 $f_{u,*}$ ，考虑用一个生成函数来表示所有的情况，即:</p>
<script type="math/tex; mode=display">F(u,z)=\sum_{i=0}^{m-1} f_{u,i}\times z^i</script><p>其中 $z$ 就是无实意的未知数( $x$ )，其项数 $i$ 表示子树权值为 $i$ ，前面的系数自然就是权值为 $i$ 的情况数</p>
<p>那么 $dp$ 转移能被简化为：</p>
<script type="math/tex; mode=display">F_{u,z}=z^{val_u} \prod_{v\in son_u} (F_{v,z}+z^0)</script><p>$val_u$ 是节点 $u$ 的权值，后面的 $z^0$ <del>作用显然</del>： 设 $u$ 有两个子节点 $v1,v2$ ，将式子展开后能看出 $z^0$ 的作用：</p>
<script type="math/tex; mode=display">z^{val_u} \times \left(F_{v1,z}+1\right) \times (F_{v2,z}+1)</script><p>显而易见，$z^0$ 保证了对于 $u$ 的子节点不同的选择方法，进一步展开后能发现选 $\{v1,v2\},\{v1\},\{v2\},\{\varnothing\}$ 的不同方案都被涵盖</p>
<p>对于重链上每个点 $i$ ，将 $i$ 的所有轻儿子 $lson_i$ 的 $F_{lson,z}+z^0$ 做卷积就能考虑所有轻儿子对于该子树的贡献，即</p>
<script type="math/tex; mode=display">LF_{i,z}=z^{val_i} \prod_{v\in son_i , v\not ={hson_i}} (F_{v,z}+z^0)</script><p>类比于 $F_{i,z}$ 的定义，对于 $h_{i,*}$ 定义 $H_{i,z}$</p>
<p>对于每个点再记录 $LH_{i,z}$ 表示点 $i$ 的每个轻儿子的 $H_{lson_i,z}$ 的和，即</p>
<script type="math/tex; mode=display">LH_{i,z}=\sum_{v\in son_i,v\not ={hson_i}} H_{v,z}</script><p>由此，可以用线段树维护每个点的轻边的信息，而求出 $F_{hson,z},H_{hson,z}$ 后就能维护父亲重链的信息</p>
<p>对于一条重链，设重链上点深度从小到大为 $p_1,…,p_c$ ，那么有：</p>
<script type="math/tex; mode=display">\begin{cases}
F_{p_c,z}=H_{p_c,z}=z^{val_{p_c}}  &\text{$p_c$ 是叶节点}\\
F_{p_i,z}=LF_{p_i,z}\times (F_{p_{i+1},z}+z^0)\times z^{val_{p_i}} &\text{LP感性理解}\\
H_{p_i,z}=H_{p_{i+1},z}+F_{p_i,z} \\
\end{cases}</script><p>那么能得到矩阵转移：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}F_{p_{i+1},z} & H_{p_{i+1},z} & z^0\end{bmatrix}
\begin{bmatrix}
LF_{p_i,z}\times z^{val_{p_1}} & LF_{p_i,z}\times z^{val_{p_1}} & 0 \\
0 & 1 & 0 \\
LF_{p_i,z}\times z^{val_{p_1}} & LH_{p_i}+LF_{p_i,z}\times z^{val_{p_i}} & 1 \\
\end{bmatrix}
\quad=\quad
\begin{bmatrix}F_{p_i,z} & H_{p_i,z} & z^0\end{bmatrix}</script><p>这个 $3\times 3$ 的矩阵转移会导致要做 $27$ 次生成函数乘法，考虑如何优化</p>
<p>猫老师告诉我们，矩阵乘法对形如 $\begin{bmatrix}a &amp; b &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ c &amp; d &amp; 1\end{bmatrix}$ 的矩阵是封闭的，即：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}a_1 & b_1 & 0 \\ 0 & 1 & 0 \\ c_1 & d_1 & 1 \\\end{bmatrix}
\begin{bmatrix}a_2 & b_2 & 0 \\ 0 & 1 & 0 \\ c_2  & d_2 & 1\end{bmatrix}
\quad=\quad
\begin{bmatrix}a_1a_2 & b_1+a_1b_2 & 0 \\ 0 & 1 & 0 \\ a_2c_1+c_2 & b_2c_1+d_1+d_2 & 1\end{bmatrix}</script><p>这样就优化为了 $4$ 次生成函数乘法</p>
<p>至此，这道 树剖后矩阵乘法卷积维护前缀和转多项式生成函数套个 $FWT$ 后上线段树 的题就完成了。。。吗？</p>
<p>树剖在洛谷上被卡掉了qwq，$80$ 分走人</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rei register int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">130</span>,N=<span class="number">3e4</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inv2=<span class="number">5004</span>,mod=<span class="number">1e4</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,Q,tot,cnt;</span><br><span class="line"><span class="keyword">int</span> e[M][M],inv[mod+<span class="number">5</span>],v[N],tmp1[M],tmp2[M];</span><br><span class="line"><span class="keyword">int</span> head[N],Next[N&lt;&lt;<span class="number">1</span>],ver[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> fa[N],depth[N],top[N],Size[N],pos[N],repos[N],hson[N],bot[N];</span><br><span class="line"><span class="keyword">int</span> F[N][M],H[N][M],lH[N][M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x&gt;=mod ? x-mod : x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123; ver[++tot]=y,Next[tot]=head[x],head[x]=tot;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mat</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="comment">//神奇的方法：lF(x)-&gt;将值写成x*0^y的形式 如果有除以0的情况就将y--</span></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">put_val</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123; k ? (x=k,y=<span class="number">0</span>) : (x=<span class="number">1</span>,y=<span class="number">1</span>);&#125;</span><br><span class="line">	<span class="keyword">friend</span> mat <span class="keyword">operator</span> *(mat A,<span class="keyword">int</span> B)&#123;</span><br><span class="line">		(!B) ? ++A.y : A.x=A.x*B%mod;</span><br><span class="line">		<span class="keyword">return</span> A;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">friend</span> mat <span class="keyword">operator</span> /(mat A,<span class="keyword">int</span> B)&#123;</span><br><span class="line">		(!B) ? --A.y : A.x=A.x*inv[B]%mod;</span><br><span class="line">		<span class="keyword">return</span> A;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">val</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> y ? <span class="number">0</span> : x;&#125;</span><br><span class="line">&#125;lF[N][M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FWT</span><span class="params">(<span class="keyword">int</span> *f,<span class="keyword">int</span> n,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;n;j+=(i&lt;&lt;<span class="number">1</span>)) <span class="keyword">for</span>(rei k=<span class="number">0</span>;k&lt;i;++k)&#123;</span><br><span class="line">        rei t1=f[j+k],t2=f[j+i+k];</span><br><span class="line">        f[j+k]=<span class="built_in">add</span>(t1+t2),f[j+i+k]=<span class="built_in">add</span>(t1-t2+mod);</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">-1</span>) f[j+k]=f[j+k]*inv2%mod,f[j+i+k]=f[j+i+k]*inv2%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Tr&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fath)</span></span>&#123;</span><br><span class="line">        fa[x]=fath,depth[x]=depth[fath]+<span class="number">1</span>,Size[x]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(rei i=head[x];i;i=Next[i])&#123;</span><br><span class="line">            rei y=ver[i]; <span class="keyword">if</span>(y==fath) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs1</span>(y,x),Size[x]+=Size[y];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> anc)</span></span>&#123;</span><br><span class="line">        rei heavy=<span class="number">0</span>,MAX=<span class="number">0</span>; pos[x]=++cnt,repos[cnt]=x;</span><br><span class="line">        <span class="keyword">for</span>(rei i=head[x];i;i=Next[i])&#123;</span><br><span class="line">            rei y=ver[i]; <span class="keyword">if</span>(y==anc || Size[y]&lt;=MAX) <span class="keyword">continue</span>;</span><br><span class="line">            MAX=Size[y],heavy=y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!heavy) <span class="keyword">return</span> bot[ top[x] ]=pos[x],<span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">        hson[x]=heavy,top[heavy]=top[x],<span class="built_in">dfs2</span>(heavy,x);</span><br><span class="line">        <span class="keyword">for</span>(rei i=head[x];i;i=Next[i])&#123;</span><br><span class="line">            rei y=ver[i]; <span class="keyword">if</span>(y==anc || y==heavy) <span class="keyword">continue</span>;</span><br><span class="line">            top[y]=y,<span class="built_in">dfs2</span>(y,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> INIT&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> anc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;m;++i) F[x][i]=e[ v[x] ][i];</span><br><span class="line">        <span class="keyword">for</span>(rei i=head[x];i;i=Next[i])&#123;</span><br><span class="line">            rei y=ver[i];</span><br><span class="line">            <span class="keyword">if</span>(y==anc) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(y,x);</span><br><span class="line">            <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;m;++j)&#123;</span><br><span class="line">                F[x][j]=<span class="built_in">add</span>(F[x][j]+F[x][j]*F[y][j]%mod);</span><br><span class="line">                H[x][j]=<span class="built_in">add</span>(H[x][j]+H[y][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;m;++i) H[x][i]=<span class="built_in">add</span>(H[x][i]+F[x][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getl</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(rei x=<span class="number">1</span>;x&lt;=n;++x)&#123;</span><br><span class="line">            <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;m;++i) lF[x][i].<span class="built_in">put_val</span>(e[<span class="number">0</span>][i]),lH[x][i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(rei i=head[x];i;i=Next[i])&#123;</span><br><span class="line">                rei y=ver[i];</span><br><span class="line">                <span class="keyword">if</span>(y==fa[x] || y==hson[x]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;m;++j)&#123;</span><br><span class="line">                    lF[x][j]=lF[x][j]*<span class="built_in">add</span>(<span class="number">1</span>+F[y][j]);</span><br><span class="line">                    lH[x][j]=<span class="built_in">add</span>(lH[x][j]+H[y][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> ST&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tree_node</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> a[M],b[M],c[M],d[M];</span><br><span class="line">        <span class="keyword">friend</span> tree_node <span class="keyword">operator</span> *(tree_node A,tree_node B)&#123;</span><br><span class="line">            tree_node C;</span><br><span class="line">            <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;m;++i) C.a[i]=C.b[i]=C.c[i]=C.d[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;m;++i) &#123;</span><br><span class="line">                C.a[i]=A.a[i]*B.a[i]%mod;</span><br><span class="line">                C.b[i]=<span class="built_in">add</span>(A.b[i]+A.a[i]*B.b[i]%mod);</span><br><span class="line">                C.c[i]=<span class="built_in">add</span>(B.a[i]*A.c[i]%mod+B.c[i]);</span><br><span class="line">                C.d[i]=<span class="built_in">add</span>(B.b[i]*A.c[i]%mod+<span class="built_in">add</span>(A.d[i]+B.d[i]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> C;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123; tr[now]=tr[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]*tr[now&lt;&lt;<span class="number">1</span>];&#125;<span class="comment">//注意合并的顺序啊啊啊</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;m;++j)&#123;</span><br><span class="line">            tr[i].a[j]=tr[i].b[j]=tr[i].c[j]=tr[i].d[j]=lF[x][j].<span class="built_in">val</span>()*e[ v[x] ][j]%mod;</span><br><span class="line">            tr[i].d[j]=<span class="built_in">add</span>(tr[i].d[j]+lH[x][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r) <span class="keyword">return</span> <span class="built_in">update</span>(now,repos[l]),<span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">        rei mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(now&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">build</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">pushup</span>(now);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">tree_node <span class="title">query</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) <span class="keyword">return</span> tr[now];</span><br><span class="line">        rei mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(R&lt;=mid) <span class="keyword">return</span> <span class="built_in">query</span>(now&lt;&lt;<span class="number">1</span>,l,mid,L,R);</span><br><span class="line">        <span class="keyword">if</span>(mid+<span class="number">1</span>&lt;=L) <span class="keyword">return</span> <span class="built_in">query</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,L,R);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,L,R)*<span class="built_in">query</span>(now&lt;&lt;<span class="number">1</span>,l,mid,L,R);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r) <span class="keyword">return</span> <span class="built_in">update</span>(now,repos[l]),<span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">        rei mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        x&lt;=mid ? <span class="built_in">change</span>(now&lt;&lt;<span class="number">1</span>,l,mid,x) : <span class="built_in">change</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,x);</span><br><span class="line">        <span class="built_in">pushup</span>(now);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">getans</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        tree_node re=<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,pos[x],bot[x]);</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;m;++i) tmp1[i]=re.c[i],tmp2[i]=re.d[i];<span class="comment">//F,H</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> new_v)</span></span>&#123;</span><br><span class="line">    v[x]=new_v;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        rei y=fa[ top[x] ];</span><br><span class="line">        ST::<span class="built_in">getans</span>(top[x]);</span><br><span class="line">        <span class="keyword">if</span>(y) <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;m;++i) lF[y][i]=lF[y][i]/<span class="built_in">add</span>(tmp1[i]+<span class="number">1</span>), lH[y][i]=<span class="built_in">add</span>(lH[y][i]-tmp2[i]+mod);</span><br><span class="line">        ST::<span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,pos[x]),ST::<span class="built_in">getans</span>(top[x]);</span><br><span class="line">        <span class="keyword">if</span>(y) <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;m;++i) lF[y][i]=lF[y][i]*<span class="built_in">add</span>(tmp1[i]+<span class="number">1</span>),lH[y][i]=<span class="built_in">add</span>(lH[y][i]+tmp2[i]);</span><br><span class="line">        x=y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> op[<span class="number">10</span>]; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;v[i]);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>,x,y;i&lt;n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y),<span class="built_in">add</span>(x,y),<span class="built_in">add</span>(y,x);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;m;++i) e[i][i]=<span class="number">1</span>,<span class="built_in">FWT</span>(e[i],m,<span class="number">1</span>);</span><br><span class="line">	inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;mod;++i) inv[i]=(mod-mod/i)*inv[mod%i]%mod;</span><br><span class="line">	Tr::<span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>),top[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    Tr::<span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    INIT::<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>),INIT::<span class="built_in">getl</span>();</span><br><span class="line">    ST::<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;Q);</span><br><span class="line">	<span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op); rei x,y;</span><br><span class="line">		<span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;C&#x27;</span>) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y),<span class="built_in">change</span>(x,y);</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x),ST::<span class="built_in">getans</span>(<span class="number">1</span>);</span><br><span class="line">			<span class="built_in">FWT</span>(tmp2,m,<span class="number">-1</span>),<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tmp2[x]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>多项式</tag>
        <tag>生成函数</tag>
        <tag>动态dp</tag>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title>概率与期望</title>
    <url>/2021/10/08/%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/</url>
    <content><![CDATA[<h2 id="一些-text-trick"><a href="#一些-text-trick" class="headerlink" title="一些 $\text{trick}$"></a>一些 $\text{trick}$</h2><p>定义 $E(x)$ 表示随机变量 $x$ 的期望值，即，$E(x)=\sum P(x=i)\times i$</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>先定义目标状态的期望 $E(S)$</p>
<p>用期望的线性性拆成若杠 $\sum E(x_{0,1,2,….})$ 并分类</p>
<p>对于每一类找递推式或直接算的式子，或考虑引入新的值来辅助计算</p>
<h3 id="技巧-套路"><a href="#技巧-套路" class="headerlink" title="技巧/套路"></a>技巧/套路</h3><p>由等比数列求和得：</p>
<script type="math/tex; mode=display">\sum_{i=0}^n x^i=\frac{1-x^{n+1}}{1-x}</script><p>$n\rightarrow \infty,x\in (0,1)$ 时</p>
<script type="math/tex; mode=display">\sum_{i=0}^{\infty} x^i=\frac{1}{1-x}</script><ul>
<li><p>期望的性质</p>
<p><strong>线性性</strong>： $E(x+y)=E(x)+E(y)$</p>
<p>不相关可积性： $E(xy)=E(x)\times E(y)$</p>
</li>
</ul>
<p>对于离散变量 $x$ ：$P(x=k)=P(x\leq k)-P(x\leq k-1)$</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><blockquote>
<p>$n$ 个随机变量 $x_i,\forall x_i,1\leq x_i\leq S$ ，求 $\max_{1\leq i\leq n} x_i$ 的期望</p>
</blockquote>
<script type="math/tex; mode=display">\begin{aligned}
E(\max)&=\sum_{i=1}^S P(\max=i)\times i \\
&=\sum_{i=1}^S \left(P(\max\leq i)-P(\max\leq i-1)\right)\times i \\
&=\sum_{i=1}^S \left(\frac{i^n}{S^n}-\frac{(i-1)^n}{S^n} \right)\times i
\end{aligned}</script><h3 id="拿球问题"><a href="#拿球问题" class="headerlink" title="拿球问题"></a>拿球问题</h3><blockquote>
<p>$n$ 个球，拿 $m$ 次，求拿出的数字之和期望</p>
</blockquote>
<script type="math/tex; mode=display">\sum_{i=1}^n P(i)\times i=\sum_{i=1}^n \frac{m}{n}\times i=\frac{m(n+1)}{2}</script><p>其中是否放回对答案无影响</p>
<blockquote>
<p>拿出求后有 $p_1$ 的概率放回，$p_2$ 的概率放回两个和该球相同的，求期望</p>
</blockquote>
<p>感性理解一下，答案不变</p>
<h3 id="游走问题"><a href="#游走问题" class="headerlink" title="游走问题"></a>游走问题</h3><blockquote>
<p>链上从一段到另一端的期望步数</p>
</blockquote>
<p>设 $X_i$ 表示 随机游走下 $i$ 第一次到 $i+1$ 的步数</p>
<script type="math/tex; mode=display">E(X_2)=\frac{1}{2}+\frac{1}{2}\times (1+E(X_1)+E(X_2))</script><script type="math/tex; mode=display">E(X_i)=\frac{1}{2}+\frac{1}{2}\times (1+E(X_{i-1})+E(X_i))=E(X_{i-1})+2</script><script type="math/tex; mode=display">E(ans)=\sum_{i=1}^{n-1}E(X_i)=(n-1)^2</script><blockquote>
<p>完全图上，从一个点到另一个点的期望</p>
</blockquote>
<p>$\frac{1}{n-1}$ 成功，则期望步数即为 $n-1$</p>
<blockquote>
<p>$2n$ 点的完全二分图上游走</p>
</blockquote>
<p>设 $E_a$ 表示在同侧的期望步数，$E_b$ 表示在异侧的期望步数，有：</p>
<script type="math/tex; mode=display">\begin{cases}
E_b=\frac{1}{n}+\frac{n-1}{n}(E_b+2) &\text{前者是到另一侧的期望步数，后者是另一侧又到另一侧的步数，系数表示不需要自己走回自己}\\
E_b=E_a+1 \\
\end{cases}</script><p>解得</p>
<script type="math/tex; mode=display">\begin{cases}
E_b=n+1 \\
E_a=n \\
\end{cases}</script><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><blockquote>
<p>每次随机一个整数 $[1,n]$ ，求凑齐所有数的期望次数</p>
</blockquote>
<p>单次概率 $P=\frac{n-i+1}{n}$</p>
<p>期望即为 $E(x)=\sum_{i=1}^n\frac{1}{p_i}$</p>
<blockquote>
<p>随机长度为 $n$ 的排列 $P$ ，求 $\max=P_i$ 的 $i$ 的个数的平方的期望和</p>
</blockquote>
<p>设 $X_i$ 表示 $i$ 是否满足条件的期望</p>
<p>要求的为：$E\left(\left(\sum_{i}^n X_i\right)^2\right)$</p>
<p>若 $i$ 被选，$X_i$ 就是 $1$ ，否则为 $0$ ，所以平方无意义</p>
<script type="math/tex; mode=display">\left(\sum_{i=1}^n X_i\right)^2=\sum_{i,j,i<j}^n \left(X_i\times X_j+X_i^2\right)</script><script type="math/tex; mode=display">原式=\sum_{i,j,i<j}^n\left(E(X_i\times X_j+X_i)\right)=\sum_{i=1}^n E(X_i)+\sum_{i,j,i<j}^n E(X_i\times X_j)</script><p>由于 $X_i,X_j$ 相互独立，则有：</p>
<script type="math/tex; mode=display">原式=\sum_{i=1}^n \frac{1}{n}+\sum_{i=1,j>i}\frac{1}{i\times j}</script><blockquote>
<p>随机长度为 $n$ 的排列 $P$ ，求其包含 $w_{1\sim m}$ 作为子序列/连续子序列的概率</p>
</blockquote>
<ul>
<li><p>第一问</p>
<script type="math/tex; mode=display">\binom{n}{m}\times \frac{(n-m)!}{n!}=\frac{1}{m!}</script></li>
<li><p>第二问</p>
<p>  取 $m$ 个位置，第一个位置 $n$ 种，第二个 $n-1$ 种，一直乘到 $n-m+1$ 种，在这 $m$ 个位置选出正确的 $w_i$ 的概率为</p>
<script type="math/tex; mode=display">\prod_{i=n-m+1}^n\frac{1}{i}=\frac{(n-m)!}{n!}</script><p>  再枚举开头，有 $n-m+1$ 种，即有</p>
<script type="math/tex; mode=display">ans=\frac{(n-m)!}{n!}\times (n-m+1)=\frac{(n-m+1)!}{n!}</script></li>
</ul>
<blockquote>
<p>$n$ 堆石头，第 $i$ 堆有 $a_i$ 个，每次随机选一个石头并扔掉其所在堆的所有石头，求第 $1$ 堆石头期望第几次被扔掉</p>
</blockquote>
<p>设 $X_i$ 表示 $i$ 是第 $X_i$ 次被拿走，即有 $X_i=\sum_{i-1}^m [X_i\leq X_1]$</p>
<script type="math/tex; mode=display">\begin{aligned}
E(X_1)&=\sum_{i=2}^n E([E_x\leq E_1])+1 \\
&=\sum_{i=2}^n P([E_x\leq E_1])+1 \\
&=\left(\sum_{i=1}^n \frac{a_i}{a_1-a_i}\right)+1 \\
\end{aligned}</script><blockquote>
<p>随机长度 $n$ 的 $01$ 串 $S$ ，每个位置为 $1$ 的概率为 $p$ ，定义 $ans$ 是每段连续 $1$ 长度的平方之和，求 $E(ans)$</p>
</blockquote>
<p>定义 $X_i$ 表示以 $i$ 结尾时1的答案，$Y_i$ 表示以 $i$ 结尾时后缀 $1$ 的个数</p>
<ul>
<li><p>$S_{i+1}=0$</p>
<script type="math/tex; mode=display">Y_{i+1}=0,X_{i+1}=X_i</script></li>
<li><p>$S_{i+1}=1$</p>
<script type="math/tex; mode=display">Y_{i+1}=Y_i+1,X_{i+1}=X_i-Y_i^2+(Y_i+1)^2=X_i+2\times Y_i+1</script></li>
</ul>
<p>且有 $E(X_n)=E(ans)$</p>
<p>那么有</p>
<script type="math/tex; mode=display">E(X_n)=p\times (\ E(X_{n-1})+2\times E(Y_{n-1}+1)\ )+(1-p)\times E(x_{n-1})</script><script type="math/tex; mode=display">E(Y_n)=p\times (1+E(Y_{n-1}))+(1-p)\times 0</script><blockquote>
<p>给定序列，每次随机删除一个元素，求 $ij$ 在过程中相邻的概率</p>
</blockquote>
<p>将 $ij$ 中间的数全排列，$ij$ 在最后的方案数除以总数</p>
<script type="math/tex; mode=display">P=\frac{2\times (j-i-1)!}{(j-i+1)!}=\frac{2}{(j-i)(j-i+1)}</script><blockquote>
<p>给定 $1\sim n$ 这 $n$ 个数，每次随机选择一个并删除其所有约数，求删完的期望</p>
</blockquote>
<p>题意转化为随机删除 $x$ ，若其未被标记则标记其所有的约数，求期望选到多少个没被标记的 $x$</p>
<p>设 $X_i$ 表示 $i$ 在没被标记前就被删掉的期望</p>
<script type="math/tex; mode=display">E(ans)=\sum_{i=1}^n E(X_i)=\sum_{i=1}^n\frac{1}{\left\lfloor\frac{i}{n} \right\rfloor}</script><p>即，$i$ 的倍数有 $\left\lfloor\frac{i}{n} \right\rfloor$ 个， $i$ 最早被删除的概率即为 $\frac{1}{\left\lfloor\frac{i}{n} \right\rfloor}$</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><blockquote>
<p>给定 $n$ 个硬币，价值为 $val_i$ ，每次随机取走一个，获得的收益时左右两个硬币价值的乘积，求总期望</p>
</blockquote>
<p>设 $x_{i,j}=[ij是否相遇]$</p>
<p>那么总价值为 $S=\sum_{i,j} x_{i,j}\times w_i\times w_j$</p>
<p>由期望的线性性可知</p>
<script type="math/tex; mode=display">E(S)=\sum_{i,j,i<j}^n E(x_{i,j})\times w_i\times w_j=\sum_{i,j,i<j}^n \frac{2\times w_i\times w_j}{(j-i)\times (j-i+1)}</script><blockquote>
<p>$n$ 个数 $a_{1\sim n}$ 每次等概率选出两个数，合并在一起为一个新数并放回，得到的收益时新的数的值，求总收益期望</p>
</blockquote>
<p>设 $X_i$ 表示 $a_i$ 被选的次数</p>
<p>总收益即为 $S=\sum_{i=1}^n X_i\times a_i$</p>
<script type="math/tex; mode=display">E(S)=\sum_{i=1}^n E(X_i)\times a_i</script><p>一个数 $a_x$ 在第 $j$ 次被合并的概率和是 $\sum_{j=1}^{n-1}\frac{2}{n-j+1}$ ，即，每个数独立，第 $j$ 次还剩 $n-j+1$ 个数</p>
<p>那么有：</p>
<script type="math/tex; mode=display">E(S)=\sum_{i=1}^n\sum_{j=1}^{n-1}\frac{2\times a_i}{n-j+1}</script><h2 id="刷一波期望-tag-下的题"><a href="#刷一波期望-tag-下的题" class="headerlink" title="刷一波期望 tag 下的题"></a>刷一波期望 <code>tag</code> 下的题</h2><h3 id="P3232-HNOI2013-游走"><a href="#P3232-HNOI2013-游走" class="headerlink" title="P3232 [HNOI2013]游走"></a><a href="https://www.luogu.com.cn/problem/P3232">P3232 [HNOI2013]游走</a></h3><blockquote>
<p>$n$ 个点 $m$ 个边的无向连通图，在该图上随机游走，每一步中以相等概率随机选择当前点的某条边，沿该边走后获得该边编号的分数，到 $n$ 时游走结束，对 $m$ 条边编号使总分的期望值最小</p>
</blockquote>
<p>由数据范围 $1\leq n\leq 500,1\leq m\leq 125000$ 可以考虑到：<strong>若直接考虑边的期望经过次数时间复杂度不能接受，所以先考虑点的期望经过次数</strong>，即：</p>
<script type="math/tex; mode=display">f_i=\begin{cases}
\sum_{i,j\in E,j!=n} \frac{f_j}{deg_j}+1 &\text{ $i=1$ } \\
\sum_{i,j\in E,j!=n} \frac{f_j}{deg_j} \\
0 &\text{ $i=n$ } \\
\text{注意这里面是 $deg_j$ 而不是 $deg_i$ } \\
\end{cases}</script><p>对于这 $n-1$ 个式子(没有 $n$ ) ，用高斯消元求解易得</p>
<p>那么边的期望经过次数即为 $g(u,v)=\frac{f_u}{deg_u}+\frac{f_v}{deg_v}$</p>
<p>直接排序求即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">550</span>,M=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">int</span> head[M],ver[M&lt;&lt;<span class="number">1</span>],Next[M&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line"><span class="keyword">int</span> n,m,s[M&lt;&lt;<span class="number">1</span>],ed[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">double</span> d[N],f[N][N],ans[N],sum,E[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123; ver[++tot]=v; Next[tot]=head[u];head[u]=tot;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123; <span class="keyword">return</span> (x&lt;=eps &amp;&amp; x&gt;=-eps) ? <span class="number">0</span> : (x&gt;<span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">gauss</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">        rei num=i;</span><br><span class="line">        <span class="keyword">for</span>(rei j=i+<span class="number">1</span>;j&lt;n;++j) <span class="keyword">if</span>(<span class="built_in">dcmp</span>(f[j][i]-f[num][i])&gt;<span class="number">0</span>) num=j;</span><br><span class="line">        <span class="keyword">if</span>(num!=i) <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=n;++j) <span class="built_in">swap</span>(f[i][j],f[num][j]);</span><br><span class="line">        <span class="keyword">for</span>(rei j=i+<span class="number">1</span>;j&lt;n;++j) <span class="keyword">if</span>(<span class="built_in">dcmp</span>(f[j][i]))&#123;</span><br><span class="line">            <span class="keyword">double</span> t=f[j][i]/f[i][i];</span><br><span class="line">            <span class="keyword">for</span>(rei k=<span class="number">1</span>;k&lt;=n;++k) f[j][k]-=t*f[i][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=n<span class="number">-1</span>;i;--i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(rei j=i+<span class="number">1</span>;j&lt;n;++j) f[i][n]-=f[i][j]*ans[j];</span><br><span class="line">        ans[i]=f[i][n]/f[i][i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); <span class="built_in">freopen</span>(<span class="string">&quot;1.ans&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,x,y;i&lt;=m;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y),<span class="built_in">add</span>(x,y),<span class="built_in">add</span>(y,x),++d[x],++d[y],s[i]=x,ed[i]=y;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">        f[i][i]=<span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span>(rei j=head[i];j;j=Next[j])&#123;</span><br><span class="line">            rei y=ver[j]; <span class="keyword">if</span>(y==n) <span class="keyword">continue</span>;</span><br><span class="line">            f[i][y]=<span class="number">-1</span>/d[y];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">1</span>][n]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">gauss</span>();</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=m;++i) E[i]=ans[ s[i] ]/d[ s[i] ]+ans[ ed[i] ]/d[ ed[i] ];</span><br><span class="line">    <span class="built_in">sort</span>(E+<span class="number">1</span>,E+<span class="number">1</span>+m);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=m;++i) sum+=E[i]*(m-i+<span class="number">1.0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.3lf\n&quot;</span>,sum);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P3239-HNOI2015-亚瑟王"><a href="#P3239-HNOI2015-亚瑟王" class="headerlink" title="P3239 [HNOI2015]亚瑟王"></a><a href="https://www.luogu.com.cn/problem/P3239">P3239 [HNOI2015]亚瑟王</a></h3><blockquote>
<p>$n$ 张卡牌，第 $i$ 张发动技能的概率为 $p_i$ ，若成功发动会造成 $d_i$ 点伤害，一局游戏有 $r$ 轮，每一轮中，从第一张开始按照顺序出牌：若当前第 $i$ 牌已成功发动过则跳过，若是最后一张则结束该；否则以 $p_i$ 的概率发动，若成功则结束该轮，否则考虑下一张</p>
</blockquote>
<p>题中的 $p_i$ 并不能直接推出答案，考虑设 $fp_i$ 表示牌 $i$ 在所有的 $r$ 轮中被使用的概率，如此有答案 $\sum fp_i\times d_i$</p>
<ul>
<li><p>对于 $fp_i$</p>
<p>显然有 $fp_1=1-(1-p_1)^r$</p>
<p>考虑第 $2$ 张牌，若第 $1$ 张牌发动则有 $fp_2=1-(1-p_2)^{r-1}$ ，若没有发动则有 $fp_2=1-(1-p_2)^r$</p>
<p>那么有结论：若已经确定 $\forall i&gt;1$ 在 $1\sim i-1$ 张牌在所有 $r$ 轮种是否发动技能，$fp_i$ 仅取决于 $1\sim i-1$ 有多少张发动的牌，即 $fp_i=1-(1-p_i)^{r-j}$</p>
</li>
</ul>
<p>显然需要一个 $dp$ 来维护，即 $f_{i,j}$ 表示 $r$ 轮中前 $i$ 张牌中有 $j$ 张发动的概率，则有</p>
<script type="math/tex; mode=display">f_{i,j}+=
\begin{cases}
(1-(1-p_i)^{r-j+1})\times f_{i-1,j-1} &\text{$i$ 发动，此时有 $j-1$ 轮不能发动} \\
(1-p_i)^{r-j}\times f_{i-1,j} &\text{$i$ 不发动，那么有 $j$ 轮不能发动} \\
\end{cases}</script><p>那么易得 $fp$ :</p>
<script type="math/tex; mode=display">fp_i=\sum_{j=0}^{min(i-1,j)} (1-(1-p_i)^{r-j})\times f_{i-1,j}</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">250</span>,M=<span class="number">150</span>;</span><br><span class="line"><span class="keyword">int</span> n,r,d[N];</span><br><span class="line"><span class="keyword">double</span> p[N],fp[N],pow_j[N][N];<span class="comment">//pow_j[i][j]: (1-p[i])^j</span></span><br><span class="line"><span class="keyword">double</span> f[N][M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		pow_j[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=r;++j) pow_j[i][j]=pow_j[i][j<span class="number">-1</span>]*(<span class="number">1</span>-p[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f); <span class="built_in">memset</span>(fp,<span class="number">0</span>,<span class="keyword">sizeof</span> fp);</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>]=pow_j[<span class="number">0</span>][r]; f[<span class="number">0</span>][<span class="number">1</span>]=fp[<span class="number">0</span>]=<span class="number">1</span>-f[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;n;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;=r;++j)&#123;</span><br><span class="line">		fp[i]+=f[i<span class="number">-1</span>][j]*(<span class="number">1</span>-pow_j[i][r-j]);<span class="comment">//对于前i-1张，j轮不考虑第i张，r-j轮考虑</span></span><br><span class="line">		f[i][j]+=f[i<span class="number">-1</span>][j]*(pow_j[i][r-j]);<span class="comment">//不选第i张</span></span><br><span class="line">		<span class="keyword">if</span>(j) f[i][j]+=f[i<span class="number">-1</span>][j<span class="number">-1</span>]*(<span class="number">1</span>-pow_j[i][r-j+<span class="number">1</span>]);<span class="comment">//选第i张</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">double</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;n;++i) res+=d[i]*fp[i];</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	rei T; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;r);</span><br><span class="line">		<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lf%d&quot;</span>,&amp;p[i],&amp;d[i]);</span><br><span class="line">		<span class="built_in">init</span>();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%.10lf\n&quot;</span>,<span class="built_in">solve</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P4284-SHOI2014-概率充电器"><a href="#P4284-SHOI2014-概率充电器" class="headerlink" title="P4284 [SHOI2014]概率充电器"></a><a href="https://www.luogu.com.cn/problem/P4284">P4284 [SHOI2014]概率充电器</a></h3><blockquote>
<p>一个树形结构，每个点有 $p_i$ 的概率直接被充电，随后直接充电的点以 $edge_{i,j}$ 的概率给其他点间接充电，求进入充电状态的点的个数期望</p>
<p>注意：被间接充电的点也可以给其他点充电</p>
</blockquote>
<p>先考虑一个点有电的情况：</p>
<script type="math/tex; mode=display">\begin{cases}
&\text{自身以 $q_i$ 的概率充电} \\
&\text{被其 $son$ 充电} \\
&\text{被其 $fa$ 充电} \\
\end{cases}</script><p>树形图容易考虑到一个 $trick$ : $\text{up \ and \ down}$ ：先从下往上推得前两种情况，再从根往下推第三种</p>
<p>具体的，设每个点的初始概率即为 $q_i\%$</p>
<ul>
<li><p>对于 $up$ 操作：</p>
<p>设事件 $A$ 表示点 $i$ 直接充电，事件 $B$ 表示点 $i$ 被子节点间接充电，那么至少发生一件的概率为 $P(A)+P(B)-P(A)\times P(B)$</p>
<p>即，$h_i=h_i+h_j\times edge_{i,j}-h_i\times h_j\times edge_{i,j},\quad j\in son_i$</p>
</li>
<li><p>对于 $down$ 操作：</p>
<p>即，用父亲有电来更新儿子</p>
<p>设事件 $A$ 表示除了子树 $j$ 以外的使 $i$ 有电的概率，又有 $P(B)=h_j\times edge_{i,j}$</p>
<p>那么有 $P(A)=\frac{h_i-P(B)}{1-P(B)}$ , $h_j=h_j+P(A)\times edge_{i,j}-h_j\times P(A)\times edge_{i,j}$</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> head[N],Next[N&lt;&lt;<span class="number">1</span>],ver[N&lt;&lt;<span class="number">1</span>],val[N&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line"><span class="keyword">int</span> a[N],depth[N];</span><br><span class="line"><span class="keyword">double</span> h[N],ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> z)</span></span>&#123; ver[++tot]=v; Next[tot]=head[u],head[u]=tot,val[tot]=z;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span></span>&#123; <span class="keyword">return</span> (x+eps&gt;y &amp;&amp; x-eps&lt;y) ? <span class="number">1</span> : <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(rei i=head[x];i;i=Next[i])&#123;</span><br><span class="line">        rei y=ver[i]; <span class="keyword">if</span>(depth[y]) <span class="keyword">continue</span>;</span><br><span class="line">        depth[y]=depth[x]+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">up</span>(y);</span><br><span class="line">        <span class="keyword">double</span> P2=h[y]*(<span class="keyword">double</span>) val[i]/<span class="number">100</span>;</span><br><span class="line">        h[x]=h[x]+P2-h[x]*P2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    ans+=h[x];</span><br><span class="line">    <span class="keyword">for</span>(rei i=head[x];i;i=Next[i])&#123;</span><br><span class="line">        rei y=ver[i]; <span class="keyword">if</span>(depth[y]&lt;=depth[x]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(h[y]*(<span class="keyword">double</span>) val[i]/<span class="number">100</span>,<span class="number">1</span>))&#123; <span class="built_in">down</span>(y); <span class="keyword">continue</span>;&#125;<span class="comment">//h_j已经是1，不需要再更新</span></span><br><span class="line">        <span class="keyword">double</span> P2=(h[x]-h[y]*(<span class="keyword">double</span>) val[i]/<span class="number">100</span>)/(<span class="number">1</span>-h[y]*(<span class="keyword">double</span>) val[i]/<span class="number">100</span>);</span><br><span class="line">        P2*=(<span class="keyword">double</span>) val[i]/<span class="number">100</span>;</span><br><span class="line">        h[y]=h[y]+P2-P2*h[y];</span><br><span class="line">        <span class="built_in">down</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,x,y,z;i&lt;n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z),<span class="built_in">add</span>(x,y,z),<span class="built_in">add</span>(y,x,z);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]),h[i]=a[i]*<span class="number">0.01</span>;</span><br><span class="line">    depth[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">up</span>(<span class="number">1</span>); <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.6lf\n&quot;</span>,ans);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P2221-HAOI2012-高速公路"><a href="#P2221-HAOI2012-高速公路" class="headerlink" title="P2221 [HAOI2012]高速公路"></a><a href="https://www.luogu.com.cn/problem/P2221">P2221 [HAOI2012]高速公路</a></h3><blockquote>
<p>给定一个 $1\sim n$ 区间，要求区间加，并求出 $[l,r]$ 中等概率选取两点之间的期望距离</p>
</blockquote>
<p>显然需要用线段树来维护一些东西，考虑答案的形式：</p>
<script type="math/tex; mode=display">ans=\frac{\sum_{i=l}^r\sum_{j=i}^r (pre_j-pre_i)}{\binom{r-l+1}{2}}</script><p>考虑如何用线段树维护分子：</p>
<p>一个 $trick$ 是枚举 $[l,r]$ 中每一个位置被包含多少次：</p>
<p>$l$ ：被 $[l,l],[l,l+1],…$ 等 $r-l+1$ 个包含</p>
<p>$l+1$ ：被 $[l+1,l+1],[l+1,l+2],…[l,l+1],[l,l+2],…$ 等 $2(r-l)$ 个包含</p>
<p>$l+i$ ：以 $l+i$ 开头的包含 $r-i+1$ 次 $\cup$ 以 $l+i-1$ 开头的包含 $r-i+1$ 次 $\cup…\cup$ 以 $l$ 开头的 包含$r-i+1$ 次 $\Leftrightarrow$ $(r-i+1)(i-l+1)$</p>
<p>此时需要维护的分子转化为：</p>
<script type="math/tex; mode=display">\begin{aligned}
分子&=\sum_{i=l}^r a_i\times (r-i+1)\times (i-l+1) \\
&=-\sum_{i=l}^r a_i\times i^2+\sum_{i=l}^r a_i\times i\times (r-l)+\sum_{i=l}^r a_i\times (r-l+1-lr) &\text{拆开并化简得} \\
\end{aligned}</script><p>这样就能用线段树维护了，具体的，分别用 $ai_0,ai_1,ai_2$ 维护 $\sum a_i,\sum a_i\times i,\sum a_i\times i^2$</p>
<p>对于区间修改，不难想到再额外维护 $sumi_1,sumi_2$ 表示 $\sum i,\sum i^2$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SGT&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">        ll ai_0,ai_1,ai_2,sum_i,sum_i2;</span><br><span class="line">        ll lazy;</span><br><span class="line">    &#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">        tr[now].ai_0=tr[now&lt;&lt;<span class="number">1</span>].ai_0+tr[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].ai_0;</span><br><span class="line">        tr[now].ai_1=tr[now&lt;&lt;<span class="number">1</span>].ai_1+tr[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].ai_1;</span><br><span class="line">        tr[now].ai_2=tr[now&lt;&lt;<span class="number">1</span>].ai_2+tr[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].ai_2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[now].lazy)&#123;</span><br><span class="line">            rei mid=l+r&gt;&gt;<span class="number">1</span>,w=tr[now].lazy;</span><br><span class="line">            tr[now&lt;&lt;<span class="number">1</span>].lazy+=(ll) w,tr[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lazy+=(ll) w;</span><br><span class="line">            tr[now&lt;&lt;<span class="number">1</span>].ai_0+=(ll) (mid-l+<span class="number">1</span>)*w,tr[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].ai_0+=(ll) (r-mid)*w;</span><br><span class="line">            tr[now&lt;&lt;<span class="number">1</span>].ai_1+=(ll) w*tr[now&lt;&lt;<span class="number">1</span>].sum_i,tr[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].ai_1+=(ll) w*tr[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum_i;</span><br><span class="line">            tr[now&lt;&lt;<span class="number">1</span>].ai_2+=(ll) w*tr[now&lt;&lt;<span class="number">1</span>].sum_i2,tr[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].ai_2+=(ll) w*tr[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum_i2;</span><br><span class="line">            tr[now].lazy=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r) <span class="keyword">return</span> tr[now].sum_i=l,tr[now].sum_i2=(ll) l*l,<span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">        rei mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(now&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">build</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">        tr[now].sum_i=tr[now&lt;&lt;<span class="number">1</span>].sum_i+tr[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum_i;</span><br><span class="line">        tr[now].sum_i2=tr[now&lt;&lt;<span class="number">1</span>].sum_i2+tr[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum_i2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R,ll w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;R || r&lt;L) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=L &amp;&amp; r&lt;=R)&#123;</span><br><span class="line">            tr[now].ai_0+=(ll) (r-l+<span class="number">1</span>)*w;tr[now].ai_1+=(ll) w*tr[now].sum_i;</span><br><span class="line">            tr[now].ai_2+=(ll) w*tr[now].sum_i2;tr[now].lazy+=w;<span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushdown</span>(now,l,r);</span><br><span class="line">        rei mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">update</span>(now&lt;&lt;<span class="number">1</span>,l,mid,L,R,w),<span class="built_in">update</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,L,R,w);</span><br><span class="line">        <span class="built_in">pushup</span>(now);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R,ll &amp;ai_0,ll &amp;ai_1,ll &amp;ai_2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;R || r&lt;L) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=L &amp;&amp; r&lt;=R) <span class="keyword">return</span> ai_0+=tr[now].ai_0,ai_1+=tr[now].ai_1,ai_2+=tr[now].ai_2,<span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">        <span class="built_in">pushdown</span>(now,l,r);</span><br><span class="line">        rei mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">query</span>(now&lt;&lt;<span class="number">1</span>,l,mid,L,R,ai_0,ai_1,ai_2);</span><br><span class="line">        <span class="built_in">query</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,L,R,ai_0,ai_1,ai_2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    SGT::<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">char</span> s[<span class="number">2</span>]; ll l,r; <span class="built_in">scanf</span>(<span class="string">&quot;%s%lld%lld&quot;</span>,s,&amp;l,&amp;r);</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;C&#x27;</span>)&#123;</span><br><span class="line">            ll w; <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;w);</span><br><span class="line">            <span class="keyword">if</span>(l==r) <span class="keyword">continue</span>;</span><br><span class="line">            SGT::<span class="built_in">update</span>(<span class="number">1</span>,<span class="number">1</span>,n,l+<span class="number">1</span>,r,w);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ll S1=<span class="number">0</span>,S2=<span class="number">0</span>,S3=<span class="number">0</span>;</span><br><span class="line">            SGT::<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,l+<span class="number">1</span>,r,S1,S2,S3);</span><br><span class="line">            ll son=-S3+(l+r+<span class="number">1</span>)*S2+(r-(l+<span class="number">1</span>)-(l+<span class="number">1</span>)*r+<span class="number">1</span>)*S1,mo=(r-l+<span class="number">1</span>)*(r-l)/<span class="number">2</span>;</span><br><span class="line">            ll gcd=__gcd(son,mo);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld\n&quot;</span>,son/gcd,mo/gcd);<span class="comment">//约分</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P4564-CTSC2018-假面"><a href="#P4564-CTSC2018-假面" class="headerlink" title="P4564 [CTSC2018]假面"></a><a href="https://www.luogu.com.cn/problem/P4564">P4564 [CTSC2018]假面</a></h3><blockquote>
<p>有两种操作：对于指定的 $id$ ，有 $p$ 的概率对 $id$ 造成 $1$ 点伤害；针对 $k$ 个指定单位并恰好命中一个，命中每个存活的单位的概率相等，若 $k$ 个单位均死亡则不会命中任何地方单位</p>
<p>对于操作 $2$ ，求其命中各敌人的概率分别是多少；所有操作进行完后，所有单位的剩余生命值的期望</p>
</blockquote>
<p>首先两个操作之间是互相独立的</p>
<p>先考虑第 $i$ 个人的剩余生命值期望：$E(i)=\sum_{j=0}^{a_i} j\times f_{i,j}$ ，其中 $f_{i,j}$ 表示第 $i$ 个人的剩余生命值为 $j$ 的期望</p>
<p>每次操作 $1$ 进行后能以 $O(a_i)$ 的复杂度维护 $f_i$ ，即，</p>
<script type="math/tex; mode=display">
\begin{cases}
f_{i,j}=p\times f_{i,j+1}+(1-p)\times f_{i,j} \\
特殊的,f_{i,0}=p\times f_{i,j+1}+f_{i,j} \\
\end{cases}</script><p>设 $g_j$ 表示 $j$ 人存活的概率，$h_{u,j}$ 表示除了 $u$ 还有 $j$ 人存活，那么有：</p>
<script type="math/tex; mode=display">g_j=alive_u\times h_{u,j-1}+dead_u\times h_{u,j}</script><script type="math/tex; mode=display">h_{u,j}=\frac{g_j-alive_u\times h_{u,j-1}}{dead_u}</script><p>可以做到 $O(n^2)$ 预处理并 $O(1)$ 查询</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">210</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line">ll inv[N],a[N],b[N];</span><br><span class="line">ll f[N][<span class="number">105</span>];<span class="comment">//第i个人有j点生命的概率</span></span><br><span class="line">ll g[N];<span class="comment">//g_j:j个人活着的概率</span></span><br><span class="line">ll h[N];<span class="comment">//h_&#123;u,j&#125; 除了u还有j个人</span></span><br><span class="line"><span class="keyword">int</span> n,Q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(ll x,<span class="keyword">int</span> y,ll res=<span class="number">1</span>)</span></span>&#123; <span class="keyword">while</span>(y)&#123; <span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=res*x%mod; y&gt;&gt;=<span class="number">1</span>; x=x*x%mod;&#125;; <span class="keyword">return</span> res;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">(<span class="keyword">int</span> i,ll p)</span></span>&#123;</span><br><span class="line">    ll q=(<span class="number">1</span>-p+mod)%mod;<span class="comment">//不命中</span></span><br><span class="line">    <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;=a[i];++j) j ? f[i][j]=(p*f[i][j+<span class="number">1</span>]%mod+q*f[i][j]%mod)%mod : f[i][j]=(p*f[i][j+<span class="number">1</span>]%mod+f[i][j])%mod;<span class="comment">//特殊的，j=0时其系数q不重要</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span> g); g[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=k;++i)&#123;</span><br><span class="line">        ll alive=(mod+<span class="number">1ll</span>-f[ b[i] ][<span class="number">0</span>])%mod;</span><br><span class="line">        ll dead=(mod+<span class="number">1ll</span>-alive)%mod;</span><br><span class="line">        <span class="keyword">for</span>(rei j=i;j&gt;=<span class="number">0</span>;--j) j ? g[j]=(g[j]*dead+g[j<span class="number">-1</span>]*alive%mod)%mod : g[j]=g[j]*dead%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei u=<span class="number">1</span>;u&lt;=k;++u)&#123;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        ll alive=(mod+<span class="number">1ll</span>-f[ b[u] ][<span class="number">0</span>])%mod,dead=(mod+<span class="number">1ll</span>-alive)%mod;</span><br><span class="line">        <span class="built_in">memset</span>(h,<span class="number">0</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">        <span class="keyword">if</span>(alive!=<span class="number">1</span>)&#123;</span><br><span class="line">            ll invd=<span class="built_in">qpow</span>(dead,mod<span class="number">-2</span>);</span><br><span class="line">            h[<span class="number">0</span>]=g[<span class="number">0</span>]*invd%mod;</span><br><span class="line">            <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;k;++j) h[j]=(g[j]-alive*h[j<span class="number">-1</span>]%mod+mod)%mod*invd%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;=k;++j) h[j]=g[j+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;k;++j) ans=(ans+h[j]*inv[j+<span class="number">1</span>]%mod)%mod;</span><br><span class="line">        ans=ans*alive%mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;1.in&quot;,&quot;r&quot;,stdin); freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        inv[i]=<span class="built_in">qpow</span>(i,mod<span class="number">-2</span>);</span><br><span class="line">        f[i][ a[i] ]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;Q);</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        rei op; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;op);</span><br><span class="line">        <span class="keyword">if</span>(!op)&#123;</span><br><span class="line">            <span class="keyword">int</span> id; ll u,v; <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld%lld&quot;</span>,&amp;id,&amp;u,&amp;v);</span><br><span class="line">            <span class="built_in">attack</span>(id,(ll) u*<span class="built_in">qpow</span>(v,mod<span class="number">-2</span>)%mod);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            rei k; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line">            <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=k;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">            <span class="built_in">solve</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=a[i];++j) ans=(ans+(ll) j*f[i][j]%mod)%mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans); <span class="keyword">if</span>(i!=n) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// puts(&quot;&quot;);</span></span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P6030-SDOI2012-走迷宫"><a href="#P6030-SDOI2012-走迷宫" class="headerlink" title="P6030 [SDOI2012]走迷宫"></a><a href="https://www.luogu.com.cn/problem/P6030">P6030 [SDOI2012]走迷宫</a></h3><blockquote>
<p>给出 $n$ 点 $m$ 边的有向图，有起点 $s$ ,终点 $t$ ，从一个点随机沿一条有向边到另一个点，求到终点的步数期望值</p>
</blockquote>
<p>显然有 $dp_u$ 表示节点 $u$ 走到节点 $n$ 所经过的节点数的期望值，那么有：</p>
<script type="math/tex; mode=display">dp_u=\frac{1}{deg_u}\left(\sum_{u,v\in E}dp_v\right)+1</script><p>由于有环的情况，需要高斯消元，但数据范围并不允许这么做</p>
<p>重新审视题中条件：<strong>每个强连通分量大小 $\leq 100$</strong> ，那么可以用 $tarjan-scc$ 缩点，缩点后即为一个 $DAG$</p>
<p>显然需要倒序计算 $dp$ 值以保证所需的值要么是未知数要么是已经被计算出来的(看作常数)</p>
<p>那么，从 $s$ 开始做缩点所得的强连通分量的编号就是以 $t$ 为起点在 $DAG$ 上做的拓扑所得的拓扑序</p>
<p>那么直接从 $1\sim 强连通分量个数$ 依次在当前强连通分量中做高斯消元即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> S=<span class="number">110</span>,N=<span class="number">1e4</span>+<span class="number">10</span>,M=<span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> INF=<span class="number">1e15</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,s,t;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M&lt;&lt;<span class="number">1</span>],Next[M&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line"><span class="keyword">int</span> bel[N],cnt,dfn[N],low[N],dfn_cnt,stk[N],top;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> id[N],seq[S],subsiz,deg[N];</span><br><span class="line"><span class="keyword">double</span> dp[N],a[S][S],f[S];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; scc[N],rev[N];</span><br><span class="line"><span class="keyword">bool</span> can[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123; ver[++tot]=v,Next[tot]=head[u],head[u]=tot;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(can[x]) <span class="keyword">return</span> ;</span><br><span class="line">    can[x]=<span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> y:rev[x]) <span class="built_in">dfs</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	dfn[x]=low[x]=++dfn_cnt; vis[x]=<span class="number">1</span>; stk[++top]=x;</span><br><span class="line">	<span class="keyword">for</span>(rei i=head[x];i;i=Next[i])&#123;</span><br><span class="line">		rei y=ver[i];</span><br><span class="line">		<span class="keyword">if</span>(!dfn[y]) <span class="built_in">tarjan</span>(y),low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(vis[y]) low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(low[x]==dfn[x])&#123;</span><br><span class="line">		++cnt; rei y;</span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">			y=stk[top--];vis[y]=<span class="number">0</span>;</span><br><span class="line">			scc[ bel[y]=cnt ].<span class="built_in">push_back</span>(y);</span><br><span class="line">		&#125;<span class="keyword">while</span>(y!=x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;s,&amp;t);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>,u,v;i&lt;=m;++i)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v); ++deg[u]; <span class="built_in">add</span>(u,v);</span><br><span class="line">        rev[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">tarjan</span>(s);</span><br><span class="line">    <span class="built_in">dfs</span>(t);</span><br><span class="line">    <span class="keyword">if</span>(!dfn[t]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;INF&quot;</span>),<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=cnt;++i)&#123;</span><br><span class="line">		subsiz=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span> a),<span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> u:scc[i]) seq[++subsiz]=u,id[u]=subsiz;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> u:scc[i])&#123;<span class="comment">//取出连通块 scc_i 内的点并放到代求里</span></span><br><span class="line">			rei p=id[u];</span><br><span class="line">			<span class="keyword">if</span>(u==t)&#123; a[p][p]=<span class="number">1</span>; <span class="keyword">continue</span>;&#125;</span><br><span class="line">			a[p][p]=a[p][subsiz+<span class="number">1</span>]=deg[u];</span><br><span class="line">			<span class="keyword">for</span>(rei i=head[u];i;i=Next[i])&#123;</span><br><span class="line">				rei v=ver[i];</span><br><span class="line">				<span class="keyword">if</span>(bel[v]==bel[u]) --a[p][ id[v] ];</span><br><span class="line">				<span class="keyword">else</span> a[p][subsiz+<span class="number">1</span>]+=dp[v];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(!can[u]) a[p][subsiz+<span class="number">1</span>]=INF;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=subsiz;++j)&#123;<span class="comment">//连通块内做高斯消元</span></span><br><span class="line">			rei t=j;</span><br><span class="line">			<span class="keyword">for</span>(rei k=j+<span class="number">1</span>;k&lt;=subsiz;++k) <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[k][j])&gt;<span class="built_in">fabs</span>(a[t][j])) t=k;</span><br><span class="line">			<span class="keyword">for</span>(rei k=j;k&lt;=subsiz+<span class="number">1</span>;++k) <span class="built_in">swap</span>(a[t][k],a[j][k]);</span><br><span class="line">			<span class="keyword">for</span>(rei k=j+<span class="number">1</span>;k&lt;=subsiz+<span class="number">1</span>;++k) a[j][k]/=a[j][j];</span><br><span class="line">            a[j][j]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(rei k=j+<span class="number">1</span>;k&lt;=subsiz;++k)&#123;</span><br><span class="line">				<span class="keyword">for</span>(rei l=j+<span class="number">1</span>;l&lt;=subsiz+<span class="number">1</span>;++l) a[k][l]-=a[k][j]*a[j][l];</span><br><span class="line">				a[k][j]=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(rei j=subsiz;j;--j)&#123;</span><br><span class="line">			f[j]=a[j][subsiz+<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">for</span>(rei k=j+<span class="number">1</span>;k&lt;=subsiz;++k) f[j]-=f[k]*a[j][k];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=subsiz;++j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(f[j]&gt;<span class="number">1e9</span>) dp[ seq[j] ]=INF;</span><br><span class="line">			<span class="keyword">else</span> dp[ seq[j] ]=f[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	dp[s]&gt;<span class="number">1e9</span> ? <span class="built_in">puts</span>(<span class="string">&quot;INF&quot;</span>) : <span class="built_in">printf</span>(<span class="string">&quot;%.3lf\n&quot;</span>,dp[s]);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P4206-NOI2005-聪聪与可可"><a href="#P4206-NOI2005-聪聪与可可" class="headerlink" title="P4206 [NOI2005] 聪聪与可可"></a><a href="https://www.luogu.com.cn/problem/P4206">P4206 [NOI2005] 聪聪与可可</a></h3><blockquote>
<p>$n$ 点 $m$ 边的有向图，$A$ 在点 $S$ ，$B$ 在点 $T$ ，$B$ 每次 等概率移动至相邻节点或不动，$A$ 每次可以移动 $1$ 步或 $2$ 步来追逐 $B$ ，$A$ 先走 $B$ 后走，求 $A$ 追到 $B$ 的平均步数</p>
</blockquote>
<p>$A$ 的移动方案并不好实时处理，考虑预处理 $go_{i,j}$ 表示 $A$ 在 $i$ ，$B$ 在 $j$ 时，$A$ 下一步最优走到的位置，为此还需处理最短路 $dis_{i,j}$</p>
<p>直接记忆化搜索 $f_{s,t}$ 表示 $A$ 在 $s$ ，$B$ 在 $t$ 时，$A$ 追到 $B$ 的平均步数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS=<span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">int</span> go[N][N],dis[N][N],vis[N];</span><br><span class="line"><span class="keyword">int</span> head[N],ver[N&lt;&lt;<span class="number">1</span>],Next[N&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line"><span class="keyword">int</span> n,m,S,T;</span><br><span class="line"><span class="keyword">double</span> res[N][N],p[N];</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123; ver[++tot]=v; Next[tot]=head[u],head[u]=tot;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">int</span> num)</span></span>&#123; <span class="keyword">return</span> (x-EPS&lt;=<span class="number">0.0</span> &amp;&amp; x+EPS&gt;=<span class="number">0.0</span>) ? <span class="number">1</span> : <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> *dis,<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">	dis[id]=<span class="number">0</span>; q.<span class="built_in">push</span>(id);</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">		rei x=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>(); vis[x]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(rei i=head[x];i;i=Next[i])&#123;</span><br><span class="line">			rei y=ver[i];</span><br><span class="line">			<span class="keyword">if</span>(dis[x]+<span class="number">1</span>&lt;dis[y])&#123;</span><br><span class="line">				dis[y]=dis[x]+<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(!vis[y]) vis[y]=<span class="number">1</span>,q.<span class="built_in">push</span>(y);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="comment">// if(res[s][t]) return res[s][t];</span></span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">check</span>(res[s][t],<span class="number">0</span>)) <span class="keyword">return</span> res[s][t];</span><br><span class="line">	<span class="keyword">if</span>(s==t) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">	rei fi_st=go[s][t],se_st=go[fi_st][t];</span><br><span class="line">	<span class="keyword">if</span>(fi_st==t || se_st==t) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">	res[s][t]=<span class="number">1.0</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=head[t];i;i=Next[i]) res[s][t]+=<span class="built_in">dfs</span>(se_st,ver[i])/(<span class="number">1</span>+p[t]);</span><br><span class="line">	res[s][t]+=<span class="built_in">dfs</span>(se_st,t)/(<span class="number">1</span>+p[t]);</span><br><span class="line">	<span class="keyword">return</span> res[s][t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,INF,<span class="keyword">sizeof</span> dis),<span class="built_in">memset</span>(go,INF,<span class="keyword">sizeof</span> go);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">spfa</span>(dis[i],i);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">for</span>(rei x=head[i];x;x=Next[x])&#123;</span><br><span class="line">		rei y=ver[x];</span><br><span class="line">		<span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=n;++j) <span class="keyword">if</span>(dis[i][j]<span class="number">-1</span>==dis[y][j]) go[i][j]=<span class="built_in">min</span>(go[i][j],y);<span class="comment">//注意取最小的编号</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// for(rei i=1;i&lt;=n;++i) for(rei j=1;j&lt;=n;++j) printf(&quot;%d%c&quot;,go[i][j],j==n ? 10 : 32);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;S,&amp;T);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>,u,v;i&lt;=m;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v),<span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u),++p[u],++p[v];</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.3lf\n&quot;</span>,<span class="built_in">dfs</span>(S,T));</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P3211-HNOI2011-XOR和路径"><a href="#P3211-HNOI2011-XOR和路径" class="headerlink" title="P3211 [HNOI2011]XOR和路径"></a><a href="https://www.luogu.com.cn/problem/P3211">P3211 [HNOI2011]XOR和路径</a></h3><blockquote>
<p>给无向图，从节点 $1$ 开始等概率走到下一个点，直至到 $n$ ，求路径 $xor和$ 的期望</p>
</blockquote>
<p><del>一开始想偏到边的期望经过次数了</del></p>
<p><strong>对于涉及位运算的题，先考虑是否能拆开一位一位的做</strong></p>
<p>由期望的线性性可知拆开做的正确性</p>
<p>对于每一位 $rk$ : 设 $ans_i$ 表示点 $i$ 到点 $n$ 的步数异或和的期望，那么有：</p>
<script type="math/tex; mode=display">ans_u=\frac{1}{out_u} \left(\sum_{at \ edge_{rk},edge_{u,v}=0}f_v \ + \ \sum_{at\ edge_{rk},edge_{u,v}=1} (1-f_v)  \right)</script><p>由异或性质易得</p>
<p>为了便于高斯消元有：</p>
<script type="math/tex; mode=display">ans_u \times out_u=\left(\sum_{at \ edge_{rk},edge_{u,v}=0}f_v \ + \ \sum_{at\ edge_{rk},edge_{u,v}=1} (1-f_v)  \right)</script><p>复杂度 $O(30\times n^3)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>,M=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS=<span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">double</span> k[N][N];<span class="comment">//edge_&#123;u,v&#125;=0/1 : -1/1 高斯消元系数</span></span><br><span class="line"><span class="keyword">double</span> ans[N];<span class="comment">//i-&gt;n 的步数的第 [当前位] 的异或和的期望</span></span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],Next[M],tot,val[M],out[N];</span><br><span class="line"><span class="keyword">double</span> res;</span><br><span class="line"><span class="keyword">int</span> n,m,MAX_rk;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> z)</span></span>&#123; ver[++tot]=v; Next[tot]=head[u],head[u]=tot; val[tot]=z;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">fabs</span>(x)&lt;EPS ? <span class="number">0</span> : (x&lt;<span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_k</span><span class="params">(<span class="keyword">int</span> rk)</span></span>&#123;<span class="comment">//目前讨论第rk位</span></span><br><span class="line">	<span class="built_in">memset</span>(k,<span class="number">0</span>,<span class="keyword">sizeof</span> k);</span><br><span class="line">	k[n][n]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei x=<span class="number">1</span>;x&lt;=n<span class="number">-1</span>;++x)&#123;</span><br><span class="line">		k[x][x]=out[x];</span><br><span class="line">		<span class="keyword">for</span>(rei i=head[x];i;i=Next[i]) (val[i]&amp;rk) ? ++k[x][ ver[i] ],++k[x][n+<span class="number">1</span>] : --k[x][ ver[i] ];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">gauss</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>,MAX=i;i&lt;=n;++i,MAX=i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(rei j=i;j&lt;=n;++j) <span class="keyword">if</span>(<span class="built_in">check</span>(k[MAX][i]-k[j][i])) MAX=j;</span><br><span class="line">		<span class="keyword">for</span>(rei j=i+<span class="number">1</span>;j&lt;=n;++j) <span class="keyword">if</span>(<span class="built_in">check</span>(k[j][i]))&#123;</span><br><span class="line">			<span class="keyword">double</span> tmp=k[j][i]/k[i][i];</span><br><span class="line">			<span class="keyword">for</span>(rei kk=i;kk&lt;=n+<span class="number">1</span>;++kk) k[j][kk]-=k[i][kk]*tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(rei i=n;i;--i)&#123;<span class="comment">//这样就不需要清空ans了</span></span><br><span class="line">		<span class="keyword">for</span>(rei j=i+<span class="number">1</span>;j&lt;=n;++j) k[i][n+<span class="number">1</span>]-=k[i][j]*ans[j];</span><br><span class="line">		ans[i]=k[i][n+<span class="number">1</span>]/k[i][i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>,u,v,w;i&lt;=m;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w),MAX_rk=<span class="built_in">max</span>(MAX_rk,w),<span class="built_in">add</span>(u,v,w),++out[u],(u==v) ? <span class="number">0</span> : (<span class="built_in">add</span>(v,u,w),++out[v]);<span class="comment">//要求异或和，两次异或不变，存自环无意义</span></span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=MAX_rk;i&lt;&lt;=<span class="number">1</span>) <span class="built_in">get_k</span>(i),<span class="built_in">gauss</span>(),res+=<span class="number">1.0</span>*i*ans[<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.3Lf\n&quot;</span>,res);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title>莫比乌斯反演</title>
    <url>/2021/01/06/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/</url>
    <content><![CDATA[<p>暂停更新，遇见再更</p>
<p>闲下来取写题单</p>
<h2 id="某些前置知识"><a href="#某些前置知识" class="headerlink" title="某些前置知识"></a>某些前置知识</h2><hr>
<h3 id="整除分块"><a href="#整除分块" class="headerlink" title="整除分块"></a>整除分块</h3><ul>
<li><p><strong>qwq</strong></p>
<p><del>众所周知</del></p>
<p>$a\%b=a-b*\left\lfloor \frac{a}{b} \right\rfloor$</p>
</li>
<li><p>规定：</p>
<p>当前块的左端点 $l$，块值 $k$，右端点 $r$</p>
</li>
<li><p>用途：</p>
<p>快速处理形如</p>
<script type="math/tex; mode=display">\sum ^n_{i=1} \left\lfloor\frac{n}{i}\right\rfloor</script><p>的式子</p>
</li>
<li><p>用法：</p>
<p>代入一个 $n$ 可发现某些 $\left\lfloor \frac{n}{i} \right\rfloor$ 的值相同且呈块状分布</p>
<p>对于一个起始下标为 $l$ 的块，其终止下标为 $\left\lfloor \frac{n}{\left\lfloor \frac{n}{l} \right\rfloor} \right\rfloor$</p>
</li>
<li><p>证明：</p>
<p>对于该块中的每个数 $i$，有 $k=\left\lfloor \frac{n}{i} \right\rfloor=\left\lfloor \frac{n}{l} \right\rfloor$</p>
<p>即 $ik \leq n$</p>
<p>所以要找到使 $ik \leq n$ 成立的最大值</p>
<p>所以得到：</p>
<script type="math/tex; mode=display">
\begin{cases}
k=\left\lfloor \frac{n}{l} \right\rfloor \\
r=\max(i) , ik \leq n\\
\end{cases}</script><p>推导得 $r=\left\lfloor \frac{n}{k} \right\rfloor = \left\lfloor \frac{n}{\left\lfloor \frac{n}{l} \right\rfloor} \right\rfloor$</p>
</li>
<li><p>例题</p>
<p><a href="https://www.luogu.com.cn/problem/P2261">P2261 [CQOI2007]余数求和</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ans=n*k;</span><br><span class="line"><span class="keyword">for</span>(ll l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(k/l)</span><br><span class="line">        r=<span class="built_in">min</span>(n,k/(k/l));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        r=n;</span><br><span class="line">    ans-=( (r-l+<span class="number">1</span>)*(l+r)/<span class="number">2</span> <span class="comment">/*等差数列*/</span>) *(k/l)<span class="comment">/*块值*/</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://blog.csdn.net/weixin_43627118/article/details/104024380">拓展</a></p>
<ul>
<li><p>例1</p>
<script type="math/tex; mode=display">求 \sum^n_{i=1} \left\lfloor \frac{n}{ai+b} \right\rfloor</script><ul>
<li>[一]<script type="math/tex; mode=display">
\begin{cases}
k=\left\lfloor \frac{n}{al+b} \right\rfloor \\
r=\max(i) , (ai+b)k \leq n\\
\end{cases}</script></li>
</ul>
</li>
</ul>
</li>
</ul>
<script type="math/tex; mode=display">\because (ai+b)k \leq n</script><script type="math/tex; mode=display">\therefore i \leq \frac{n-bk}{ak}</script><script type="math/tex; mode=display">\therefore r=\max(i)=\left\lfloor \frac{n-bk}{ak} \right\rfloor</script><ul>
<li><p>[二]通法</p>
<script type="math/tex; mode=display">令 r^*=ai+b</script><script type="math/tex; mode=display">\therefore r^*=\left\lfloor \frac{n}{k} \right\rfloor \ , \ k=\left\lfloor \frac{n}{al+b} \right\rfloor</script><script type="math/tex; mode=display">\therefore r^*=\left\lfloor \frac{n}{\left\lfloor \frac{n}{al+b} \right\rfloor} \right\rfloor</script><script type="math/tex; mode=display">
    \begin{cases}
    r^*=ai+b \\
    r=\max(i)\\
    i=\frac{r^*-b}{a}\\
    \end{cases}</script><script type="math/tex; mode=display">\therefore r=\left\lfloor \frac{r^*-b}{a} \right\rfloor</script><script type="math/tex; mode=display">\therefore r=\left\lfloor \frac { \left\lfloor \frac{n}{ \left\lfloor \frac{n}{al+b} \right\rfloor } \right\rfloor -b} {a} \right\rfloor</script></li>
<li><p>例2</p>
<p>$求\sum^n_{i=1} \left\lfloor \frac{n}{i^2} \right\rfloor$</p>
<ul>
<li><p>按通法推导</p>
<p>令$r^*=r^2$</p>
<script type="math/tex; mode=display">
  \begin{cases}
  k=\left\lfloor \frac{n}{l^2} \right\rfloor \\
  r^*=\left\lfloor \frac{n}{k} \right\rfloor \\
  \end{cases}</script><script type="math/tex; mode=display">
  \begin{cases}
  r^*=\left\lfloor \frac{n}{ \left\lfloor \frac{n}{l^2} \right\rfloor } \right\rfloor \\
  i=\sqrt{i^*} \\
  r=\max(i) \\
  \end{cases}</script><script type="math/tex; mode=display">\therefore r=\left\lfloor \sqrt{ \frac{n}{ \left\lfloor \frac{n}{l^2} \right\rfloor } } \right\rfloor</script></li>
</ul>
</li>
<li><p>例3</p>
<ul>
<li><p>求 $\sum^n_{i=1} \left\lceil \frac{n}{i} \right\rceil$</p>
<p><strong>转化</strong>：加上 $\frac{i-1}{i}$ 即可</p>
<p>问题转化为</p>
<script type="math/tex; mode=display">求\sum^n_{i=1} \left\lfloor \frac{n+i-1}{i} \right\rfloor</script><script type="math/tex; mode=display">\because
  \begin{cases}
  k=\left\lfloor \frac{n+l-1 }{l} \right\rfloor \\
  r=\max(i) \ ,\ ik \leq n+i-1 \\
  \end{cases}</script><script type="math/tex; mode=display">\therefore r=\left\lfloor \frac{n-1 }{k-1} \right\rfloor = \left\lfloor \frac{n-1}{ \left\lfloor \frac{ n+l-1 }{l} \right\rfloor -1} \right\rfloor</script></li>
</ul>
</li>
<li><p>例题</p>
<ul>
<li><p><a href="https://www.luogu.com.cn/problem/CF830C">CF830C Bamboo Partition</a></p>
<p>求：$\sum^n_{i=1} d-((a_i-1)\%d+1) \leq k$</p>
<p>解：</p>
<script type="math/tex; mode=display">原式 =\sum^n_{i=1} d-\left(a_i-1 \ -\ d*\left\lfloor \frac{a_i-1}{d} \right\rfloor+1\right)</script><script type="math/tex; mode=display">\therefore nd+d*\sum^n_{i=1}\left\lfloor \frac{a_i-1}{d} \right\rfloor \leq k+\sum^n_{i=1} a_i</script><p>$\therefore$ 右边定值，枚举左边</p>
<script type="math/tex; mode=display">\therefore d\leq k+\sum^n_{i=1} a_i-\left(n+\sum^n_{i=1}\left\lfloor \frac{a_i-1}{d} \right\rfloor\right)</script></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(rei ll l=<span class="number">1</span>,r;l&lt;=MAX;l=r+<span class="number">1</span>)&#123;<span class="comment">//暴力试每一个块</span></span><br><span class="line"><span class="comment">//把l看成是d</span></span><br><span class="line">    r=<span class="number">1e18</span>;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span>(a[i]<span class="number">-1</span>&gt;=l)&#123;<span class="comment">//每一个 ⌊a[i]-1/d⌋ 有值</span></span><br><span class="line">            sum+=(a[i]<span class="number">-1</span>)/l;</span><br><span class="line">            r=<span class="built_in">min</span>(r,(a[i]<span class="number">-1</span>)/((a[i]<span class="number">-1</span>)/l));</span><br><span class="line">        &#125;</span><br><span class="line">    ll tmp=k/(sum+n);<span class="comment">//见blog的式子推导</span></span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tmp) ans=<span class="built_in">max</span>(ans,<span class="built_in">min</span>(tmp,r));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(MAX &lt; k/n) ans=<span class="built_in">max</span>(ans,(ll)k/n);</span><br></pre></td></tr></table></figure>
<ul>
<li><p><a href="https://www.luogu.com.cn/problem/P2260">P2260 [清华集训2012]模积和</a></p>
<script type="math/tex; mode=display">求：\sum_{i=1}^n\sum_{j=1}^m (n\mod i) \cdot (m\mod j) [\ i\not=j \ ]  \mod 19940417</script><p>考虑一个容斥：$原式=(忽略i\not=j 条件时的值)-(i=j时原式的值)$</p>
<ul>
<li><p>忽略 $i\not=j$时：</p>
<script type="math/tex; mode=display">原式=\left(n^2-\sum_{i=1}^n i*\left\lfloor \frac{n}{i} \right\rfloor\right) \cdot \left(m^2-\sum_{j=1}^m j*\left\lfloor \frac{m}{j} \right\rfloor \right) \text{(1)}</script><p>这与[余数求和]相似</p>
</li>
<li><p>$i=j$</p>
<script type="math/tex; mode=display">\begin{aligned}
原式&=\sum_{i=1}^n \left(n-i*\left\lfloor \frac{n}{i} \right\rfloor \right) \cdot \left(m-i*\left\lfloor \frac{m}{i} \right\rfloor \right) \\
&=n^2m \ -\ \left(\sum_{i=1}^n n*i*\left\lfloor \frac{m}{i} \right\rfloor \right) - \left(\sum_{j=1}^n m*i*\left\lfloor \frac{n}{i} \right\rfloor \right)\ + \ \left(\sum_{i=1}^n i^2*\left\lfloor \frac{m}{i} \right\rfloor * \left\lfloor \frac{n}{i} \right\rfloor \right) &\text{(2)}\\
\end{aligned}</script></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数"></a>积性函数</h3><ul>
<li><p>定义</p>
<p>积性函数 $f(x)$ 满足 $f(1)=1$ 且 $\forall x,y\in \mathbb{N}_{+},\gcd(x,y)=1$ 都有 $f(xy)=f(x)f(y)$</p>
</li>
<li><p>常见形式</p>
<ul>
<li><p>单位元 $\epsilon(n)=[n=1]$</p>
</li>
<li><p>恒等函数 $I(n)=1$</p>
</li>
<li><p>单位函数 $id(n)=n$</p>
</li>
</ul>
</li>
<li><p>性质</p>
<script type="math/tex; mode=display">
\begin{aligned}
h(x) &=f(x^p) \\
h(x) &=f^p(x) \\
h(x) &=f(x)g(x) \\
h(x) &=\sum_{d\mid x} f(d)g\left( \frac{x}{d} \right)
\end{aligned}</script></li>
</ul>
<h3 id="迪利克雷卷积"><a href="#迪利克雷卷积" class="headerlink" title="迪利克雷卷积"></a>迪利克雷卷积</h3><ul>
<li><p>注：</p>
<p>$\sum_{d \mid n}$ 表示对 $n$ 的所有正因子求和</p>
</li>
<li><p>定义</p>
<p>定义数论函数的迪利克雷卷积为 $h=f \circ g$ ,其中</p>
<p>注：定义卷积符号为 $\circ$</p>
<details>
    <summary>原因戳我</summary>
    好看
</details>


</li>
</ul>
<script type="math/tex; mode=display">h(n)=\sum_{d \mid n} f(d)g\left( \frac{n}{d} \right)</script><ul>
<li><p>性质</p>
<ul>
<li><p>迪利克雷卷积拥有交换律，分配律，结合律</p>
</li>
<li><p><strong>单位元</strong> (也记作 $\varepsilon$ )</p>
<p>函数 $I(n)=[n=1]$</p>
<p>易知:</p>
<script type="math/tex; mode=display">f \circ I=I \circ f=f</script></li>
<li><p><strong>逆元</strong> (当且仅当 $f(1) \neq 0$)</p>
<p>若 $f \circ g=I$，则称 $g(x)$ 是 $f(x)$ 的逆元</p>
<p>可以构造：</p>
<script type="math/tex; mode=display">\sum_{d\mid n}g(d)f\left( \frac{n}{d} \right)=[n=1]</script><script type="math/tex; mode=display">\therefore g(n)=\frac{1}{f(1)}\left( [n=1]-\sum_{d\mid n,d<n}g(d)f\left( \frac{n}{d} \right)  \right)</script></li>
</ul>
</li>
</ul>
<h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><ul>
<li><p>定义</p>
<p>$\varphi(n) \ =\ n*\prod^n_{i=1} \left( 1-\frac{1}{p_i}\right)$</p>
<p>其中 $p_i$ 是 $n$ 的质因数</p>
<p>即小于等于 $n$ 且与 $n$ 互素的数的个数</p>
</li>
<li><p>性质</p>
<ul>
<li><p>$1.$ 是积性函数</p>
</li>
<li><p>$2.$</p>
<p>对于质数 $p$</p>
<p>$\varphi(p)=p-1$</p>
</li>
<li><p>$3.$</p>
<p>若 $n=p^k$ ,其中 $p$ 是质数</p>
<p>$\varphi(n)\ =\ p^k-p^{k-1}\ =\ (p-1)p^{k-1}$</p>
<p>证：$1$ 到 $n$ 中除了 $p$ 的倍数，都与 $p^k$ 互质，且 $1$ 到 $n$ 中 $p$ 的倍数的个数为 $\displaystyle{\frac{p^k}{p}}=p^{k-1}$</p>
</li>
<li><p>$4.$</p>
<p>所有<strong>小于等于</strong> $n$ 且与 $n$ 互质的数的个数和 $sum=n*\displaystyle{\frac{\varphi(n)}{2}}$</p>
<p>证：用反证法可知：</p>
<p>若 $\gcd(n,i)=1$，则 $\gcd(n,n-i)=1$ $\Rightarrow$ 更相减损术</p>
<p>所以每个与 $n$ 互质的数都是成对的</p>
<p>$i$ 与 $n-i$ 成对</p>
</li>
<li><p>$5.$</p>
<p>若 $i\mid p$，其中 $p$ 是质数</p>
<p>则 $\varphi(i\cdot p)=p\cdot \varphi(i)$</p>
<p>否则 $\varphi(i*p)=(p-1)\varphi(i)$</p>
<p>即</p>
<script type="math/tex; mode=display">\varphi(np)=\begin{cases}
(p-1)*\varphi(n) & n\perp p \\
p*\varphi(n) & n\not\perp p \\
\end{cases}</script><p>证明咕咕咕</p>
</li>
<li><p>$6.欧拉反演$</p>
<p>$\displaystyle{\sum_{d\mid n}\varphi(d)=n}$</p>
<ul>
<li><p>证：</p>
<script type="math/tex; mode=display">\because n=\prod_{i=1}^{m}p_i^{a_i}</script><script type="math/tex; mode=display">又\because \varphi(n) 是积性函数</script><script type="math/tex; mode=display">\therefore \sum_{d|n}=\sum_{d|n}\prod_{i=1}^{m}\varphi(p_i^{j})\times[p_i^j\ |\ d]</script><script type="math/tex; mode=display">
\begin{aligned} 对上式因式分解可得 \\
右边&=\prod_{i=1}^{m}\left(\sum_{j=0}^{a_i}\varphi\left(p_i^j\right)\right)\\
&=\prod_{i=1}^{m}\left(\sum_{j=1}^{a_i}\left(p_i^j-p_i^{j-1}\right)+1\right)\\
&=\prod_{i=1}^{m}p_i^{a_i}\\
&=n \end{aligned}</script></li>
<li><p>扩展：</p>
<script type="math/tex; mode=display">\gcd(i,j)=\sum_{d\mid i,d\mid j} \varphi(d)</script></li>
</ul>
</li>
<li><p>$7. \varphi 与 \mu$</p>
<p>$\displaystyle{\frac{\varphi(n)}{n}=\sum_{d\mid n}\frac{\mu(d)}{d}}$</p>
<ul>
<li><p>证：</p>
<script type="math/tex; mode=display">\because \sum_{d\mid n}\varphi(d)=n</script><script type="math/tex; mode=display">\therefore \sum_{d\mid n}\varphi(d) \cdot 1=n</script><script type="math/tex; mode=display">\therefore \varphi \circ I=id \qquad \text{变成卷积形式}</script><script type="math/tex; mode=display">\therefore \varphi \circ I \circ \mu = id \circ \mu \qquad \text{迪利克雷卷积性质}</script><script type="math/tex; mode=display">\therefore \varphi \circ \epsilon =id\circ \mu</script><script type="math/tex; mode=display">
\begin{aligned}
\therefore \varphi
&=id \circ \mu \\
&=\sum_{d\mid n} \mu(d) \cdot \frac{n}{d} \\
\end{aligned}</script><p>同除 $n$得：</p>
<script type="math/tex; mode=display">\displaystyle{\frac{\varphi(n)}{n}=\sum_{d\mid n}\frac{\mu(d)}{d}}</script></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="写在前面的总结"><a href="#写在前面的总结" class="headerlink" title="写在前面的总结"></a>写在前面的总结</h2><p><strong>遇到艾弗森方程，转化为$\sum_{d\mid n} \mu(d)$</strong></p>
<p><strong>遇到具体的值，考虑欧拉函数 ————by CTime_Pup_314</strong></p>
<ul>
<li><p>当遇到迪利克雷卷积形式的式子($\sum_{d\mid n}···$)时</p>
<p>看标准分解式 $p_1^{a_1}p_2^{a_2}…p_n^{a_n}$</p>
<p>并分析其中一个 $p_i^{a_i}$</p>
</li>
<li><p>再尝试转化出 $F(n)=\sum_{d\mid n}\mu(\frac{n}{d}) f(d)$ 的形式</p>
<p>再考虑加入 $p$ 的影响:</p>
<p>分为 $n \perp p$ 和 $n\not\perp p$两种讨论</p>
<ul>
<li><p>$n \perp p$ 时，$\sum_{d\mid n}\mu\left(\frac{np}{d}\right) f(d) + \sum_{d\mid n}\mu\left(\frac{np}{dp}\right)f(dp)\ =\ -F(n)+\mu(n)$</p>
</li>
<li><p>$n \not\perp p$ 时，$\sum_{d\mid n}\mu\left(\frac{np}{d}\right) f(d) + \sum_{d\mid n}\mu\left(\frac{np}{dp}\right) f(dp)\ =\ \mu(n)$</p>
</li>
</ul>
</li>
<li><p>若问题类似与 $\displaystyle{\sum_{i=1}^n\sum_{j=1}^mf\left(gcd(i,\ j)\right )}$</p>
<p>则转化为 $\displaystyle{\sum_{T=1}^n\left\lfloor \frac{n}{T} \right\rfloor \left\lfloor \frac{m}{T} \right\rfloor \sum_{d\mid T}\mu\left(\frac{T}{d}\right)f(d)}$</p>
</li>
</ul>
<h2 id="莫比乌斯函数"><a href="#莫比乌斯函数" class="headerlink" title="莫比乌斯函数"></a>莫比乌斯函数</h2><ul>
<li><p>定义</p>
<p>设 $n=\prod_{i=1}^k p_i^{c_i}$，其中 $p_i$ 为质因子, $c_i$ 为个数</p>
<script type="math/tex; mode=display">
\mu(n)=
\begin{cases}
1 &n=1 \\
0 &\exist i\in [1,k],\ \text{使} \ c_i>1 \\
(-1)^k &\forall i \in [1,k] \ \ \   c_i=1 \\
\end{cases}</script></li>
<li><p>性质</p>
<script type="math/tex; mode=display">\sum_{d \mid n} \mu(d)=
\begin{cases}
1 &n=1 \\
0 &n\neq 1
\end{cases}
\ \ =[n==1]</script><ul>
<li><p>证明</p>
<p>显然不用考虑使 $\mu(d)=0$ 的那些 $d$</p>
<p>设 $n$ 有 $k$ 个互异质因数</p>
<p>$\therefore$ 由 $r$ 个质因数乘起来的因数 $d$ 有   $C_k^r$ 个</p>
<script type="math/tex; mode=display">\therefore \sum_{d \mid n} \mu(d)=\sum_{i=0}^k (-1)^i \cdot C^i_k</script><p>由二项式定理：</p>
<script type="math/tex; mode=display">(x+y)^k=\sum_{i=0}^k\cdot C_k^i \cdot x^i y^{k-i}</script><p>可知</p>
<p>取 $x=-1,y=1$</p>
<script type="math/tex; mode=display">\therefore 原式=(1+(-1))^k=0^k=0</script><p>同时，这也证明了$\sum_{d \mid n} \mu(d)=[n=1]= \varepsilon(n)$</p>
<p>以及 $\mu \circ 1=\varepsilon$</p>
</li>
<li><p>性质2</p>
<script type="math/tex; mode=display">[\gcd(i,j)=1]=\sum_{d\mid \gcd(i,j)} \mu(d)</script><p><del>和上面的一模一样。。。</del></p>
</li>
</ul>
</li>
<li><p>线性筛求法</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> p[N];<span class="comment">//第tot个质因数值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!flg[i])<span class="comment">/*之前没有用过该质因数*/</span> p[++tot]=i,mu[i]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=tot &amp;&amp; i*p[j]&lt;=n ;++j)&#123;</span><br><span class="line">            flg[ i*p[j] ]=<span class="number">1</span>;<span class="comment">//每个质因数的倍数打上标记</span></span><br><span class="line">            <span class="keyword">if</span>(!(i%p[j]))&#123;<span class="comment">//有平方因子</span></span><br><span class="line">                mu[ i*p[j] ]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mu[ i*p[j] ]=-mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h2><ul>
<li><p>公式</p>
<script type="math/tex; mode=display">若 \operatorname{F}(n)=\sum_{d\mid n} f(d)，那么 f(n)=\sum_{d\mid n} \mu(d)\operatorname{F}\left(\frac{n}{d}\right)</script><script type="math/tex; mode=display">若 \operatorname{F}(n)=\sum_{n\mid d} f(d)，那么 f(n)=\sum_{n\mid d} \mu\left(\frac{d}{n}\right)\operatorname{F}(d)</script></li>
<li><p>略证</p>
<script type="math/tex; mode=display">\sum_{d\mid n}\mu(d)=[n=1] \Rightarrow \mu \circ 1= \varepsilon</script><script type="math/tex; mode=display">\operatorname{F}(n)=\sum_{d\mid n}f(d) \Rightarrow \operatorname{F}=f \circ 1</script><script type="math/tex; mode=display">\therefore \operatorname{F} \circ \mu = f \circ 1 \circ \mu</script><script type="math/tex; mode=display">\therefore \operatorname{F} \circ \mu=f \circ \varepsilon</script><script type="math/tex; mode=display">\therefore f=\operatorname{F} \circ \mu</script><script type="math/tex; mode=display">\therefore f(n)=\sum_{d\mid n}\mu(d) \cdot \operatorname{F}\left(\frac{n}{d}\right)</script></li>
</ul>
<p><del>好吧我不怎么会证</del></p>
<p>用莫比乌斯函数就可以解决大部分莫反问题——by CTime_Pup_314</p>
<h3 id="需要带脑子推式子的例题"><a href="#需要带脑子推式子的例题" class="headerlink" title="需要带脑子推式子的例题"></a>需要带脑子推式子的例题</h3><ul>
<li><p><del>k倍经验</del></p>
<p><del>UVA11417 GCD垃圾红题</del>，UVA11424 GCD - Extreme (I)，P1390 公约数的和，P2398 GCD SUM，P2568 GCD，SP3871 GCDEX - GCD Extreme，UVA11426 拿行李（极限版），SP3871 GCDEX - GCD Extreme,[SP19985]GCDEX2 - GCD Extreme (hard)（要用杜教筛）， [SDOI2008] 仪仗队</p>
</li>
</ul>
<p><strong>请仔细留意如何筛出所需函数</strong></p>
<ul>
<li><p>附线性筛板子  <del>不压行显得多一点</del> 改码风了，不压行好烦</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//f是你想要的函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>]=<span class="number">1</span>,varphi[<span class="number">1</span>]=<span class="number">1</span>,f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei d=<span class="number">2</span>;d&lt;N;++d)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag[d])&#123;</span><br><span class="line">            prime[++tot]=d,varphi[d]=d<span class="number">-1</span>,mu[i]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f[d]=它该等于的式子</span><br><span class="line">        <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=tot &amp;&amp; d*prime[j]&lt;N;++j)&#123;</span><br><span class="line">            rei tmp=d*prime[j]; flag[tmp]=<span class="number">1</span>;</span><br><span class="line">            varphi[tmp]=varphi[d] * (d%prime[j]<span class="comment">/*是否互素*/</span> ? prime[j]<span class="number">-1</span> : prime[j]);</span><br><span class="line">           	(!(d%p[j])) ? mu[d*p[j]]=<span class="number">0</span> : mu[d*p[j]]=-mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">        这里可能需要进一步处理<span class="built_in">f</span>(n)</span><br><span class="line">    &#125;</span><br><span class="line">    这里也有可能</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注：规定所有的 $n&lt;m$ , 所有出现的 $p$ 为质数</p>
<ul>
<li><p>$1$</p>
<p><a href="https://www.luogu.com.cn/problem/P4450">P4450 双亲数</a></p>
<script type="math/tex; mode=display">求 \sum^n_{i=1}\sum^m_{j=1} [\ \gcd(i,j)=1\ ]</script><p>解：</p>
<script type="math/tex; mode=display">\begin{aligned}
原式
&= \sum^n_{i=1}\sum^m_{j=1}\sum_{d\mid \gcd(i,j)} \mu(d) &\text{莫比乌斯函数的性质2}\\
&= \sum^n_{i=1}\sum^m_{j=1}\sum_{d\mid i \ , \ d\mid j} \mu(d) &\text{拆开}\\
&= \sum^n_{i=1}\sum^m_{j=1}\sum^n_{d=1} \mu(d) [ \ d \mid i \ ] [ \ d \mid j \ ] &\text{条件转移到右边} \\
&= \sum^n_{d=1} \mu(d) \sum^n_{i=1} [d\mid i] \sum^m_{j=1} [d\mid j] &\text{调整顺序} \\
&= \sum^n_{d=1} \mu(d) \left\lfloor \frac{n}{d} \right\rfloor \left\lfloor \frac{m}{d} \right\rfloor &\text{...} \\
\end{aligned}</script></li>
<li><p>$2$</p>
<p><a href="https://www.luogu.com.cn/problem/P2522">P2522 [HAOI2011]Problem b</a></p>
<script type="math/tex; mode=display">求 \sum^n_{i=1}\sum^m_{j=1} [\gcd(i,j)=k]</script><p>解：</p>
<p>将范围缩小 $k$ 就可以</p>
<p>即</p>
<script type="math/tex; mode=display">\begin{aligned}
原式
&=\sum^{ \left\lfloor \frac{n}{k} \right\rfloor }_{i=1} \sum^{ \left\lfloor \frac{m}{k} \right\rfloor  }_{j=1} [\gcd(i,j)=1] \\
&=\sum^{ \left\lfloor \frac{n}{k} \right\rfloor }_{d=1} \mu(d) \left\lfloor \frac{n}{kd} \right\rfloor \left\lfloor \frac{m}{kd} \right\rfloor
\end{aligned}</script></li>
<li><p>$3$</p>
<script type="math/tex; mode=display">求\sum^n_{i=1}\sum^m_{j=1} i*j*[\ \gcd(i,j)=k\ ]</script><script type="math/tex; mode=display">\begin{aligned}
原式
&=k^2*\sum^{\left\lfloor \frac{n}{k} \right\rfloor}_{i=1} \sum^{\left\lfloor \frac{m}{k} \right\rfloor}_{j=1} i*j*[ \ \gcd(i,j)=1 \ ] &\text{ $i$ 缩小成 $\frac{i}{k}$，$j$ 同理} \\
&=k^2* \sum^{\left\lfloor \frac{n}{k} \right\rfloor}_{d=1}\mu(d) \sum^{\left\lfloor \frac{n}{k} \right\rfloor}_{i=1} \sum^{\left\lfloor \frac{m}{k} \right\rfloor}_{j=1} i*j*[d\mid i][d\mid j] \\
&=k^2 \sum^{\left\lfloor \frac{n}{k} \right\rfloor}_{d=1}\mu(d) * d^2 \sum^{\left\lfloor \frac{n}{kd} \right\rfloor}_{i=1}i\sum^{\left\lfloor \frac{m}{kd} \right\rfloor}_{j=1}j &\text{ $i$ 缩小为 $\frac{i}{d}$ ，$j$ 同理} \\
&\text{变成等差数列了qwq}
\end{aligned}</script></li>
<li><p>$4$</p>
<script type="math/tex; mode=display">求\sum_{i=1}^n\sum_{j=1}^m \gcd(i,\ j)</script><p><a href="https://www.luogu.com.cn/problem/P1447">P1447 [NOI2010] 能量采集</a></p>
<p>由题，没有被遮挡的植物坐标 $(x,y)$ 满足 $n\perp m$，而一条线 $(0,0)-(x,y)$ 上被挡住的植物有 $\gcd(x,y)-1$ 个</p>
<script type="math/tex; mode=display">\therefore 求\sum^n_{i=1}\sum^m_{j=1}((2*\gcd(i,j)-1) \ +1 \ )</script><script type="math/tex; mode=display">\therefore 求2*\sum^n_{i=1}\sum^m_{j=1}(\gcd(i,j)) \ - \ nm</script><script type="math/tex; mode=display">\therefore 求\sum_{i=1}^n\sum_{j=1}^m \gcd(i,\ j)</script><p>先进行简单化简</p>
<script type="math/tex; mode=display">\sum_{d=1}^nd\sum_{i=1}^n\sum_{j=1}^m[ \ \gcd(i,j)=d \ ]</script><script type="math/tex; mode=display">\sum_{d=1}^nd\sum_{k=1}^{\lfloor \frac{n}{d} \rfloor}\mu(k) \left\lfloor \frac{n}{kd} \right\rfloor \left\lfloor \frac{m}{kd} \right\rfloor</script><p>设 $T=kd$</p>
<script type="math/tex; mode=display">
\begin{aligned}
\therefore
原式
&= \sum_{d=1}^nd\sum_{T=1}^n\mu\left(\frac{T}{d}\right) \left\lfloor \frac{n}{T} \right\rfloor \left\lfloor \frac{m}{T} \right\rfloor [d\mid T]\ \\
&= \sum_{T=1}^n \left\lfloor \frac{n}{T} \right\rfloor \left\lfloor \frac{m}{T} \right\rfloor \sum_{d\mid T}\mu \left( \frac{T}{d} \right)d \\
\end{aligned}</script><p>设 $\operatorname{F}(n)=\sum_{d\mid n}\mu \left( \frac{n}{d} \right)d$</p>
<p>根据上面的总结可知</p>
<script type="math/tex; mode=display">\operatorname{F}(np)=\sum_{d\mid n} \mu\left(\frac{np}{d} \right)d \ + \ \sum_{d\mid n}\mu\left(\frac{np}{dp} \right) dp</script><p>当 $n\perp p$ 时，</p>
<script type="math/tex; mode=display">\operatorname{F}(np)=-\operatorname{F}(n)+p\operatorname{}{F}(n)</script><p>当 $n\not\perp p$ 时，</p>
<script type="math/tex; mode=display">\operatorname{F}(np)=p\operatorname{}{F}(n)</script><p>$\therefore 显然F(n)符合欧拉函数的性质$</p>
<ul>
<li><p>变式</p>
<p><a href="https://www.luogu.com.cn/problem/P4449">P4449 于神之怒加强版</a></p>
<script type="math/tex; mode=display">求\sum_{i=1}^n\sum_{j=1}^m \gcd(i,\ j)^k \mod p</script><p>先把 $k$ 提出来得</p>
<script type="math/tex; mode=display">\begin{aligned}
原式
&=\sum_{d=1}^n d^k \sum_{i=1}^{\left\lfloor \frac{n}{d} \right\rfloor}\sum_{i=1}^{\left\lfloor \frac{m}{d} \right\rfloor} [ \ \gcd(i,j)=1 \ ] \\
&=\sum_{d=1}^n d^k \sum_{x=1}^{\left\lfloor \frac{n}{d} \right\rfloor} \left\lfloor \frac{n}{dx} \right\rfloor\left\lfloor \frac{m}{dx} \right\rfloor \mu(x) \\
&设\  T=dx \\
&=\sum_{T=1}^n \sum_{d\mid T}d^k \left\lfloor \frac{n}{T} \right\rfloor \left\lfloor \frac{m}{T} \right\rfloor \mu\left(\frac{T}{d} \right) &\text{总是忘记可以这么化} \\
&=\sum_{T=1}^n \left\lfloor \frac{n}{T} \right\rfloor \left\lfloor \frac{m}{T} \right\rfloor \sum_{d\mid T}\mu \left( \frac{T}{d} \right)d^k &\text{剩余做法参照上面} \\
\end{aligned}</script><p>处理 $\sum_{d\mid T}\mu \left( \frac{T}{d} \right)d^k$</p>
<p>设积性函数 $f(T)=id^k \circ \mu$</p>
<script type="math/tex; mode=display">\because 积性函数满足 f(nm)=f(n)f(m) , T=\prod_{i=1}^k p_i^{c_i}</script><script type="math/tex; mode=display">\therefore 研究 T\mid P^x , x\in \text{N+} , p\in \text{primes}</script><p>当 $x=1$</p>
<script type="math/tex; mode=display">d^k \mu\left(\frac{T}{d} \right)=\begin{cases}
    -1 &(d=1) \\
    T^k &(d==T) \\
\end{cases}</script><script type="math/tex; mode=display">\therefore f(T)=T^k-1</script><p>当 $x&gt;1$</p>
<script type="math/tex; mode=display">d^k\mu\left(\frac{T^x}{d} \right)=\begin{cases}
    -\left(T^{x-1} \right)^k &\left(d=T^{x-1}\right) \\
    \left(T^x \right)^k &\left(T^x\right) \\
\end{cases}</script><p>$\therefore$ 筛法为</p>
<script type="math/tex; mode=display">f_{i*p_j}=\begin{cases}
    f_i * f_{p_j} &\left( \ \gcd(p_j,i)=1 \ \right) \\
    f_i * p_j^k &( \ p_j\mid i \ ) \\
\end{cases}</script></li>
<li><p>变式</p>
<p><a href="https://www.luogu.com.cn/problem/UVA11424">UVA11424 GCD - Extreme (I)</a></p>
<script type="math/tex; mode=display">求\sum_{i=1}^n\sum_{j=i+1}^n \gcd(i,j)</script><p>有一个比莫反更好的方法</p>
<p>设 $f(n)=\gcd(1,n)+\gcd(2,n)+…+\gcd(n-1,n)$</p>
<p>$\therefore ans=f(2)+f(3)+…+f(n)$</p>
<p>设 $g(n,x)$ 表示 $\gcd(x,n)=i$ 的小于 $n$ 的正整数个数</p>
<script type="math/tex; mode=display">\therefore f(n)=\sum_{i\mid n}i*g(n,i)</script><p>考虑 $\varphi$ 即可</p>
<p><del>精神不稳就这吧</del></p>
<p>我的精神是正常的只是懒得写</p>
</li>
</ul>
</li>
<li><p>$5$</p>
<p><a href="https://www.luogu.com.cn/problem/P2257">P2257 YY的GCD</a></p>
<script type="math/tex; mode=display">求\sum_{i=1}^n\sum_{j=1}^m[\ \gcd(i,j)=p \ ]\ ，\ 其中 \ p\ 是质数</script><script type="math/tex; mode=display">设\operatorname{F}(n)=[\ n=p\ ]</script><script type="math/tex; mode=display">原式=\sum_{i=1}^n\sum_{j=1}^mf(\gcd(i,j))</script><script type="math/tex; mode=display">设T=kd</script><p>推导与上一题类似，略(<del>懒</del>)</p>
<script type="math/tex; mode=display">\therefore \sum_{T=1}^n \left\lfloor \frac{n}{T} \right\rfloor \left\lfloor \frac{m}{T} \right\rfloor \sum_{d\mid T}\mu \left( \frac{T}{d} \right) f(d)</script></li>
<li><p>$6$</p>
<p><a href="https://www.luogu.com.cn/problem/SP5971">SP5971 LCMSUM - LCM Sum</a></p>
<script type="math/tex; mode=display">求\sum^n_{i=1}\text{lcm}(i,n)</script><ul>
<li><p>[ 法一 ]</p>
<script type="math/tex; mode=display">\begin{aligned}
  原式
  &=\sum^n_{i=1} \frac{i \cdot n}{\gcd(i,n)} \\
  &=\frac{1}{2} \cdot \left(\sum^{n-1}_{i=1} \frac{i\cdot n}{\gcd(i,n)}\ + \ \sum^1_{i=n-1} \frac{i\cdot n}{\gcd(n-i,n)} \right)+n &\text{复制原式并颠倒，并提出第 $n$ 项}\\
  &=\frac{1}{2}\cdot \sum^{n-1}_{i=1} \frac{n^2}{\gcd(i,n)} \ + \ n &\text{ $\gcd(i,n)$ 转化为 $\gcd(n-i,n)$ ,并合并分母}\\
  &=\frac{1}{2}\cdot \sum^{n}_{i=1} \frac{n^2}{\gcd(i,n)} \ + \ \frac{n}{2} \\
  \end{aligned}</script><p>  $\gcd(i,n)$ 值相同的放在一起 $\Rightarrow$ 统计 $\gcd(i,n)=d$ 的个数</p>
<p>  当 $\gcd(i,n)=d$ , $\gcd(\frac{i}{d},\frac{i}{n})=1$</p>
<p>  所以 $\gcd(i,n)=d$ 的个数有 $\varphi\left(\frac{n}{d}\right)$</p>
<script type="math/tex; mode=display">\therefore 原式=\frac{1}{2} \sum_{d\mid n}\frac{ n^2\cdot\varphi(\frac{n}{d}) }{d} \ + \ \frac{n}{2}</script></li>
<li><p>[ 法二 ]</p>
<script type="math/tex; mode=display">\begin{aligned}
  原式
  &=\sum_{i=1}^n \frac{i\cdot n}{\gcd(i,n)} \\
  &=\sum_{d\mid n}\sum_{i=1}^n \ [\ \gcd(i,n)=d \ ] \ \frac{i\cdot n}{d} &\text{枚举 $\gcd(i,n)=d$ }\\
  &=n \cdot \sum_{d\mid n}\sum_{i=1}^{\left\lfloor \frac{n}{d} \right\rfloor} [ \ \gcd(i,\frac{n}{d})=1 \ ] \cdot i \\
  \end{aligned}</script><p>  提出式子 $\displaystyle{\sum_{i=1}^n [\ \gcd(i,n)=1\ ]\cdot i}$</p>
<p>  式子的含义是求小于等于 $n$ 的数中与 $n$ 互质的数的和</p>
<p>  这与上文推导的欧拉函数性质 $4$ 一样</p>
<p>  即 $sum=n*\displaystyle{\frac{\varphi(n)}{2}}$</p>
<script type="math/tex; mode=display">\therefore 原式=n\cdot \sum_{d\mid n} d*\frac{\varphi(d)}{2}</script></li>
</ul>
</li>
<li><p>$7.$</p>
<p><a href="https://www.luogu.com.cn/problem/P3327">P3327 [SDOI2015]约数个数和</a></p>
<p>设 $\operatorname{d}(i)$ 为 $i$ 的约数个数 ，注意仍有 $n&lt;m$</p>
<script type="math/tex; mode=display">求：\sum_{i=1}^n\sum_{j=1}^m \operatorname{d}(ij)</script><p><strong>有一个显然的结论</strong>:$\displaystyle{\operatorname{d}(n)=\sum_{x\mid n,y\mid n}[ \ \gcd(x,y)=1 \ ]}$</p>
<script type="math/tex; mode=display">\begin{aligned}
原式
&=\sum_{i=1}^n \sum_{j=1}^m \sum_{x\mid i} \sum_{y\mid j} \sum_{d\mid \gcd(x,y)} \mu(d) &\text{(1)}\\
&=\sum_{d=1}^n\mu(d) \sum_{i=1}^n \sum_{j=1}^m \left\lfloor \frac{i}{d}  \right\rfloor \cdot \left\lfloor \frac{j}{d}  \right\rfloor &\text{莫反套路，前置 $\mu$ 函数，在 $i$ 内能被 $d$ 整除的有 $\frac{i}{d}$ 个}\\
\end{aligned}</script><p>然而 $d$ 在分母上，不易打表，无法数论分块 $\Rightarrow$ 重新考虑 $(1)$ 式</p>
<p>$(1)$ 中对每组 $(d,i,j)$ ，先考虑 $\displaystyle{\sum_{i=1}^n \sum_{j=1}^m \sum_{x\mid i} \sum_{y\mid j}}$ $(2)$</p>
<p>其贡献为 $\left(i的因数(x)的个数 \left(即\sum_{x\mid i} \right) \right) \cdot \left(j的因数的个数 \left(即\sum_{y\mid j} \right) \right)$</p>
<p>再提前 $\displaystyle{\sum_{d\mid \gcd(x,y)}\mu(d)}$ ，转化为从 $1$ 到 $n$ 枚举 $d$ ，同时缩小 $(2)$ 式的数据范围</p>
<p>若使 $[\ d\mid \gcd(x,y) \ ]=1$ ，那么 $x,y$ 都为 $d$ 的倍数 ，所以数据范围应为枚举 $d,2d,3d,4d…$ 直至 $kd&gt;n$</p>
<script type="math/tex; mode=display">原式=\sum_{d=1}^n\mu(d) \cdot \sum_{s=1}^{\left\lfloor \frac{n}{d} \right\rfloor} \left\lfloor \frac{n}{sd} \right\rfloor \cdot \sum_{t=1}^{\left\lfloor \frac{m}{d} \right\rfloor} \left\lfloor \frac{m}{td} \right\rfloor</script><p>式子含义明显</p>
<p>设 $\displaystyle{\operatorname{f}(i)=\sum_{i=1}^n \left\lfloor \frac{n}{i} \right\rfloor}$ ，考虑对 $\operatorname{f}(i)$ 分块</p>
<p>显然有 $\displaystyle{\operatorname{f}(i)=\sum_{i=1}^n} \operatorname{d}(x)$</p>
<script type="math/tex; mode=display">原式=\sum_{d=1}^n\mu(d) \cdot \operatorname{f} \left(\left\lfloor \frac{n}{d} \right\rfloor \right) \cdot \operatorname{f} \left(\left\lfloor \frac{m}{d} \right\rfloor \right)</script></li>
<li><p>$8$</p>
<p><a href="https://www.luogu.com.cn/problem/P1829">P1829 【[国家集训队]Crash的数字表格 / JZPTAB】</a></p>
<script type="math/tex; mode=display">求 \sum_{i=1}^n\sum_{j=1}^m \text{lcm}(i,j)</script><script type="math/tex; mode=display">\begin{aligned}
原式
&=\sum_{d=1}^n \frac{1}{d} * \sum_{i=1}^n\sum_{j=1}^mi*j*[ \ \gcd(i,j)=d \ ] &\text{用前面的$\frac{1}{d}$抵消了原有的 $\frac{1}{\gcd}$}\\
&=\sum_{d=1}^n d\sum_{i=1}^{\left\lfloor \frac{n}{d}  \right\rfloor}\sum_{j=1}^{\left\lfloor \frac{m}{d}  \right\rfloor}i*j*[ \ \gcd(i,j)=1 \ ] &\text{缩小数据范围，恰好可以用前面的 $\sum d$ 抵消造成的影响} \\
&=\sum_{d=1}^n d \sum_{k=1}^{\left\lfloor \frac{n}{d}  \right\rfloor} \mu(k) * k^2 * \sum_{i=1}^{\left\lfloor \frac{n}{dk}  \right\rfloor} \sum_{j=1}^{\left\lfloor \frac{m}{dk}  \right\rfloor} i j &\text{后面的两个 $\sum$ 的数据范围均被缩小了 $k$ ，所以前面乘上 $k^2$ } \\
\end{aligned}</script><p>设 $S(n)=\sum_{i=1}^n=\frac{n(n+1)}{2}$</p>
<script type="math/tex; mode=display">\therefore 原式=\sum_{d=1}^n d \sum_{k=1}^{\left\lfloor \frac{n}{d}  \right\rfloor} \mu(k) * k^2 *S\left(\frac{n}{kd} \right) * S\left(\frac{m}{kd} \right)</script><p>再设 $T=kd$</p>
<script type="math/tex; mode=display">\begin{aligned}
\therefore 原式
&=\sum_{T=1}^n * S\left(\frac{n}{T} \right)S\left(\frac{m}{T} \right) * \sum_{d\mid T}\mu\left(\frac{T}{d} \right) * \left(\frac{T}{d}\right)^2 \\
&=\sum_{T=1}^n * S\left(\frac{n}{T} \right)S\left(\frac{m}{T} \right) * \sum_{d\mid T}Td\mu(d) &\text{如果看到提醒我去问人} \\
\end{aligned}</script><p>$\therefore$ 只需预处理 $\sum_{d\mid T}Td\mu(d)$ 即可</p>
<p><a href="https://www.luogu.com.cn/blog/qwaszx/solution-p1829">传送门</a></p>
</li>
<li><p>$9.$</p>
<p><a href="https://www.luogu.com.cn/problem/P3911">P3911 最小公倍数之和</a></p>
<script type="math/tex; mode=display">求\displaystyle{\sum_{i=1}^n \sum_{j=1}^n \text{lcm} \left(A_i,A_j \right)}</script><p>考虑转化该式：</p>
<p>设 $\displaystyle{M=\max_{1&lt;=i&lt;=n}A_i \quad,\quad C_i=\sum_{d=1}^n [A_d=i] }$</p>
<script type="math/tex; mode=display">\therefore 原式=\sum_{i=1}^M\sum_{j=1}^M \text{lcm}(i,j) * C_i * C_j \quad \text{枚举所有 $A_i$ 的值，$C_i$表达是否存在该值以及该值的数量 $\Rightarrow$ 避免重复运算 }</script><p>其余按套路来</p>
<script type="math/tex; mode=display">\begin{aligned}
原式
&=\sum_{d=1}^M\sum_{i=1}^{\left\lfloor \frac{M}{d} \right\rfloor}\sum_{j=1}^{\left\lfloor \frac{M}{d} \right\rfloor} [\gcd(i,j)=1]*d * ij *C_{id}C_{jd} \\
&=\sum_{d=1}^M d \sum_{k=1}^{\left\lfloor \frac{M}{d} \right\rfloor} k^2\mu(k) \sum_{i=1}^{\left\lfloor \frac{M}{kd} \right\rfloor}\sum_{j=1}^{\left\lfloor \frac{M}{kd} \right\rfloor} ij * C_{idk}C_{jdk} &\text{过程略}\\
\end{aligned}</script><p>考虑后面部分的 $C$ 如何快速处理</p>
<p>设 $T=dk$</p>
<script type="math/tex; mode=display">\begin{aligned}
原式
&=\sum_{T=1}^n T \cdot \sum_{k\mid T} k\mu(k) \cdot \sum_{i=1}^{\left\lfloor \frac{n}{T} \right\rfloor}\sum_{j=1}^{\left\lfloor \frac{n}{T} \right\rfloor} A_{i\cdot T}A_{j\cdot T} \cdot ij \\
&设s_i=i*\sum_{k\mid i}k\cdot \mu(k) \\
&=\sum_{T=1}^ns_T \cdot \sum_{i=1}^{\left\lfloor \frac{n}{T} \right\rfloor}\sum_{j=1}^{\left\lfloor \frac{n}{T} \right\rfloor}A_{iT}A_{jT}\cdot ij \\
&=\sum_{T=1}^n s_T \cdot \left(\sum_{i=1}^{\left\lfloor \frac{n}{T} \right\rfloor} i\cdot A_{iT}\right) \left(\sum_{j=1}^{\left\lfloor \frac{n}{T} \right\rfloor} A_{jT} \cdot j\right) \\
&=\sum_{T=1}^n s_T \cdot \left(\sum_{i=1}^{\left\lfloor \frac{n}{T} \right\rfloor} i\cdot A_{iT}\right)^2 &\text{后面两项一样}\\
\end{aligned}</script><p>简单的变式<a href="https://www.luogu.com.cn/problem/AT5200">AT5200 [AGC038C] LCMs</a></p>
<p>求 $\displaystyle{\sum_{i=0}^{n}\sum_{j=i+1}^{n}\text{lcm}(A_i,A_j)} \quad \mod p$</p>
<script type="math/tex; mode=display">原式=\frac{\sum_{i=1}^n \sum_{j=1}^n \text{lcm}(A_i,A_j)-\sum_{i=1}^n A_i}{2}</script><p>注意及时取模即可</p>
</li>
<li><p>$10.$</p>
<p><a href="https://www.luogu.com.cn/problem/P3768">P3768 简单的数学题</a></p>
<script type="math/tex; mode=display">求\displaystyle{\left(\sum_{i=1}^n\sum_{j=1}^n ij\gcd(i,j) \right) \pmod p}</script><script type="math/tex; mode=display">\begin{aligned}
原式
&=\sum_{i=1}^n\sum_{j=1}^n ij * id\left( \ \gcd(i,j) \ \right) \\
&=\sum_{i=1}^n\sum_{j=1}^n ij \sum_{d\mid i,d\mid j} \varphi(d) &\text{欧拉函数性质 $6$} \\
&=\sum_{d=1}^n \varphi(d) *d^2 \left(\sum_{i=1}^{\left\lfloor \frac{n}{d} \right\rfloor} i \right)^2 &\text{两个 $i$ 可以合并} \\
\end{aligned}</script><ul>
<li><p>前半部分</p>
<p>  杜教筛 $\Rightarrow$ 设 $S(n)=\sum_{d=1}^n \varphi(d) * d^2$</p>
<p>  若使 $f\circ g$ 结果只有 $n$ $\Rightarrow$ 取 $g=id$</p>
<script type="math/tex; mode=display">\therefore f\circ g=\sum_{d\mid n} \varphi(d)*d^2 * \left(\frac{n}{d} \right)^2 = n^3 \quad \text{同理}</script><script type="math/tex; mode=display">\therefore S(n)=\frac{\sum_{i=1}^n\left(f\circ g \right) - \sum_{i=2}^n g\left(i\right)S\left(\left\lfloor \frac{n}{i} \right\rfloor \right) }{g(1)}</script><script type="math/tex; mode=display">1.\sum_{i=1}^n\left(f\circ g \right)=\sum_{i=1}^n i^3=\frac{n^2\left(n+1\right)^2}{4}</script><script type="math/tex; mode=display">2.\sum_{i=1}^ng(i)=\sum_{i=1}^ni^2=\frac{n(n+1)(2n+1)}{6}</script></li>
<li><p>右半部分</p>
<p>  求 $\displaystyle{\left(\sum_{i=1}^ni\right)^2}$</p>
<p>  然而我只会<a href="https://math.stackexchange.com/questions/1423948/trying-to-prove-sum-i-1n-i3-sum-i-1n-i2">证明$\displaystyle{\left(\sum_{i=1}^ni\right)^2=\sum_{i=1}^n i^3 }$</a></p>
<p>  最快的方法是差分</p>
<p>  设 $\displaystyle{A_n=\sum_{i=1}^n i^3 \ , \ B_n=\sum_{i=1}^n i}$</p>
<p>  一).</p>
<script type="math/tex; mode=display">显然有 A_1=B_1^2</script><p>  二).</p>
<script type="math/tex; mode=display">转化为求 \quad \Delta A_n=A_{n+1}-A_n=\Delta B_n^2</script><script type="math/tex; mode=display">\begin{aligned}
  \Delta B_n^2
  &=B_{n+1}^2-B_n^2 \\
  &=(B_{n+1}-B_n) * (B_{n+1}+B_n) \\
  &=(n+1) * \left(\frac{(n+1)(n+2)}{2} + \frac{n(n+1)}{2} \right) \\
  &=\frac{(n+1)^2}{2} (2n+2) \\
  &=(n+1)^3 \\
  &=\Delta A_n \\
  \end{aligned}</script><script type="math/tex; mode=display">\therefore \left(\sum_{i=1}^ni\right)^2=\sum_{i=1}^n i^3=\frac{n^2(n+1)^2}{4}</script></li>
</ul>
</li>
<li><p>11.</p>
<p><a href="https://www.luogu.com.cn/problem/P1587">P1587 [NOI2016] 循环之美</a></p>
<script type="math/tex; mode=display">求k进制下 ， \sum_{i=1}^n\sum_{j=1}^m \left[\frac{i}{j}是纯循环小数\right]</script><p>一个神仙转化如下</p>
<p>设该纯循环小数的循环节长度为 $times$，$\left\{\frac{x}{y}\right\}$ 表示 $\frac{x}{y}$ 的小数部分</p>
<p>在 $k$ 进制下，总有 $\displaystyle{\left\{\frac{x}{y} \right\} = \left\{\frac{x \cdot k^{times}}{y} \right\} }$</p>
<p>即</p>
<script type="math/tex; mode=display">\frac{x}{y}-\left\lfloor \frac{x}{y} \right\rfloor = \frac{x\cdot k^{times}}{y}-\left\lfloor \frac{x\cdot k^{times}}{y} \right\rfloor</script><script type="math/tex; mode=display">x-\left\lfloor \frac{x}{y} \right\rfloor \cdot y =x\cdot k^{times} - \left\lfloor \frac{x\cdot k^{times}}{y} \right\rfloor \cdot y</script><p>考虑到最简分数，即 $\gcd(x,y)=1$</p>
<script type="math/tex; mode=display">x \equiv x\cdot k^{times}\pmod y</script><script type="math/tex; mode=display">k^{times}\equiv 1\pmod y</script><script type="math/tex; mode=display">k\equiv 1\pmod y</script><p>$\therefore$ 问题转化为</p>
<script type="math/tex; mode=display">求\sum_{i=1}^n\sum_{j=1}^m [\gcd(i,j)=1] [\gcd(j,k)=1]</script><script type="math/tex; mode=display">\begin{aligned}
原式&=f(n,m,k)\\
&=\sum_{i=1}^n\sum_{jd=1}^m[\gcd(i,jd)=1] \sum_{d\mid dj,d\mid k} \mu(d) \\
&=\sum_{d\mid k} \mu(d) \sum_{i=1}^n\sum_{j=1}^{\left\lfloor \frac{m}{d} \right\rfloor} [\gcd(i,jd)=1] \\
&=\sum_{d\mid k}\mu(d) \cdot f\left(\frac{m}{d},n,d \right) \\
\end{aligned}</script><p>最后对 $k=1$ 的情况直接算即可</p>
</li>
<li><p>12.</p>
<p><a href="https://www.luogu.com.cn/problem/P3704">P3704 [SDOI2017]数字表格</a></p>
<script type="math/tex; mode=display">求\prod_{i=1}^n\prod_{j=1}^mf[\gcd(i,j)]</script><p>设 $n&lt;m$</p>
<script type="math/tex; mode=display">\begin{aligned}
原式&=\prod_{d=1}^{n}\prod_{i=1}^n\prod_{j=1}^m \ [\ \gcd(i,j)=d\ ] \ \cdot \ f[d] \\
&= \prod_{d=1}^{n}f[d]^{\left( \sum\limits_{i=1}^{n} \sum\limits_{j=1}^{m} [\ \gcd(i,j)=d\ ]\right) } \quad \text{乘积形式化为幂次} \\
\end{aligned}</script><p>看指数项<del>发现是HAOI2011</del></p>
<script type="math/tex; mode=display">\begin{aligned}
\sum\limits_{i=1}^{n} \sum\limits_{j=1}^{m} [\ \gcd(i,j)=d\ ]&=\sum^{ \left\lfloor \frac{n}{d} \right\rfloor }_{k=1} \mu(k) \left\lfloor \frac{n}{kd} \right\rfloor \left\lfloor \frac{m}{kd} \right\rfloor
\end{aligned}</script><p>$\sout{好了可以O(nT)了}$</p>
<p>用能量采集的 $\text{trick}$ 提出 $T=kd$ ,即</p>
<script type="math/tex; mode=display">\sum\limits_{T=1}^n\mu\left(\frac{T}{d}\right) \left\lfloor \frac{n}{T} \right\rfloor \left\lfloor \frac{m}{T} \right\rfloor [\ d\mid T \ ]</script><p>$T$ 对 $d$ 取值做出了限制条件 $\Rightarrow$ 考虑把 $T$ 提到式子最前面,即</p>
<script type="math/tex; mode=display">\prod_{T=1}^n\prod_{d\mid T} f[d]^{\left(\mu\left(\frac{T}{d} \right) \left\lfloor \frac{n}{T} \right\rfloor \left\lfloor \frac{m}{T} \right\rfloor \right)}</script><p>即</p>
<script type="math/tex; mode=display">\prod_{T=1}^n \left(\prod_{d\mid T} f[d]^{\mu\left(\frac{T}{d} \right) } \right)^{\left\lfloor \frac{n}{T} \right\rfloor \left\lfloor \frac{m}{T} \right\rfloor}</script></li>
</ul>
<hr>
<h3 id="要带更多的脑子"><a href="#要带更多的脑子" class="headerlink" title="要带更多的脑子"></a>要带更多的脑子</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="+数据结构"></a>+数据结构</h4><ul>
<li><p>$1.$</p>
<p><a href="https://www.luogu.com.cn/problem/P3312">P3312 [SDOI2014]数表</a></p>
<p>给定 $A$ , 求 $\displaystyle{\sum_{i=1}^n \sum_{j=1}^m d( \ \gcd(i,j) \ ) [ \ d( \ (\gcd(i,j) \ ) \leq A \ ]}$</p>
<p><del>众所周知 $d(n)$ 代表约数的和</del></p>
<script type="math/tex; mode=display">原式=\sum_{T=1}^n \left\lfloor \frac{n}{kd} \right\rfloor \left\lfloor \frac{m}{kd} \right\rfloor \sum_{x\mid T}\mu(x) * d\left(\frac{T}{x} \right) \left[ d\left(\frac{T}{x} \right) \leq A \right]</script><p>$设 \displaystyle{f(i)=\sum_{x\mid T}\mu(x) * d\left( \frac{T}{x} \right) \left[ d\left(\frac{T}{x} \right) \leq A \right]}$</p>
<p>看起来是关于 $(T,A)$</p>
<p>将询问按 $A$ 升序排列并提前处理 $d(x)$</p>
<p>当 $A$ 增大时，该函数值也以一定规律增大 $\Rightarrow$ 看成插入</p>
<p>$\therefore$ 需要支持插入与查询的数据结构 $\Rightarrow$ 树状数组</p>
<p>每次暴力加入所有 $d(x) \leq A$ 的 $x$</p>
<p>即对所有 $kx\leq n$ 都有 $f(kx)+=d(xyt4)\mu(k)$</p>
</li>
</ul>
<h4 id="记忆化"><a href="#记忆化" class="headerlink" title="+记忆化"></a>+记忆化</h4><ul>
<li><p>$1.$</p>
<p><a href="https://www.luogu.com.cn/problem/P4619">P4619 [SDOI2018]旧试题</a></p>
<p>求</p>
<script type="math/tex; mode=display">\sum_{i=1}^A\sum_{j=1}^B\sum_{k=1}^C d(i\times j\times k) \mod 10^9+7</script><p>首先可以回忆起 <a href="https://www.luogu.com.cn/problem/P3327">P3327 [SDOI2015]约数个数和</a> 这道题中对 $d(xy)$ 的处理方法： $d(i\times j)=\sum_{x\mid i}\sum_{y\mid j} [\gcd(x,y)=1]$</p>
<p>所以在该题中，对于每两个数都有以上关系式</p>
</li>
</ul>
<script type="math/tex; mode=display">\begin{aligned} 原式 

   &=\sum_{i=1}^A\sum_{j=1}^B\sum_{k=1}^C \sum_{u\mid i} \sum_{v\mid j} \sum_{w\mid k} [u\bot u] [u\bot w] [v\bot w] \\\\

  &=\sum_u \sum_v \sum_w [u\bot v] [u\bot w] [v\bot w] \left\lfloor \frac{A}{u} \right\rfloor \left\lfloor \frac{B}{v} \right\rfloor \left\lfloor \frac{C}{w} \right\rfloor \\

\end{aligned}</script><p>  考虑记忆化搜索<del>(指暴力)</del></p>
<p>  设 $f_{i,A,B,C}$ 表示对于所有满足 $(u,v) ; (u,w) ; (v,w)$ 的所有公共素因子不小于第 $i$ 个素数 $p_i$ 时 $\left\lfloor \frac{a}{u} \right\rfloor \left\lfloor \frac{b}{v} \right\rfloor \left\lfloor \frac{c}{w} \right\rfloor$ 的求和</p>
<p>  考虑转移：分为三组，两两考虑，以 $(u,v)$ 为例：</p>
<p>  对于 $f_{i-1,A,B,C}$ 可以分成两组：</p>
<p>  - $(u,v)$ 的公共素因子均不小于 $p_i$ ，我们需要的是这部分</p>
<p>  - $(u,v)$ 的公共素因子有 $p_{i-1}$ ，这部分需要被减去，即减去</p>
<script type="math/tex; mode=display">\left\lfloor \frac{\left\lfloor \frac{A}{p_{i-1}} \right\rfloor}{u} \right\rfloor \left\lfloor \frac{\left\lfloor \frac{B}{p_{i-1}} \right\rfloor}{v} \right\rfloor \left\lfloor \frac{C}{w} \right\rfloor</script><p>  $(u,w) , (v,w)$ 同理</p>
<p>  注意 $p_{i-1}\mid(u,v,w)$ 的情况被计算 $3$ 次，所以最后应该加上</p>
<script type="math/tex; mode=display">\left\lfloor \frac{\left\lfloor \frac{A}{p_{i-1}} \right\rfloor}{u} \right\rfloor \left\lfloor \frac{\left\lfloor \frac{B}{p_{i-1}} \right\rfloor}{v} \right\rfloor \left\lfloor \frac{\left\lfloor \frac{C}{p_{i-1}} \right\rfloor}{w} \right\rfloor \times 2</script><hr>
<h2 id="杜教筛"><a href="#杜教筛" class="headerlink" title="杜教筛"></a>杜教筛</h2><ul>
<li><p>用途：求积性函数 $\operatorname{f}(n)$ 的前缀和，即 $\sum_{i=1}^n f(i)$，其时间复杂度低于线性</p>
</li>
<li><p>方法：</p>
<p>$f(i)$ 为已知的函数</p>
<p>设 $S(n)=\sum f(i)$</p>
<p>出于前缀和的考虑，自行选取函数 $g(n)$ ，最好使 $f\circ g$ 的式子中没有除 $n$ 以外的变量</p>
<p>带入公式</p>
</li>
<li><p>推导</p>
<p>设函数 $S(n)=\sum_{i=1}^n f(i)$</p>
<p>要计算出 $S(n)$ 关于 $S\left(\left\lfloor\frac{n}{i}\right\rfloor\right)$ 的递推式才能使复杂度低于线性</p>
<p>设 $S(n)=\sum_{i=1}^n f(i)$</p>
<p>任取一数论函数 $\operatorname{g}$ 均有:</p>
<script type="math/tex; mode=display">\begin{aligned}
\sum_{i=1}^n \sum_{d\mid i} f(d)\cdot g\left(\frac{i}{d}\right)
&=\sum_{i=1}^n f\circ g \\
&=\sum_{i=1}^n g\circ f &\text{迪利克雷卷积性质}\\
&=\sum_{d=1}^n \sum_{k=1}^{\left\lfloor \frac{n}{d} \right\rfloor} g(d)f(k) &\text{改为枚举d，d的倍数k} \\
&=\sum_{d=1}^n g(d) S\left(\left\lfloor \frac{n}{d} \right\rfloor \right) \\
&=\sum_{i=1}^n (f\circ g) &\text{直接由原式得}\\
\end{aligned}</script><p>提取出 $i=1$ 时的 $g(1)S(n)$</p>
<pre><code>注：如果g是积性函数，g(1)=1
</code></pre><script type="math/tex; mode=display">\therefore g(1)S(n)=\sum_{i=1}^n (f\circ g) \ - \ \sum_{d=2}^n g(d) S\left(\left\lfloor \frac{n}{d} \right\rfloor \right)</script></li>
<li><p>$\mu$ 的前缀和</p>
<p>$设\operatorname{g}=I$</p>
<pre><code>I是恒等函数, 见积性函数
</code></pre><script type="math/tex; mode=display">\because \sum_{d\mid n} \mu \circ I=\epsilon(n)</script><script type="math/tex; mode=display">又\because g(1)S(n)=\sum_{i=1}^n \sum_{d\mid i} f(d)\cdot g\left(\frac{i}{d}\right) \ - \ \sum_{d=2}^n g(d) S\left(\left\lfloor \frac{n}{d} \right\rfloor \right)</script><script type="math/tex; mode=display">\therefore S(n)=\sum_{i=1}^n\epsilon(i) \ - \ \sum_{d=2}^n S\left(\left\lfloor \frac{n}{d} \right\rfloor \right)</script><script type="math/tex; mode=display">\therefore S(n)=1 \ - \ \sum_{d=2}^n S\left(\left\lfloor \frac{n}{d} \right\rfloor \right)</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">get_mu</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;MAX) <span class="keyword">return</span> sum_mu[x];<span class="comment">//直接线性筛</span></span><br><span class="line">    <span class="keyword">if</span>(mp_mu[x]) <span class="keyword">return</span> mp_mu[x];</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll l=<span class="number">1</span>,r;l&lt;=x;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">        r=x/(x/l);</span><br><span class="line">        ans-=<span class="built_in">get_mu</span>(x/l)*(r-l+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mp_mu[x]=ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>$\varphi$ 的前缀和</p>
<script type="math/tex; mode=display">由\varphi 性质得 n=\sum_{d\mid n}\varphi(d)</script><script type="math/tex; mode=display">\therefore id=\varphi \circ I</script><p>直接套到杜教筛公式得：</p>
<script type="math/tex; mode=display">\begin{aligned}
S(n)
&=\sum_{i=1}^ni-\sum_{i=2}^nS\left(\left\lfloor \frac{n}{i} \right\rfloor\right) \\
&=\frac{n(n+1)}{2} -\sum_{i=2}^nS\left(\left\lfloor \frac{n}{i} \right\rfloor\right)
\end{aligned}</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vis[<span class="number">0</span>]=vis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    mu[<span class="number">1</span>]=phi[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;N;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            p[++tot]=i;</span><br><span class="line">            mu[i]=<span class="number">-1</span>;</span><br><span class="line">            phi[i]=i<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=tot &amp;&amp; i*p[j]&lt;N;++j)&#123;</span><br><span class="line">            rei tmp=i*p[j];</span><br><span class="line">            vis[tmp]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%p[j])&#123;</span><br><span class="line">                mu[tmp]=-mu[i];</span><br><span class="line">                phi[tmp]=phi[i]*phi[ p[j] ];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                mu[tmp]=<span class="number">0</span>;</span><br><span class="line">                phi[tmp]=phi[i]*p[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;N;++i)&#123;</span><br><span class="line">        mu[i]+=mu[i<span class="number">-1</span>];</span><br><span class="line">        phi[i]+=phi[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getmu</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;N) <span class="keyword">return</span> mu[x];</span><br><span class="line">    <span class="keyword">if</span>(summu[x]) <span class="keyword">return</span> summu[x];</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll l=<span class="number">2</span>,r;l&lt;=(ll)x;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">        r=x/(x/l);</span><br><span class="line">        ans-=<span class="number">1ll</span>*(r-l+<span class="number">1</span>)*<span class="built_in">getmu</span>(x/l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> summu[x]=ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getphi</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;N) <span class="keyword">return</span> phi[x];</span><br><span class="line">    <span class="keyword">if</span>(sumphi[x]) <span class="keyword">return</span> sumphi[x];</span><br><span class="line">    ll ans=<span class="number">1ll</span>*x*(x+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll l=<span class="number">2</span>,r;l&lt;=(ll)x;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">        r=x/(x/l);</span><br><span class="line">        ans-=<span class="number">1ll</span>*(r-l+<span class="number">1</span>)*<span class="built_in">getphi</span>(x/l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sumphi[x]=ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
</search>
