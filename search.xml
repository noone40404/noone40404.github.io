<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>60801202-AGC004</title>
    <url>/2021/08/06/AGC004/</url>
    <content><![CDATA[<p><del>这场好难qwq</del> 我好菜</p>
<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><blockquote>
<p>有 $2$ 种操作: 花费 $a_i$ 秒，直接获得颜色 $i$ 和 花费 $x$ 秒，使得之前获得的颜色 $i$ 全部变为颜色 $(i+1) \ \text{mod} \ n$ ，求收集到 $0$ 到 $n-1$ 所有颜色的最短时间</p>
</blockquote>
<p>每种方案的 $2操作$ 取决于被 $2操作$ 作用次数最多的颜色，考虑枚举 $2操作$ ，滑动窗口查询最小值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">4e3</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,x,a[N],q[N];</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;x);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]),a[i+n]=a[i];</span><br><span class="line">	<span class="keyword">for</span>(rei k=<span class="number">0</span>;k&lt;n;++k)&#123;</span><br><span class="line">		ll s=(ll) k*x; rei l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=k;++i)&#123;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;=r &amp;&amp; a[ q[r] ]&gt;=a[i]) --r;</span><br><span class="line">			q[++r]=i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(rei i=k+<span class="number">1</span>;i&lt;=n+k;++i)&#123;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;=r &amp;&amp; i-k&gt;q[l]) ++l;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;=r &amp;&amp; a[ q[r] ]&gt;=a[i]) --r;</span><br><span class="line">			q[++r]=i; s+=a[ q[l] ];</span><br><span class="line">		&#125;</span><br><span class="line">		ans=k ? <span class="built_in">min</span>(ans,s) : s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><blockquote>
<p>给出一个由 # 和 $.$ 组成的矩阵，让你给出两个大小相同且 # 是相连的矩阵，且这两个矩阵的 $.$ 重叠部分刚好是给出的这个矩阵。</p>
</blockquote>
<p>考虑题目中保证边界不被染色，即边界中不含有 $.$</p>
<p>所以只需要让行按照奇偶染色，最后一边染起始列，一边染结束列来保证连通</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> s[N][N],a[N][N],b[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s[i]+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=m;++j) a[i][j]=b[i][j]=s[i][j];</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) a[i][<span class="number">1</span>]=b[i][m]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">for</span>(rei j=<span class="number">2</span>;j&lt;m;++j) i&amp;<span class="number">1</span> ? a[i][j]=<span class="string">&#x27;#&#x27;</span> : b[i][j]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,a[i]+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,b[i]+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>$n$ 个城市，每个城市有一个传送点，传送到唯一另外一个城市，保证经过多次传送始终能到达 $1$ 号城市。现在修改一些点的目的地，使得从任何一点出发在传送 $k$ 次之后恰好都能到达 $1$ 号城市，求最少改变的数量。</p>
</blockquote>
<p>简化问题模型：城市构成一个基环内向树，要求修改尽可能少的出边是每个点到 $1$ 号点需要经过至多 $k$ 条边（考虑到没说禁止自环</p>
<p>那么选一些点传送至 $1$ 号点，再把原树分为几颗，其中最大深度不能超过 $k-1$，贪心即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> tot,head[N],Next[N&lt;&lt;<span class="number">1</span>],ver[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> ac[<span class="number">20</span>][N],d[N],cov[N],ans,fa[N];</span><br><span class="line">priority_queue&lt;PII&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123; ver[++tot]=v,Next[tot]=head[u],head[u]=tot;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    d[x]=d[ fa[x] ]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;<span class="number">20</span>;++i) ac[i][x]=ac[i<span class="number">-1</span>][ ac[i<span class="number">-1</span>][x] ];</span><br><span class="line">    <span class="keyword">for</span>(rei i=head[x];i;i=Next[i]) <span class="built_in">dfs</span>(ver[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cover</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cov[x]) <span class="keyword">return</span>; cov[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=head[x];i;i=Next[i]) <span class="built_in">cover</span>(ver[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;fa[i]);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;=n;++i) <span class="built_in">add</span>(ac[<span class="number">0</span>][i]=fa[i],i);</span><br><span class="line">    ans+=fa[<span class="number">1</span>]!=<span class="number">1</span>;<span class="comment">//添加1节点的自环</span></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) q.<span class="built_in">push</span>(<span class="built_in">mk</span>(d[i],i));</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        rei x=q.<span class="built_in">top</span>().second,anc=x; q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(cov[x] || d[x]-d[<span class="number">1</span>]&lt;=m) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">19</span>;~i;--i) <span class="keyword">if</span>(d[x]-d[ ac[i][anc] ]&lt;m &amp;&amp; ac[i][anc]) anc=ac[i][anc];</span><br><span class="line">        <span class="built_in">cover</span>(anc); ++ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>一个棋盘，每个格子有机器人或空格或出口 ，每次命令所有机器人向任意一个方向移动一格，如果超出了棋盘的边界或到了出口就会消失，求机器人到出口的最多数量</p>
</blockquote>
<p>让机器人移动相当于移动出口，出口自带框，出框的机器人消失，出口抵达的机器人出去</p>
<p>定义 $l,r,u,d$ 四个参数表示出口 $E$ 向 $4$ 个方向能抵达的最远位置，在最优情况下出口会跑成一个矩形</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/4vyc5rkx.png" alt="官方图1"></p>
<p>黄色区域就是机器人的移动范围，在该范围内的机器人取舍已经被计算好</p>
<p>再考虑曾经有这个移动范围时，不能走的格子</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/txvynkqu.png" alt="官方图2"></p>
<p>纯红色区域中的机器人全部死亡，不管</p>
<p>对于红黄详见的部分之前已经取舍，考虑白色部分的转移：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/0cln7tdd.png" alt="官方图3"></p>
<p>移动范围扩大，加上相应颜色区域的机器人数量即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e2</span>+<span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">return</span> a&gt;b?a:b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">return</span> a&lt;b?a:b;&#125;</span><br><span class="line"><span class="keyword">short</span> f[N][N][N][N],g[N][N],h[N][N];</span><br><span class="line"><span class="keyword">char</span> s[N][N];</span><br><span class="line"><span class="keyword">int</span> n,m,ans,px,py;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s[i]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i][j]==<span class="string">&#x27;E&#x27;</span>) px=i,py=j;</span><br><span class="line">            g[i][j]=g[i][j<span class="number">-1</span>]+(s[i][j]==<span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">            h[i][j]=h[i<span class="number">-1</span>][j]+(s[i][j]==<span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    rei pl=py<span class="number">-1</span>,pr=m-py,pd=px<span class="number">-1</span>,pu=n-px,p;</span><br><span class="line">    <span class="keyword">for</span>(rei l=<span class="number">0</span>;l&lt;=pl;++l) <span class="keyword">for</span>(rei r=<span class="number">0</span>;r&lt;=pr;++r) <span class="keyword">for</span>(rei d=<span class="number">0</span>;d&lt;=pd;++d) <span class="keyword">for</span>(rei u=<span class="number">0</span>;u&lt;=pu;++u)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!(~f[l][r][d][u])) <span class="keyword">continue</span>;</span><br><span class="line">		rei cl=<span class="built_in">max</span>(r+<span class="number">1</span>,py-l),cr=<span class="built_in">min</span>(m-l,py+r),cd=<span class="built_in">max</span>(u+<span class="number">1</span>,px-d),cu=<span class="built_in">min</span>(n-d,px+u);</span><br><span class="line">		<span class="keyword">if</span>((p=py+r+<span class="number">1</span>)&lt;=m-l) f[l][r+<span class="number">1</span>][d][u]=<span class="built_in">max</span>(f[l][r+<span class="number">1</span>][d][u] , f[l][r][d][u]+h[cu][p]-h[cd<span class="number">-1</span>][p]);</span><br><span class="line">		<span class="keyword">if</span>((p=py-l<span class="number">-1</span>)&gt;=r+<span class="number">1</span>) f[l+<span class="number">1</span>][r][d][u]=<span class="built_in">max</span>(f[l+<span class="number">1</span>][r][d][u] , f[l][r][d][u]+h[cu][p]-h[cd<span class="number">-1</span>][p]);</span><br><span class="line">		<span class="keyword">if</span>((p=px+u+<span class="number">1</span>)&lt;=n-d) f[l][r][d][u+<span class="number">1</span>]=<span class="built_in">max</span>(f[l][r][d][u+<span class="number">1</span>] , f[l][r][d][u]+g[p][cr]-g[p][cl<span class="number">-1</span>]);</span><br><span class="line">		<span class="keyword">if</span>((p=px-d<span class="number">-1</span>)&gt;=u+<span class="number">1</span>) f[l][r][d+<span class="number">1</span>][u]=<span class="built_in">max</span>(f[l][r][d+<span class="number">1</span>][u] , f[l][r][d][u]+g[p][cr]-g[p][cl<span class="number">-1</span>]);</span><br><span class="line">		ans=<span class="built_in">max</span>(ans,f[l][r][d][u]);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>给定一个 $N$ 个点，$M$ 条边的连通无向简单图，其中 $N_1\leq M\leq N$ ，每个点可以为黑或白，初始每个点都白。每次选择一对具有相同颜色且相邻的顶点，并反转它们的颜色 (即如果一条边的两端是白色的，可以将其变为黑色)。询问是否存在一种方案，将所有的点都变成黑色，输出最少的操作次数。</p>
</blockquote>
<p>由数据范围：</p>
<ul>
<li><p>先考虑树的情况</p>
<p>把树看成一个二分图并将所有点重新染色-左红右蓝。如此在初始时所有边上的点颜色都不相同</p>
<p>考虑每次操作：将颜色相同的点反色。转化为新染色方案中，找一对颜色不同的两端点，并交换颜色。显然有 <strong><em>\</em>原图中两点颜色相同的边经过反色操作形成的反色且颜色相同的边**</strong> 对应到 <strong><em>\</em>新的染色方案中两点颜色不同的边操作后两点颜色仍不同**</strong></p>
<p>所以问题转化为是否有方案将左红右蓝转化为左蓝右红</p>
<p>在新染色方案上考虑，找到不变量红点数量与蓝点数量。显然若初始时 $num_红!=num_蓝$ 无解</p>
<p>移动红点到原先蓝点的位置。 直接计算最少方案并不容易，考虑每条边的贡献</p>
<p>设这条边断掉后，左边红点比蓝点多 $L$ 个，则改变一定还需要被经过 $L$ 次</p>
<p>所以枚举每条边，统计出其一侧的红蓝点数量差并将绝对值相加</p>
</li>
<li><p>基环树</p>
<p>由于刚才用到二分图的性质，因此想到对基环树分奇环/偶环考虑</p>
<ul>
<li><p>奇环</p>
<p>为满足二分图，先断掉这个奇环，此时问题与树的情况相同</p>
<p>在考虑断掉的边，由于奇环，该边的两端点在二分图中处于同一侧</p>
<p>所以该边的两个端点可以同时改变颜色，即 $2蓝\Rightarrow 2红$ 或 $2红\Rightarrow 2蓝$</p>
<p>可以把红色看成棋子，蓝色看成空位。这条边相当于一个<strong><em>\</em>源/汇**</strong>，可以不断提供/吞没成对的棋子</p>
<p>$\therefore$ 这里判断的是红蓝色是否有相同的奇偶性，否 则无解，是 则算出源/汇需要提供多少次棋子，并与树情况算出的累加</p>
</li>
<li><p>偶环</p>
<p>对于偶环仍然满足二分图性质，所以需要判断的是红蓝点数是否相同</p>
<p>偶环的作用是提供枢纽，减少环中绕行的次数。显然环外的边经过次数不变，而环内边的经过次数相互约束：环内相邻两条边的经过次数（带符号）的差值恒定且与点有关</p>
<p>可以发现环上的交换是一个<a href="https://www.luogu.com.cn/problem/P2512">均分纸牌问题</a>，求中位数即可</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rei register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100054</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,L;</span><br><span class="line"><span class="keyword">int</span> ver[N&lt;&lt;<span class="number">1</span>],head[N],Next[N&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line"><span class="keyword">int</span> fa[N],depth[N],Size[N];</span><br><span class="line"><span class="keyword">int</span> cnt,buf[N];</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ad</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> (x<span class="number">-1</span>^<span class="number">1</span>)+<span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123; ver[++tot]=v,Next[tot]=head[u],head[u]=tot; ver[++tot]=u,Next[tot]=head[v],head[v]=tot;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	Size[x]=-(depth[x]&amp;<span class="number">1</span>) | <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=head[x],y;i;i=Next[i])</span><br><span class="line">		<span class="keyword">if</span>(!~fa[ y=ver[i] ]) fa[y]=x,depth[y]=depth[x]+<span class="number">1</span>,<span class="built_in">dfs</span>(y),Size[x]+=Size[y];</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(depth[x]&lt;depth[y]) L=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	rei incr; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>,u,v;i&lt;m;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v),<span class="built_in">add</span>(u,v);</span><br><span class="line">	<span class="built_in">memset</span>(fa,<span class="number">-1</span>,<span class="keyword">sizeof</span> fa),fa[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(m==n<span class="number">-1</span>)&#123;<span class="comment">//树</span></span><br><span class="line">		<span class="keyword">if</span>(Size[<span class="number">1</span>]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>),<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) ans+=<span class="built_in">abs</span>(Size[i]);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans),<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	rei	u=ver[ <span class="built_in">ad</span>(L) ],v=ver[L];</span><br><span class="line">	<span class="keyword">if</span>( (depth[u]^depth[v]) &amp;<span class="number">1</span>)&#123;<span class="comment">//偶环</span></span><br><span class="line">		<span class="keyword">if</span>(Size[<span class="number">1</span>]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>),<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(rei i=v;i!=u;i=fa[i]) buf[cnt++]=Size[i];</span><br><span class="line">		++cnt;</span><br><span class="line">		<span class="built_in">nth_element</span>(buf,buf+cnt/<span class="number">2</span>,buf+cnt);</span><br><span class="line">		<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;cnt;++i) ans+=<span class="built_in">abs</span>(buf[i]-buf[cnt/<span class="number">2</span>])-<span class="built_in">abs</span>(buf[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;<span class="comment">//奇环</span></span><br><span class="line">		<span class="keyword">if</span>(Size[<span class="number">1</span>]&amp;<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>),<span class="number">0</span>;</span><br><span class="line">		incr=-Size[<span class="number">1</span>]/<span class="number">2</span>,ans=<span class="built_in">abs</span>(incr);</span><br><span class="line">		rei i;</span><br><span class="line">		<span class="keyword">for</span>(i=v;i!=u;i=fa[i]) Size[i]+=incr;</span><br><span class="line">		<span class="keyword">for</span>(;i;i=fa[i]) Size[i]+=incr&lt;&lt;<span class="number">1</span>;<span class="comment">//加上源/汇点贡献</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) ans+=<span class="built_in">abs</span>(Size[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>构造</tag>
        <tag>dp</tag>
        <tag>贪心</tag>
        <tag>染色</tag>
      </tags>
  </entry>
  <entry>
    <title>50801202-AGC003</title>
    <url>/2021/08/05/AGC003/</url>
    <content><![CDATA[<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>给定 $n$ 个数 ，要求从中选出最多的数，满足任意两个数之积都不是完全立方数</p>
</blockquote>
<p>考虑对数 $x$ 进行唯一分解，即将其每个质因子的指数对 $3$ 取模得到数 $a$ , 在对 $a$ 的每个质因子的指数的相反数对 $3$ 取模得到 $a$ 的补数 $b$ ,满足 $a\times b$ 是完全立方数</p>
<p>对于数列中的分解数集与其补数集，贪心选取较大的内个，注意特判最简数与其补数相等时（即 $x$ 是完全平方数）只能选一个</p>
<p>重点求如何分解数与分解数的补数</p>
<p>筛出 $10^{\frac{10}{3}}$ 内的质数，求出该范围内的分解数与补数，对于剩余的数分解质因数最多 $2$ 项，特判是否为完全平方数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p[]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">37</span>&#125;,S=<span class="number">127</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line">vector&lt;ll&gt; pd;</span><br><span class="line"><span class="keyword">int</span> n,c[N],ans;</span><br><span class="line">ll a[N],b[N];</span><br><span class="line">map&lt;ll,<span class="keyword">int</span>&gt; h,vis;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">qpow</span><span class="params">(ll a,ll b,ll n)</span></span>&#123; ll ret=<span class="number">1</span>; <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>,a=a*a%n) <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ret=a*ret%n; <span class="keyword">return</span> ret;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123; <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b,a%b) : a;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">miller_rabin</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;<span class="number">12</span>;++i) <span class="keyword">if</span>(n%p[i]==<span class="number">0</span>) <span class="keyword">return</span> n==p[i];</span><br><span class="line">    ll r; rei t;</span><br><span class="line">    <span class="keyword">for</span>(r=n<span class="number">-1</span>,t=<span class="number">0</span>;~r&amp;<span class="number">1</span>;r&gt;&gt;=<span class="number">1</span>,++t);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;<span class="number">12</span>;++i)&#123;</span><br><span class="line">        ll x=<span class="built_in">qpow</span>(p[i],r,n),xs;</span><br><span class="line">        <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=t;++j)&#123;</span><br><span class="line">            xs=x*x%n;</span><br><span class="line">            <span class="keyword">if</span>(xs==<span class="number">1</span> &amp;&amp; x!=<span class="number">1</span> &amp;&amp; x!=n<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            x=xs;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x!=<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=<span class="number">2200</span>;++i) <span class="keyword">if</span>(<span class="built_in">miller_rabin</span>(i)) pd.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        ll x,t; <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;x); a[i]=b[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(rei k=<span class="number">0</span>;k&lt;pd.<span class="built_in">size</span>();++k)&#123;</span><br><span class="line">            c[k]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(x%pd[k]==<span class="number">0</span>) ++c[k],x/=pd[k];</span><br><span class="line">            c[k]%=<span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span>(c[k]==<span class="number">2</span>) a[i]*=pd[k]*pd[k],b[i]*=pd[k];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c[k]==<span class="number">1</span>) a[i]*=pd[k],b[i]*=pd[k]*pd[k];</span><br><span class="line">        &#125;</span><br><span class="line">        t=<span class="built_in">sqrt</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(t*t==x) a[i]*=t*t,b[i]*=t;</span><br><span class="line">        <span class="keyword">else</span> a[i]*=x,b[i]*=x*x;</span><br><span class="line">        ++h[ a[i] ];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[ a[i] ]||vis[ b[i] ]||a[i]==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        vis[ a[i] ]=<span class="number">1</span>; ans+=<span class="built_in">max</span>(h[ a[i] ],h[ b[i] ]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans+(h[<span class="number">1</span>]!=<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>初始为 $1$ 到 $n$ 的数列，每次操作把数组长度变为 $q_i$ ，新增的数为上一个操作后的数组的重复，求最终每个数出现的次数</p>
</blockquote>
<p><del>这个题作为 $E$ 题好像有点水（逃</del></p>
<p>首先容易发现，对于每次操作，只有长度单调递增的操作对答案有贡献</p>
<p>考虑每次操作 $q$ 对数组 $A={a_1,a_2…a_n}$ 的影响：</p>
<script type="math/tex; mode=display">A\Rightarrow \underbrace{AAA...A}_{k=\left\lfloor \frac{q}{len_A} \right\rfloor} \ + \ a_1 \ + \ a_2 \ + \ ... \ + a_{q\%len_A}</script><p>题目要求维护 $ans[N]$，那么倒序维护系数 $k$ ，对于剩下的一部分递归继续分解</p>
<p>最后的答案用差分维护</p>
<p><del>经典不会表述，经典看不懂赛时代码</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line">ll k[N],delta[N],sta[N],top;</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decompose</span><span class="params">(ll lenth,ll k_add)</span></span>&#123;</span><br><span class="line">    rei it=<span class="built_in">upper_bound</span>(sta+<span class="number">1</span>,sta+<span class="number">1</span>+top,lenth)-sta<span class="number">-1</span>;<span class="comment">//注意这里要找剩下的</span></span><br><span class="line">    <span class="keyword">if</span>(!it) <span class="keyword">return</span> delta[<span class="number">1</span>]+=k_add,delta[lenth+<span class="number">1</span>]-=k_add,<span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">    k[it]+=(ll) (lenth/sta[it])*k_add;</span><br><span class="line">    <span class="built_in">decompose</span>(lenth%sta[it],k_add);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;q),sta[++top]=(ll) n;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=q;++i)&#123;</span><br><span class="line">        ll x; <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;x);</span><br><span class="line">        <span class="keyword">while</span>(top &amp;&amp; x&lt;=sta[top]) --top;</span><br><span class="line">        sta[++top]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    k[top]=<span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=top;i&gt;=<span class="number">2</span>;--i)&#123;</span><br><span class="line">        k[i<span class="number">-1</span>]+=(sta[i]/sta[i<span class="number">-1</span>])*k[i];</span><br><span class="line">        <span class="built_in">decompose</span>(sta[i]%sta[i<span class="number">-1</span>],k[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    delta[<span class="number">1</span>]+=k[<span class="number">1</span>],delta[ sta[<span class="number">1</span>]+<span class="number">1</span> ]-=k[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,delta[i]+=delta[i<span class="number">-1</span>]);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>给定一个 $n\times m$ 的黑白网格，保证黑格四连通且至少有一个黑格，定义分形如下：$0$ 级分形是一个 $1\times 1$ 的黑色单元格。$k+1$ 级分形由 $n$ 行 $m$ 列较小一级的分形按网格的样式拼成：与黑色单元格对应的位置是一个 $k$ 级分形；与白色单元格对应的位置是一个全部为白色，尺寸与 $k$ 级分形相同的网格。求 $k$ 级分形的四联通数量</p>
</blockquote>
<p>看个图直观一点</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ihi8a16b.png" alt="https://cdn.luogu.com.cn/upload/image_hosting/ihi8a16b.png"></p>
<p>考虑无向图 $G$ ，其中的点与 $1$ 级分形一一对应，将对应至少一个位置的黑发四联通的点连边</p>
<p>求$k$ 级分形对应的 $G$ 的连通分量数</p>
<p>显然 $G$ 的连边情况与网格的上下，左右的黑格位置是否重复有关，设 $lr,ud$ 分别表示上下，左右的黑格位置重复的个数，$v$ 表示原网格中黑格的个数，$ev,eh$ ：垂直/水平方向的相邻黑格的个数</p>
<ul>
<li><p>若 $lr&gt;0 \wedge ud&gt;0$，归纳可得 $G$ 任意两点均连通，故答案为 $1$。</p>
</li>
<li><p>若 $lr=0 \wedge ud=0$，归纳可得 $G$ 任意两点均不连通，故答案为 $v^{k-1}$。</p>
</li>
<li><p>若 $lr&gt;0 \wedge ud=0$，将网格逆时针旋转 $\frac{1}{4}$ 周变为情况 $4$。</p>
</li>
<li><p>若 $lr=0 \wedge ud&gt;0$，我们可以发现所有边都是垂直方向的，故 $G$ 一定是若干条垂直方向的链组成的。</p>
</li>
</ul>
<p>链是树，我们可以用 $C=V-E$ 来计算连通分量数。</p>
<p>有性质: $k$ 级分形等于把 $k-1$ 级分形的每个黑格替换成一个 $1$ 级分形。可以归纳证明。</p>
<p>那么考虑计算 $k$ 级分形对应的图 $G_k$ 中的点数 $V_k$ 和边数 $E_k$ ，有递推式：</p>
<p>$V_k=V_{k-1}\times v ,V_1=1$</p>
<p>$E_k=E_{k-1}\times ud + V_{k-1}\times ev ,E_1=0$</p>
<p>所以矩阵乘法计算 $V,E$ 线性递推</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e3</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll k;</span><br><span class="line"><span class="keyword">char</span> s[N][N];</span><br><span class="line"><span class="keyword">int</span> n,m,p,q,a,b,c;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Mat[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">Matrix</span>()&#123; <span class="built_in">memset</span>(Mat,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(Mat));&#125;</span><br><span class="line">    <span class="keyword">int</span>* <span class="keyword">operator</span> [](<span class="keyword">const</span> <span class="keyword">int</span> i)&#123; <span class="keyword">return</span> Mat[i];&#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span>*(Matrix &amp;mat)<span class="keyword">const</span>&#123;</span><br><span class="line">        Matrix ret;</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;<span class="number">2</span>;++j) <span class="keyword">for</span>(rei k=<span class="number">0</span>;k&lt;<span class="number">2</span>;++k)</span><br><span class="line">            ret[i][j]=(ret[i][j]+(ll) Mat[i][k]*mat[k][j]%mod)%mod;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">()</span></span>&#123; <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i) Mat[i][i]=<span class="number">1</span>;&#125;</span><br><span class="line">&#125;f;</span><br><span class="line"><span class="function">Matrix <span class="title">qpow</span><span class="params">(Matrix a,ll b)</span></span>&#123; Matrix ret;ret.<span class="built_in">set</span>(); <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>,a=a*a) <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ret=ret*a; <span class="keyword">return</span> ret;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s[i]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) p+=s[i][<span class="number">1</span>]==<span class="string">&#x27;#&#x27;</span>&amp;&amp;s[i][m]==<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=m;++i) q+=s[<span class="number">1</span>][i]==<span class="string">&#x27;#&#x27;</span>&amp;&amp;s[n][i]==<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>((p&amp;&amp;q) || k&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>),<span class="number">0</span>;</span><br><span class="line">	b=p|q;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">            c+=s[i][j]==<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">            a+=s[i][j]==<span class="string">&#x27;#&#x27;</span> &amp;&amp; s[i][j+<span class="number">1</span>]==<span class="string">&#x27;#&#x27;</span> &amp;&amp; p;</span><br><span class="line">            a+=s[i][j]==<span class="string">&#x27;#&#x27;</span> &amp;&amp; s[i+<span class="number">1</span>][j]==<span class="string">&#x27;#&#x27;</span> &amp;&amp; q;</span><br><span class="line">        &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=c,f[<span class="number">1</span>][<span class="number">0</span>]=a,f[<span class="number">1</span>][<span class="number">1</span>]=b;</span><br><span class="line">	f=<span class="built_in">qpow</span>(f,k<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(f[<span class="number">0</span>][<span class="number">0</span>]-f[<span class="number">1</span>][<span class="number">0</span>]+mod)%mod);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>贪心</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>40801202-AGC002</title>
    <url>/2021/08/04/AGC002/</url>
    <content><![CDATA[<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>给一张图，多次询问，每次 $u\leftarrow v$ 中经过的不重复点数量 $=z$ ，求经过边最大编号最小值</p>
</blockquote>
<p>边权问题想到 $Kruskal$ 重构树</p>
<p>重构树上倍增二分即可</p>
<p><del>这道题还有一种整体二分+并查集做法，但我不会</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,w;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node &amp;a,<span class="keyword">const</span> node &amp;b)&#123; <span class="keyword">return</span> a.w&lt;b.w;&#125;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> anc[<span class="number">20</span>][N&lt;&lt;<span class="number">1</span>],fa[N&lt;&lt;<span class="number">1</span>],Size[N&lt;&lt;<span class="number">1</span>],edge_val[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_fa</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x==fa[x] ? x : fa[x]=<span class="built_in">find_fa</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find_anc</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">19</span>;~i;--i) <span class="keyword">if</span>(edge_val[ anc[i][x] ]&lt;=d) x=anc[i][x];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    x=<span class="built_in">find_anc</span>(x,d),y=<span class="built_in">find_anc</span>(y,d);</span><br><span class="line">    <span class="keyword">return</span> x==y ? Size[x]&gt;=z : Size[x]+Size[y]&gt;=z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    edge_val[<span class="number">0</span>]=m+<span class="number">1</span>; root=n;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) fa[i]=i,Size[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        rei u,v; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">        u=<span class="built_in">find_fa</span>(u),v=<span class="built_in">find_fa</span>(v);</span><br><span class="line">        <span class="keyword">if</span>(u==v) <span class="keyword">continue</span>;</span><br><span class="line">        fa[u]=fa[v]=++root;Size[root]=Size[u]+Size[v];</span><br><span class="line">        fa[root]=root; anc[<span class="number">0</span>][u]=anc[<span class="number">0</span>][v]=root; edge_val[root]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=root;i;--i) <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;<span class="number">20</span>;++j) anc[j][i]=anc[j<span class="number">-1</span>][ anc[j<span class="number">-1</span>][i] ];</span><br><span class="line">    rei Q;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;Q);</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        rei x,y,z; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        rei l=<span class="number">1</span>,r=m,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            rei mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">check</span>(x,y,z,mid) ? ans=mid,r=mid<span class="number">-1</span> : l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>博弈论 每次操作将当前最大堆的糖果全部吃完或将每堆糖果吃掉一个，吃完的人输</p>
</blockquote>
<p>GreenDay学长之前讲过</p>
<p>将每堆小石子的数量看成柱状图并排序，问题转化为从 $(1,1)$ 出发，每次只能向上或向右走一格，到边界者输</p>
<p>显然棱角处均为必败点，且<del>打表得</del> $y=-k\times x$ 直线上的格子性质相同</p>
<p>找最大的 $(i,i)$ 再简单判断即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">		<span class="keyword">if</span>(i+<span class="number">1</span>&gt;a[i+<span class="number">1</span>])&#123;<span class="comment">//最大正方形</span></span><br><span class="line">			<span class="keyword">if</span>((a[i]-i)&amp;<span class="number">1</span>)&#123; <span class="built_in">puts</span>(<span class="string">&quot;First&quot;</span>); <span class="keyword">break</span>;&#125;</span><br><span class="line">			rei right=i;</span><br><span class="line">			<span class="keyword">while</span>(a[right+<span class="number">1</span>]==i) ++right;</span><br><span class="line">			<span class="keyword">if</span>((right-i)&amp;<span class="number">1</span>)&#123; <span class="built_in">puts</span>(<span class="string">&quot;First&quot;</span>); <span class="keyword">break</span>;&#125;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;Second&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>给你 $n$ 种不含白色颜色的球，每个球有 $m$ 个，把这 $n\times m$ 个球排成一排，把每一种颜色的最左边出现的球涂成白色，求有多少种不同的颜色序列</p>
</blockquote>
<p>有 $m$ 个白球，$n$ 种其他颜色的球各 $m-1$ 个 只有任意前缀中白球的个数均大于其他颜色种类数时合法</p>
<p>考虑序列计数 $dp$: 枚举位置或元素，这里枚举元素</p>
<p>设状态 $f_{i,j}$ 表示在 $n\times m$ 个位置上填了 $i$ 个白球和 $j$ 个其他球</p>
<p>考虑合法序列的从左到右的第一个格子如何转移</p>
<script type="math/tex; mode=display">\therefore f_{i,j}=\underbrace{f_{i-1,j}}_{放白球} \ + \ \underbrace{f_{i,j-1}}_{放其他颜色} \times \underbrace{\left(n-j+1\right)}_{没有使用过的颜色}\times \underbrace{\binom{n\times m-i-(m-1)\times (j-1)-1}{m-2}}_{还有 m-2 个该颜色的球没有放}</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e3</span>+<span class="number">5</span>,M=<span class="number">4e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,f[N][N],fac[M],ifac[M],inv[M],ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123; <span class="keyword">return</span> (ll) fac[n]*ifac[n-m]%mod*ifac[m]%mod;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m); inv[<span class="number">1</span>]=ifac[<span class="number">0</span>]=fac[<span class="number">0</span>]=<span class="number">1</span>; f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;=n*m;++i) inv[i]=(ll) (mod-mod/i)*inv[mod%i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n*m;++i) fac[i]=(ll) i*fac[i<span class="number">-1</span>]%mod,ifac[i]=(ll) inv[i]*ifac[i<span class="number">-1</span>]%mod;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;=i;++j)&#123;</span><br><span class="line">            f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j) f[i][j]=(f[i][j]+(ll) f[i][j<span class="number">-1</span>]*(n-j+<span class="number">1</span>)%mod *<span class="built_in">C</span>(n*m-i-(j<span class="number">-1</span>)*(m<span class="number">-1</span>)<span class="number">-1</span>,m<span class="number">-2</span>)%mod)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,m==<span class="number">1</span> ? <span class="number">1</span> : f[n][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>构造</tag>
        <tag>dp</tag>
        <tag>博弈论</tag>
        <tag>Kruskal重构树</tag>
      </tags>
  </entry>
  <entry>
    <title>90801202-AGC006</title>
    <url>/2021/08/09/AGC006/</url>
    <content><![CDATA[<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><blockquote>
<p>一个数字三角形，最下层的值是 $1\sim 2n-1$ 的排列，其余的值是正下，左下，右下方三个值的中位数，给定 $n,x$ ， 求能构造出顶端是 $x$ 的最下层排列</p>
</blockquote>
<p>先考虑无解：即 $x=1 或 x=2n-1$ 时无解</p>
<p>其次可以发现，对于两个相邻的相同数字，该数字会一直向上延伸</p>
<p>而 $x$ 就是离对称轴最近且满足条件的数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,x,p[N],vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;x);</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1</span> || x==<span class="number">2</span>*n<span class="number">-1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>),<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    p[n]=x;</span><br><span class="line">	p[n<span class="number">-1</span>]=x==<span class="number">2</span> ? x+<span class="number">1</span> : x<span class="number">-1</span>,p[n+<span class="number">1</span>]=x==<span class="number">2</span> ? x<span class="number">-1</span> : x+<span class="number">1</span>,p[n+<span class="number">2</span>]=x==<span class="number">2</span> ? x+<span class="number">2</span> : x<span class="number">-2</span>;</span><br><span class="line">    vis[x]=vis[x+<span class="number">1</span>]=vis[x<span class="number">-1</span>]=vis[x==<span class="number">2</span> ? x+<span class="number">2</span> : x<span class="number">-2</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,j=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n<span class="number">-1</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">while</span>(vis[j]) ++j;</span><br><span class="line">        p[i]=j,vis[j]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n<span class="number">-1</span>;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p[i]);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><blockquote>
<p>数轴上有 $n$ 只兔子，第 $i$ 只位于 $a_i$ ，做 $k$ 次移动，每次由 $m$ 次跳跃，对于第 $j$ 次跳跃，第 $c_j$ 只兔子等概率选取 $c_{j-1}$ 或 $c_{j+1}$ 的兔子并跳到其对称点，求每一只兔子最终位置的期望</p>
</blockquote>
<p>对于兔子 $c_j$ ，跳跃后会转移到 $2\times c_{j-1}-c_j$ 或 $2\times c_{j+1}-c_j$</p>
<p>所以有 $f’_{c_j}=\frac{2\times f_{c_{j-1}}-f_{c_j}+2\times f_{c_{j+1}}-f_{c_j}}{2}=f_{c_{j-1}}+f_{c_{j+1}}-f_{c_j}$</p>
<p>而进行 $k\leq 10^{18}$ 轮，时间复杂度显然会爆</p>
<p>$\text{ctp_314}$ 告诉我们，遇到转移问题难以转移就想一想差分，即， $d_i=f_i-f_{i-1}$</p>
<p>差分的转移为:</p>
<script type="math/tex; mode=display">d'_i=(f_{i-1}+f_{i+1}-f_i)-f_{i-1}=f_{i+1}-f_i=d_{i+1} \\
d'_{i+1}=f_{i+1}-(f_{i-1}+f_{i+1}-f_i)=f_i-f_{i-1}=d_i \\</script><p>恰好是交换，那么求出循环节即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[N],f[N],s[N],top,vis[N];</span><br><span class="line">ll ans[N],k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(rei i=n;i;--i) a[i]-=a[i<span class="number">-1</span>],f[i]=i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>,&amp;m,&amp;k);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>,p;i&lt;=m;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p),<span class="built_in">swap</span>(f[p],f[p+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i,top=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            <span class="keyword">for</span>(rei j=i;!vis[j];j=f[j]) vis[j]=<span class="number">1</span>,s[++top]=j;</span><br><span class="line">            <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=top;++j) ans[ s[j] ]=a[ s[(j+k<span class="number">-1</span>)%top+<span class="number">1</span>] ];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans[i]+=ans[i<span class="number">-1</span>]);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>数字三角形，生成规则与 $B$ 相同，给定第 $n$ 行的数列，求第 $1$ 行的</p>
</blockquote>
<p>不会的二分贪心思维题</p>
<p>二分顶端的数，由于用中位数生成，所以数列中只需要保留与顶端数的大小关系，即将原数列转化为 $01$ 串</p>
<p>由 $B$ 推出的性质推广得：当存在两个相邻的 $0/1$，且不与边界相邻，那么可以一直向上走</p>
<p>即，离对称轴最近且长度至少为 $2$ 的连续段就是顶端答案</p>
<p>最后特判不存在该连续段的情况</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,ans=<span class="number">2</span>,p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">valid</span><span class="params">(<span class="keyword">int</span> mid)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;++i)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">max</span>(p[n-i],p[n-i<span class="number">-1</span>])&lt;=mid || <span class="built_in">max</span>(p[n+i],p[n+i+<span class="number">1</span>])&lt;=mid) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">min</span>(p[n-i],p[n-i<span class="number">-1</span>])&gt;mid || <span class="built_in">min</span>(p[n+i],p[n+i+<span class="number">1</span>])&gt;mid) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> p[<span class="number">1</span>]&lt;=mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n); <span class="keyword">for</span>(rei i=<span class="number">2</span>*n<span class="number">-1</span>;i;--i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p[i]);</span><br><span class="line">    rei l=<span class="number">2</span>,r=<span class="number">2</span>*n<span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        rei mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">valid</span>(mid) ? r=mid<span class="number">-1</span>,ans=mid : l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>给定 $3\times N$ 的矩阵，点 $(i,j)$ 的数为 $i+3j-3$ 。有操作：选择 $3\times 3$ 的矩阵，并将其旋转 $180^。$ 。给定目标矩阵，询问是否可以转化</p>
</blockquote>
<p>首先考虑无解：</p>
<ul>
<li>将每一列堪为一个整体，整体内部的元素组成不变</li>
<li>所有模 $3$ 余 $2$ 的数一定在第二行</li>
</ul>
<p>再考虑性质：每次以 $(i,2)$ 为中心旋转实际是交换 $i-1,i+1$ 列，并将 $[i-1,i+1]$ 上下颠倒 —— 将上下颠倒看作奇偶性，奇数时要上下颠倒</p>
<p>将每一列当成字母，小写为颠倒前，大写为颠倒后，设 $abcde$ 为原矩形的部分</p>
<p>其次可以推出结论：</p>
<ul>
<li><p>可以将隔着一列的两列数同时颠倒</p>
<script type="math/tex; mode=display">\underline{abc}de \Rightarrow CB\underline{Ade} \Rightarrow \underline{CBE}Da \Rightarrow eb\underline{cDa}\Rightarrow \underline{ebA}dC \Rightarrow aBcDe</script></li>
<li><p>可以同时改变相邻 $4$ 列的奇偶性</p>
<script type="math/tex; mode=display">\underline{abc}d \Rightarrow C\underline{BAd} \Rightarrow \underline{CDa}b \Rightarrow A\underline{dcb} \Rightarrow ABCD</script></li>
</ul>
<p>$\therefore$ 可以成对改变边的奇偶性，那么只需要考虑最终状态 奇数列 与 偶数列上下颠倒个数 的奇偶性，若都为偶则合法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">3</span>][N],f[N],h[<span class="number">2</span>],n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i) <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=n;++j) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i][j]);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        rei a=w[<span class="number">0</span>][i],b=w[<span class="number">1</span>][i],c=w[<span class="number">2</span>][i];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(a-b)&gt;<span class="number">1</span> || <span class="built_in">abs</span>(b-c)&gt;<span class="number">1</span> || b%<span class="number">3</span>!=<span class="number">2</span> || (b%<span class="number">6</span> &amp; i&amp;<span class="number">1</span>)) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>),<span class="number">0</span>;</span><br><span class="line">        f[i]=b/<span class="number">3</span>+<span class="number">1</span>,h[i&amp;<span class="number">1</span>]^=a&gt;c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">while</span>(f[i]!=i) h[ i&amp;<span class="number">1</span>^<span class="number">1</span> ]^=<span class="number">1</span>,<span class="built_in">swap</span>(f[i],f[ f[i] ]);</span><br><span class="line">    h[<span class="number">0</span>]||h[<span class="number">1</span>] ? <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>) : <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>给定 $n\times n$ 的网格，给定黑点坐标，其余白色，若存在 $(x,y)$ 和 $(y,z)$ 则会出现一个 $(z,x)$ 的黑点，求最终黑点数</p>
</blockquote>
<p>若 $(x,y)$ 为黑色，则连 $x\rightarrow y$ 的边，将题目等价于：若有 $x\rightarrow y 且 y\rightarrow z$ ，则有 $z\rightarrow x$</p>
<p>如此连边不会影响连通性，只需考虑一个连通块内的情况并累加即可</p>
<p><strong>由连边方式构成的三元环结构引导我们对图染色</strong></p>
<p>连边方式自然定为：若 $x\rightarrow y$ , 则有 $col(x)+1\equiv col(y) \pmod 3$</p>
<p>对染色情况分类：</p>
<ul>
<li><p>所有点只用 $\leq 2$ 中颜色且成功</p>
<p>即没有出现新边，最终边数 $|E’|$ 等于原边数 $|E|$</p>
</li>
<li><p>所有点用 $3$ 种颜色且成功</p>
<p>可以证明此时图 $G$ 具有完全三分图的结构</p>
<p>在此情况下，总边数等于各个部分大小的两两乘积和</p>
</li>
<li><p>染色失败</p>
<p>设加入边 $(u,v)$ 时失败，即，加入该边前 $u,v$ 已经连通，此时他们所在的连通分量是一个完全三分图</p>
<p>考虑失败原因</p>
<ul>
<li><p>$1\rightarrow 0$</p>
<p>即自环存在于 $0\rightarrow 1\rightarrow 0$</p>
</li>
<li><p>$0\rightarrow 0$</p>
<p>即有 $0\rightarrow 0\rightarrow 1\rightarrow 0$</p>
</li>
</ul>
<p>对于自环 $s\rightarrow s$ ,可以证明所有与 $s$ 相连的点 $u$ ,都有重边； 而对于 $\forall v,u$ 都有 $v\rightarrow s\rightarrow u \rightarrow v$</p>
<p>即，图 $G$ 完全图</p>
<p>该情况下总边数时连通分量大小的平方</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],Next[N&lt;&lt;<span class="number">1</span>],ver[N&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line"><span class="keyword">int</span> col[N],c[<span class="number">3</span>],n,m,ce;</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123; ver[++tot]=v,Next[tot]=head[u],head[u]=tot;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> result=<span class="literal">true</span>; ++c[ col[x] ];</span><br><span class="line">    <span class="keyword">for</span>(rei i=head[x];i;i=Next[i])&#123;</span><br><span class="line">        rei y=ver[i];</span><br><span class="line">        rei c=(col[x]+<span class="number">2</span>-(i&amp;<span class="number">1</span>))%<span class="number">3</span>; ++ce;</span><br><span class="line">        result&amp;=(~col[y] ? col[y]==c : (col[y]=c,<span class="built_in">dfs</span>(y)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,u,v;i&lt;=m;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v),<span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">    <span class="built_in">memset</span>(col,<span class="number">-1</span>,<span class="keyword">sizeof</span> col);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span>(!~col[i])&#123;</span><br><span class="line">            c[<span class="number">0</span>]=c[<span class="number">1</span>]=c[<span class="number">2</span>]=ce=col[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(i)) ans+=(ll) (c[<span class="number">0</span>]+c[<span class="number">1</span>]+c[<span class="number">2</span>])*(c[<span class="number">0</span>]+c[<span class="number">1</span>]+c[<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c[<span class="number">0</span>] &amp;&amp; c[<span class="number">1</span>] &amp;&amp; c[<span class="number">2</span>]) ans+=(ll) c[<span class="number">0</span>]*c[<span class="number">1</span>]+(ll) (c[<span class="number">0</span>]+c[<span class="number">1</span>])*c[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">else</span> ans+=ce&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>构造</tag>
        <tag>染色</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>30801202-AGC001</title>
    <url>/2021/08/03/AGC001/</url>
    <content><![CDATA[<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><blockquote>
<p>给出光源位置，求反射总距离</p>
</blockquote>
<p>考虑到 $N\leq 10^{12}$ ，找规律</p>
<p>每次看成从一个平行四边形的右下角 $(a,b)$ 向外发射</p>
<p>所以下一个平行四边形状态为：</p>
<script type="math/tex; mode=display">(a,\ b)\rightarrow

\begin{cases}

(a-b,b) &a>b \\

(a,b-a) &b>a \\

\end{cases}</script><p>显然任意 $a,b$ 为 $0$ 时终止</p>
<p>设 $f(a,b)$ 为从点 $(a,b)$ 开始的路径长度，则</p>
<script type="math/tex; mode=display">f(a,b)=\begin{cases}

2b+f(a-b,b) &a>b \\

2a+f(a,b-a) &b>a \\

a &a=b \\

\end{cases}</script><p>然而显然能找到规律，路径总长度为 $n-\gcd(n,x)$</p>
<p><del>这十分玄学，在VP的时候猜的，还不会证qwq</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll n,x;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="number">3</span>*(n-__gcd(n,x)));</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><blockquote>
<p>删除树的一些叶节点使直径 $\leq k$ 求最少删除的点数</p>
</blockquote>
<p>考虑到 $n\leq 2000$ ,所以 <del>是dp</del> 可以考虑枚举中心</p>
<p>再按 $n$ 的奇偶考虑一下中心是边还是点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e3</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],Next[N&lt;&lt;<span class="number">1</span>],ver[N&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line"><span class="keyword">int</span> n,k,ans=INT_MAX,d[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123; ver[++tot]=v,Next[tot]=head[u],head[u]=tot; ver[++tot]=u,Next[tot]=head[v],head[v]=tot;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> fa,<span class="keyword">int</span> *d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(rei i=head[now];i;i=Next[i])&#123;</span><br><span class="line">        rei y=ver[i]; <span class="keyword">if</span>(y==fa) <span class="keyword">continue</span>;</span><br><span class="line">        d[y]=d[now]+<span class="number">1</span>; <span class="built_in">dfs</span>(y,now,d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,u,v;i&lt;n;++i)&#123; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v); <span class="built_in">add</span>(u,v);&#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">dfs</span>(i,<span class="number">0</span>,d[i]);</span><br><span class="line">    <span class="keyword">if</span>(k&amp;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=tot;i+=<span class="number">2</span>)&#123;</span><br><span class="line">            rei u=ver[i],v=ver[i+<span class="number">1</span>],res=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) res+=d[u][i]&gt;k/<span class="number">2</span> &amp;&amp; d[v][i]&gt;k/<span class="number">2</span>;</span><br><span class="line">            ans=<span class="built_in">min</span>(res,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            rei res=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=n;++j) res+=d[i][j]&gt;k/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">// printf(&quot;%d\n&quot;,res);</span></span><br><span class="line">            ans=<span class="built_in">min</span>(ans,res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>给定了数列 $A$ 的重排列，构造出数列 $A,B$ ，满足 $\sum_A=\sum_B$ ，且能由两数列划分出的回文串的字符串只由同种字符构成</p>
</blockquote>
<p><del>神仙构造题</del></p>
<p>按回文的对应相等关系连边，需要将其连成一个连通块，每次连的边数为 $\sum_{i=1}\left\lfloor \frac{a_i}{2} \right\rfloor$</p>
<p>显然若有 $2$ 个以上的 $a_i$ 为奇数则无法构成连通块</p>
<p>先考虑特殊情况：当 $M=1$ 只需令 $a_1=N,b_1=1,b_2=N-1$ 即可</p>
<p>推广可得：所有奇数放在开头结尾构成 $A$,再使开头 $+1$ ,结尾 $-1$ 构造 $B$</p>
<p>可以发现这样使中间的连边错开且前后两边错开，边数恰为 $n-1$ ，构成树</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%*d%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> *a==<span class="number">1</span> ? <span class="built_in">puts</span>(<span class="string">&quot;1\n1\n1\n&quot;</span>) : <span class="built_in">printf</span>(<span class="string">&quot;%d\n2\n1 %d\n&quot;</span>,*a,*a<span class="number">-1</span>) ,<span class="number">0</span>;</span><br><span class="line">    rei mid=<span class="built_in">partition</span>(a,a+n,[](<span class="keyword">const</span> <span class="keyword">int</span> x)-&gt;<span class="keyword">bool</span>&#123; <span class="keyword">return</span> x%<span class="number">2</span>; &#125;)-a;</span><br><span class="line">    <span class="keyword">if</span>(mid&gt;<span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Impossible&quot;</span>),<span class="number">0</span>;</span><br><span class="line">    a[n]=*a;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>,a[i],i==n ? <span class="number">10</span> : <span class="number">32</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(b+<span class="number">1</span>,a+<span class="number">1</span>,n&lt;&lt;<span class="number">2</span>);</span><br><span class="line">    ++b[<span class="number">1</span>],--b[n],n-=!b[n];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>,b[i],i==n ? <span class="number">10</span> : <span class="number">32</span>);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>求 $\displaystyle{\sum_{i=1}^n\sum_{j=i+1}^n\binom{a_i+b_i+a_j+b_j}{a_i+a_j}}$</p>
</blockquote>
<p><del>在焦作一中听过</del></p>
<p>考虑几何意义，$\binom{a_i+b_i+a_j+b_j}{a_i+a_j}$ 表示从点 $(0,0) \ \Rightarrow \ (a_i+a_j,b_i+b_j)$ 的方案数，平移得 $(-a_i,-B_i) \ \Rightarrow \ (a_j,b_j)$ 的方案数，dp即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>,M=<span class="number">2100</span>,S=<span class="number">2050</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>,INV2=<span class="number">5e8</span>+<span class="number">4</span>;</span><br><span class="line">ll a[N],b[N],f[M&lt;&lt;<span class="number">1</span>][M&lt;&lt;<span class="number">1</span>],mul[M&lt;&lt;<span class="number">2</span>],inv[M&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> n; ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fix</span><span class="params">(ll &amp;x)</span></span>&#123; <span class="keyword">while</span>(x&gt;=mod) x-=mod; <span class="keyword">while</span>(x&lt;<span class="number">0</span>) x+=mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(ll x,ll y)</span></span>&#123; rei res=<span class="number">1</span>; <span class="keyword">while</span>(y)&#123; <span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=(ll) res*x%mod; x=(ll) x*x%mod; y&gt;&gt;=<span class="number">1</span>;&#125; <span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">get_inv</span><span class="params">(ll x)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">qpow</span>(x,mod<span class="number">-2</span>)%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">get_C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123; <span class="keyword">return</span> mul[n]*inv[n-m]%mod *inv[m]%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mul[<span class="number">0</span>]=<span class="number">1</span>,inv[<span class="number">0</span>]=<span class="built_in">get_inv</span>(mul[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=<span class="number">8000</span>;++i) mul[i]=mul[i<span class="number">-1</span>]*i%mod,inv[i]=<span class="built_in">get_inv</span>(mul[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a[i],&amp;b[i]),++f[ S-a[i] ][ S-b[i] ];</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=(S&lt;&lt;<span class="number">1</span>);++i) <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=(S&lt;&lt;<span class="number">1</span>);++j) <span class="built_in">fix</span>(f[i][j]+=(f[i<span class="number">-1</span>][j]+f[i][j<span class="number">-1</span>])%mod);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">fix</span>(ans+=(((f[ S+a[i] ][ S+b[i] ]-<span class="built_in">get_C</span>( (a[i]&lt;&lt;<span class="number">1</span>)+(b[i]&lt;&lt;<span class="number">1</span>),(a[i]&lt;&lt;<span class="number">1</span>))+mod)%mod)+mod)%mod);</span><br><span class="line">    <span class="built_in">fix</span>(ans*=INV2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>给定排列 $P$，当且仅当 $i,j$ 满足 $|p_i-p_j|=1$ 且 $|i-j|\geq k$ 是可以交换 $p_i$ 和 $p_j$ ，求最终字典序最小的排列</p>
</blockquote>
<p><del>又是我不会的神仙题</del></p>
<p><strong>将下标与权值交换位置，即构造序列 $q_{p_i}=i$ </strong></p>
<p>由此有很好的性质：</p>
<ul>
<li><p>变换的条件变为：当 $|q_i-q_{i+1}|\geq k$ 时交换 $q_i,q_{i+1}$ , 那么对于 $q_i$ ,$q_j\in [q_i-k+1,q_i+k-1]$ 始终在它后面</p>
</li>
<li><p>字典序最小可以转变为下标尽量小，权值尽量小，所以拓扑+贪心即可</p>
</li>
</ul>
<p>另：建图可以优化边数，用线段树维护偏序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[N&lt;&lt;<span class="number">1</span>],Next[N&lt;&lt;<span class="number">1</span>],in[N],tot;</span><br><span class="line"><span class="keyword">int</span> val[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,k,ans[N],p[N];</span><br><span class="line">priority_queue&lt;PII&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123; ver[++tot]=v,Next[tot]=head[u],head[u]=tot,++in[v];&#125;</span><br><span class="line"><span class="keyword">namespace</span> ST&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> pos,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		val[now]=<span class="built_in">min</span>(val[now],v); <span class="keyword">if</span>(l==r) <span class="keyword">return</span> ;</span><br><span class="line">		rei mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(pos&lt;=mid) <span class="keyword">return</span> <span class="built_in">change</span>(now&lt;&lt;<span class="number">1</span>,l,mid,pos,v);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">change</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,pos,v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(L&gt;R) <span class="keyword">return</span> INF;</span><br><span class="line">		<span class="keyword">if</span>(L&lt;=l &amp;&amp; r&lt;=R) <span class="keyword">return</span> val[now];</span><br><span class="line">		rei res=INF,mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(L&lt;=mid) res=<span class="built_in">min</span>(res,<span class="built_in">query</span>(now&lt;&lt;<span class="number">1</span>,l,mid,L,R));</span><br><span class="line">		<span class="keyword">if</span>(R&gt;mid) res=<span class="built_in">min</span>(res,<span class="built_in">query</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,L,R));</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(val,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> val);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>,x;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x),p[x]=i;</span><br><span class="line">	<span class="keyword">for</span>(rei x=n,y;x;--x)&#123;</span><br><span class="line">		y=ST::<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,<span class="built_in">max</span>(p[x]-k+<span class="number">1</span>,<span class="number">1</span>),p[x]<span class="number">-1</span>); <span class="keyword">if</span>(y!=INF) <span class="built_in">add</span>(x,y);</span><br><span class="line">		y=ST::<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,p[x]+<span class="number">1</span>,<span class="built_in">min</span>(p[x]+k<span class="number">-1</span>,n)); <span class="keyword">if</span>(y!=INF) <span class="built_in">add</span>(x,y);</span><br><span class="line">		ST::<span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,p[x],x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>(!in[i]) q.<span class="built_in">push</span>(<span class="built_in">mk</span>(-p[i],i));</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">		rei x=q.<span class="built_in">top</span>().second; q.<span class="built_in">pop</span>();</span><br><span class="line">		++m; ans[ p[x] ]=m;</span><br><span class="line">		<span class="keyword">for</span>(rei i=head[x];i;i=Next[i])&#123;</span><br><span class="line">			rei y=ver[i]; <span class="keyword">if</span>(--in[y]==<span class="number">0</span>) q.<span class="built_in">push</span>(<span class="built_in">mk</span>(-p[y],y));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>构造</tag>
        <tag>dp</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>70801202-AGC005</title>
    <url>/2021/08/07/AGC005/</url>
    <content><![CDATA[<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>求数列 $A$ 的合法排列数满足 $\forall i\in(1,n) |p_i-i|\not =k$</p>
</blockquote>
<p>考虑到 $\not =$ 并不容易计算，使用容斥转化为 $=$</p>
<p>设 $\Gamma_c$ 表示包含已知的 $c对=$ 的排列数量(其他位置任意)，而其他位置任意本质上就是全排列，即，对 $\Gamma_c$ 的贡献是 $(N-c)!$ 。 由此，根据广义容斥，最终答案为 $\displaystyle{\sum_{c=0}^N (-1)^c \times \Gamma_c}$</p>
<p>转化问题为<strong>能选出多少对 $(i,a_i)$ 使 $|a_i-i|=K$ 且所有的 $i,a_i$ 分别互不相同</strong> ，设选出 $\gamma_c$ ，则 $\Gamma_c=\gamma_c \times (N-c)!$</p>
<p>则最终答案是</p>
<script type="math/tex; mode=display">\sum_{c=0}^N (-1)^c\times (N-c)! \times \gamma_c</script><p>注意这里<strong>下标与键值的对应关系</strong>，像匹配的定义，且可以将其转化成二分图模型：$G=(V_1,V_2 ; E)$，其中 $V_1={L_1,L_2,…,L_N} \ ,\ V_2={R_1,R_2,…,R_N} \ ,\ E={(L_i,R_j)\mid \ |i-j|=k}$ ，求 $E$ 有多少个 $K$ 的匹配</p>
<p>再考虑图 $G$ 的性质：</p>
<ul>
<li>每个顶点度数不超过 $2$ ——因为 $L_i$ 至多与 $R_{i-k},R_{i+k}$ 相连，对 $R_i$ 同理</li>
<li>$G$ 为若干个链的并——证明没有圈：若有圈，则设最小者 $\min$ , 顶点式 $L_{\min}$ ，与之相连的节点 $L_{\min-k}$ 则不能在圈中，则度数不超过 $1$ ,与性质 $1$ 矛盾</li>
</ul>
<p>所以求一个全由链组成的图 $G$ ，其大小为 $k$ 的匹配个数</p>
<p>考虑将这些链首尾相连，而连边则为<strong>强制不能加入匹配</strong>的坏边</p>
<p>问题转化到了链，$f_{i,j}$ 表示前 $i$ 条边，当前匹配大小为 $j$ ，且最后一条边没有匹配的方案数； $g_{i,j}$ 表示最后一条边匹配的方案数，转移时注意坏边以及相邻的边不能同时出现在匹配中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">4e3</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">924844033</span>;</span><br><span class="line"><span class="keyword">int</span> n,k,len;</span><br><span class="line"><span class="keyword">int</span> sp[N],fac[N],f[N][N],g[N][N];</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">const</span> <span class="keyword">int</span> y)</span></span>&#123; x+=y-mod; x+=x&gt;&gt;<span class="number">31</span>&amp;mod;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k); fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) fac[i]=(ll) fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;k;++i)&#123;</span><br><span class="line">        sp[++len]=<span class="number">1</span>,len+=(n-i<span class="number">-1</span>)/k;</span><br><span class="line">        sp[++len]=<span class="number">1</span>,len+=(n-i<span class="number">-1</span>)/k;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=len;++i)&#123;</span><br><span class="line">        f[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=(i+<span class="number">1</span>)/<span class="number">2</span>;++j)&#123;</span><br><span class="line">            <span class="built_in">add</span>(f[i][j]=f[i<span class="number">-1</span>][j],g[i<span class="number">-1</span>][j]);</span><br><span class="line">            g[i][j]=sp[i] ? <span class="number">0</span> : f[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei c=<span class="number">0</span>;c&lt;=n;++c)&#123;</span><br><span class="line">        rei tmp=(ll) (f[len][c]+g[len][c])%mod*fac[n-c]%mod;</span><br><span class="line">        c&amp;<span class="number">1</span> ? ans-=tmp : ans+=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    ans%=mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans+(ans&gt;&gt;<span class="number">63</span>&amp;mod));</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>给定红蓝两棵树和起点，两人分别在两棵树上交替移动，相遇后（所在节点编号相同）游戏结束，现在 $A（红）$ 想最大化游戏轮数，$B（蓝）$ 想最小化游戏轮数，求游戏轮数</p>
</blockquote>
<p><del>对抗搜索！（雾</del></p>
<p>首先考虑无解情况，即后手永远抓不到先手</p>
<p>如果存在一条红边 $(u,v)$ 且满足 $u,v$ 两点在蓝树上的距离 $\geq 3$ ，且先手能跑到 $u,v$ 点中任意一个 且 该回合内没有被抓到，则无解</p>
<p>先假设有解情况，即，先手可以走的红边的两端点在蓝树上距离 $\leq 2$ ，那么对于点 $u$ ，其与根的距离分别为 $len_红,len_蓝$ ，若 $len_红\leq len_蓝$ 那么红方一定不会走到 $u$ ， 即红方每一次移动都要保证 $len_红&gt;len_蓝$</p>
<p>$\therefore$ $\text{dfs}$ 一次找无解与满足 $len_红&gt;len_蓝$ 的点，答案就是 $2\times \max len_红$ ，即最优决策是走到 $\max len_红$ 并原地等待</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="keyword">int</span> next=<span class="number">0</span>,<span class="keyword">int</span> to=<span class="number">0</span>):<span class="built_in">next</span>(next),<span class="built_in">to</span>(to)&#123;&#125;;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> ha[N],hb[N],tot;</span><br><span class="line"><span class="keyword">int</span> fa[N],hson[N],Size[N],top[N],depth[N];</span><br><span class="line"><span class="keyword">int</span> ans,cir,n,a,b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _add(<span class="keyword">int</span> *head,<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123; edge[++tot]=<span class="built_in">Edge</span>(head[x],y);head[x]=tot;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> *head,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123; _add(head,x,y); _add(head,y,x);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    Size[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=hb[x];i;i=edge[i].next)&#123;</span><br><span class="line">        rei y=edge[i].to; <span class="keyword">if</span>(y==fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">        depth[y]=depth[x]+<span class="number">1</span>,fa[y]=x; <span class="built_in">dfs1</span>(y),</span><br><span class="line">        Size[x]+=Size[y],hson[x]=Size[ hson[x] ]&gt;Size[y] ? hson[x] : y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(depth[ top[x] ]&lt;depth[ top[y] ]) x^=y,y^=x,x^=y;</span><br><span class="line">        x=fa[ top[x] ];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth[x]&lt;depth[y] ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">return</span> depth[x]+depth[y]<span class="number">-2</span>*depth[ <span class="built_in">lca</span>(x,y) ];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> anc)</span></span>&#123;</span><br><span class="line">    top[x]=anc;</span><br><span class="line">    <span class="keyword">if</span>(hson[x]) <span class="built_in">dfs2</span>(hson[x],anc);</span><br><span class="line">    <span class="keyword">for</span>(rei i=hb[x];i;i=edge[i].next)&#123;</span><br><span class="line">        rei y=edge[i].to; <span class="keyword">if</span>(y!=fa[x] &amp;&amp; y!=hson[x]) <span class="built_in">dfs2</span>(y,y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">escape</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa,<span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line">    ans=<span class="built_in">max</span>(ans,depth[x]&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(rei i=ha[x];i;i=edge[i].next)&#123;</span><br><span class="line">        rei y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dis</span>(x,y)&gt;<span class="number">2</span>) cir=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(y==fa || dep+<span class="number">1</span>&gt;=depth[y]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">escape</span>(y,x,dep+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;a,&amp;b);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,x,y;i&lt;n;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y),<span class="built_in">add</span>(ha,x,y);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,x,y;i&lt;n;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y),<span class="built_in">add</span>(hb,x,y);</span><br><span class="line">    <span class="built_in">dfs1</span>(b);<span class="built_in">dfs2</span>(b,b);</span><br><span class="line">    <span class="built_in">escape</span>(a,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cir ? <span class="number">-1</span> : ans);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>对于一颗树 $T=(V,E)$ ，对于非空子集 $S\subseteq V$ ， 定义 $f(S)$ 表示包含 $S$ 中所有点的连通块大小的最小值，即，$f(S)=min{|U| \ \mid s\subseteq U\subseteq V,T |U|是连通图}$ ，对 $K:1\rightarrow n$ 分别求出 $\sum_{S\subseteq V,|S|=K} f(S)$ 的值</p>
</blockquote>
<p>考虑每个点 $x$ 对答案的贡献，即总方案数减去不合法方案数</p>
<script type="math/tex; mode=display">\begin{aligned}
f_i&=\sum_{x=1}^n\left(\binom{n}{i}-\sum_{\exists e(x,y)}\binom{size_y}{i} \right) \\
&=n\times \binom{n}{i} - \sum_{x=1}^m\times \sum_{\exists e(x,y)} \binom{size_y}{i} \\
\end{aligned}</script><p>设 $cnt_i$ 为子树大小为 $i$ 的子树个数</p>
<script type="math/tex; mode=display">
\begin{aligned}
f_i&=n\times \binom{n}{i}-\sum_{j=i}^n cnt_j\times \binom{j}{i} \\
&=n\times \binom{n}{i}-\sum_{j=i}^n cnt_j\times \frac{j!}{i!\times (j-i)!} \\
&=n\times \binom{n}{i}-\frac{1}{i!}\sum_{j=i}^n\frac{cnt_j\times j!}{(j-i)!} \\
&=n\times \binom{n}{i}-\frac{1}{i!} \sum_{j=0}^{n-i}\frac{cnt_{i+j}\times (i+j)!}{j!} \\
\end{aligned}</script><p>发现第二项是减法卷积，考虑 $NTT$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">8e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">924844033</span>,G=<span class="number">5</span>;</span><br><span class="line">ll n;</span><br><span class="line">ll rev[N],f[N],g[N],fac[N],ifac[N],Size[N],cnt[N];</span><br><span class="line"><span class="keyword">int</span> head[N],tot,Next[N&lt;&lt;<span class="number">1</span>],ver[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123; ver[++tot]=v,Next[tot]=head[u],head[u]=tot;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">qpow</span><span class="params">(ll x,ll y)</span></span>&#123; ll v=<span class="number">1</span>; <span class="keyword">while</span>(y)&#123; <span class="keyword">if</span>(y&amp;<span class="number">1</span>) v=v*x%mod; x=x*x%mod,y&gt;&gt;=<span class="number">1</span>;&#125; <span class="keyword">return</span> v;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    rei lim=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(lim&lt;=n) lim&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;lim;++i) rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>) | ((i&amp;<span class="number">1</span>) ? lim&gt;&gt;<span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> lim;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(ll *a,<span class="keyword">int</span> lim,<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;lim;++i) <span class="keyword">if</span>(i&lt;rev[i]) <span class="built_in">swap</span>(a[i],a[ rev[i] ]);</span><br><span class="line">    <span class="keyword">for</span>(rei len=<span class="number">1</span>;len&lt;lim;len&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        ll wn=<span class="built_in">qpow</span>(G,(mod<span class="number">-1</span>)/(len&lt;&lt;<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;lim;i+=len&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line">            ll w=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(rei j=i;j&lt;i+len;++j,w=w*wn%mod)&#123;</span><br><span class="line">                ll x=a[j],y=w*a[j+len]%mod;</span><br><span class="line">                a[j]=(x+y)%mod,a[j+len]=(x-y+mod)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(type==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    ll inv=<span class="built_in">qpow</span>(lim,mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;lim;++i) a[i]=a[i]*inv%mod;</span><br><span class="line">    <span class="built_in">reverse</span>(a+<span class="number">1</span>,a+lim);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">mul</span><span class="params">(ll *f,ll *g)</span></span>&#123;</span><br><span class="line">    rei lim=<span class="built_in">calc</span>(n&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">NTT</span>(f,lim,<span class="number">1</span>),<span class="built_in">NTT</span>(g,lim,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;lim;++i) f[i]=f[i]*g[i]%mod;</span><br><span class="line">    <span class="built_in">NTT</span>(f,lim,<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    Size[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=head[x];i;i=Next[i])&#123;</span><br><span class="line">        rei y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x),Size[x]+=Size[y];</span><br><span class="line">    &#125;</span><br><span class="line">    ++cnt[ Size[x] ],++cnt[ n-Size[x] ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">get_C</span><span class="params">(ll n,ll m)</span></span>&#123; <span class="keyword">return</span> fac[n]*ifac[m]%mod *ifac[n-m]%mod;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=ifac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    ifac[n]=<span class="built_in">qpow</span>(fac[n],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(rei i=n<span class="number">-1</span>;i;--i) ifac[i]=ifac[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,x,y;i&lt;n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y),<span class="built_in">add</span>(x,y),<span class="built_in">add</span>(y,x);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    g[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) f[i]=cnt[n-i]*fac[n-i]%mod,g[i]=ifac[i];</span><br><span class="line">    <span class="built_in">mul</span>(f,g),<span class="built_in">reverse</span>(f,f+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(n*<span class="built_in">get_C</span>(n,i)%mod-ifac[i]*f[i]%mod+mod)%mod);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>构造</tag>
        <tag>dp</tag>
        <tag>博弈论</tag>
        <tag>多项式</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>01801202-AGC007</title>
    <url>/2021/08/10/AGC007/</url>
    <content><![CDATA[<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><blockquote>
<p>一条直线上有 $N$ 个球， $N+1$ 个洞，每个球与相邻的洞距离 $d_i \ (1\leq i\leq N\times 2)$ 。随机选择一个球并向随机方向推，若洞中有球则继续滚，无球掉入。求每个球移动距离的期望</p>
</blockquote>
<p>这个阴间题有一下结论：第一个球滚入洞中后，新的距离序列的期望值仍是一个等差数列</p>
<ul>
<li><p>题解的证明：</p>
<p>共 $2\times n$ 中可能，对于第 $i$ 段，考虑能对其期望长度做出贡献的行为</p>
<ul>
<li>原第 $i$ 段距离被滚过，重新编号后原第 $i+2$ 段成为现第 $i$ 段</li>
<li>原第 $i+1$ 段被滚过，原第 $i,i+2,i+3$ 段成为第 $i$ 段</li>
</ul>
<script type="math/tex; mode=display">\therefore d_i'=d_i+\frac{i\times (d_{i+2}-d_i)+(d_{i+2}+d_{i+3})}{2\times n}=d_i+\frac{i\times 2x+2\times d+5\times x}{2\times n}</script></li>
<li><p>口胡找规律的证明</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/dqj6ou7i.png" alt="https://cdn.luogu.com.cn/upload/image_hosting/dqj6ou7i.png"></p>
<p>$4$ 个距离的期望分别是 $\frac{8\times d+5\times x}{6} \quad \frac{8\times d+15\times x}{6} \quad \frac{8\times d+25\times x}{6} \quad \frac{8\times d+35\times x}{6}$</p>
<p>然后手推一推找规律得：$d’_1=d+\frac{2\times d+5\times x}{2\times n},x’=x+\frac{4\times x}{2\times n}$</p>
<p>最后对于期望距离是 $d+\frac{2\times n-1}{2\times x}$ ，即，数列的中位数</p>
</li>
</ul>
<p>$\therefore O(n)$ 递推数列即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> d,k,ans,n2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%lf%lf&quot;</span>,&amp;n,&amp;d,&amp;k);</span><br><span class="line">    n2=n&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=n;i;--i)&#123;</span><br><span class="line">        ans+=d+k*(n2<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">        d+=(<span class="number">2</span>*d+<span class="number">5</span>*k)/n2;</span><br><span class="line">        k+=<span class="number">4</span>*k/n2;</span><br><span class="line">        n2-=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.10lf\n&quot;</span>,ans);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>数列上有 $n$ 只位于 $x_i$ 熊，到达该熊位置后 $T$ 秒会在该熊的位置生成一个金币，从 $0$ 开始走，每走以一单位长度需要 $1$ 秒，求收集所有金币并到出口的最短时间</p>
</blockquote>
<p><del>经典C比D难</del></p>
<p>显然有 $dp$ 式子：</p>
<script type="math/tex; mode=display">f_i=\min_{j\leq i}\{f_{j}+a_i-a_j+\underbrace{\max\{2\times (a_i-a_{j+1}),T\}}_{返回又回到i后，若时间不够需要在原地等} \}</script><p>考虑优化这个 $O(n^2)$ 的式子</p>
<p>首先注意 $\sum a_i-a_j=lenth$ ，所以提出这个式子并在结果中加上数列总长</p>
<p>其次处理 $\max$ :对于 $(a_i-a_{j+1})$ 的大小分类讨论，其大小随 $a_i$ 单增，维护队列，当 $(a_i-a_{j+1})\leq \frac{T}{2}$ 留在队列中，队首转移时所有弹出的 $j$ 满足 $(a_i-a_{j+1})&gt;T$ ，记录最小值即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line">ll n,T,x[N],f[N],ans,k=<span class="number">1e18</span>;</span><br><span class="line">ll head=<span class="number">1</span>,tail=<span class="number">1</span>,sta[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld%d&quot;</span>,&amp;n,&amp;ans,&amp;T);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x[i]);</span><br><span class="line">	f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;=tail &amp;&amp; (x[i]-x[ sta[head] ]+<span class="number">1</span>)&gt;(T&gt;&gt;<span class="number">1</span>))&#123;</span><br><span class="line">            k=<span class="built_in">min</span>(k,f[ sta[head] ]<span class="number">-2</span>*x[ sta[head]+<span class="number">1</span> ]);</span><br><span class="line">            ++head;</span><br><span class="line">        &#125;</span><br><span class="line">        f[i]=<span class="built_in">min</span>(f[i],<span class="built_in">min</span>(f[ sta[head] ]+T,k+<span class="number">2</span>*x[i]));</span><br><span class="line">        sta[++tail]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    ans+=f[n];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>给定一个严格二叉树，每条边有边权，找到一条 $\text{Euler}$ 环游路径(从根出发并回到根，期间每条边的两个方向恰被经过一次)，设该路径经过的叶节点按顺序依次为 $l_1,l_2,….$ ,最小化 $\max\{dis(l_1,l_2),dis(l_2,l_3),…,dis(l_{n-1},l_n)\}$</p>
</blockquote>
<p><strong>最小化最大值，自然想到二分答案，转化为判定性问题</strong></p>
<p>二分答案为 $mid$ ，设二元组 $(a,b)_x$ 表示 $x$ 子树下第一次走的代价为 $a$ ,在最后一次走的代价为 $b$ ，中间过程都 $\leq mid$</p>
<p>可以得到暴力做法：枚举当前点左右儿子的二元组 $(a,b)_{ls},(c,d)_{rs}$ ，左儿子边权为 $x$ ，右儿子边权 $y$ ，若满足 $b+c+x+y\leq mid$ ，则能得到一个新二元组 $(a+x,d+y)_x$</p>
<p>考虑优化：</p>
<p>对于两个有序对 $(a,b),(c,d)$ 若 $a\leq d 或 b\leq c$ ，即前者偏序与后者，显然前者优于后者</p>
<p>那么只保留优等情况后， $a,b$ 是反向单调的，即， $a<c \Leftrightarrow b>d$</p>
<p>对于 $(a,b) 和 (c,d)$ 的合并，假设固定 $b$ ，那么需要找 $c$ 满足 $d\leq v-b$</p>
<p>显然希望剩下的 $d$ 尽可能小，有反向单调性可知，需要找尽可能大的 $c$</p>
<p>可以按照单增的顺序枚举 $b$ ，所需的 $c$ 的上界则单减，双指针扫即可</p>
<p>再考虑顶点 $i$ 的所有状态，注意到两子节点可交换，即要同时插入 $(l,r) , (r,l)$</p>
<p>这里并不需要再次排序，由枚举的单调性可知内部有序，只需进行一次有序表合并</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">14e4</span>+<span class="number">100</span>,M=<span class="number">5e5</span>;</span><br><span class="line"><span class="keyword">int</span> n,fa[N],lc[N],rc[N];</span><br><span class="line">ll depth[N];</span><br><span class="line">PLL g[M],h[M],tmp[M];</span><br><span class="line">vector &lt;PLL&gt; f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123; (lc[fa] ? rc[fa] : lc[fa])=x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">valid</span><span class="params">(ll v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(rei x=n;x;--x)&#123;</span><br><span class="line">        f[x].<span class="built_in">clear</span>(); rei l=lc[x],r=rc[x];</span><br><span class="line">        <span class="keyword">if</span>(!(l || r))&#123; f[x].<span class="built_in">emplace_back</span>(depth[x],depth[x]); <span class="keyword">continue</span>;&#125;</span><br><span class="line">        rei L=f[l].<span class="built_in">size</span>(),R=f[r].<span class="built_in">size</span>(),cg,ch,i,j;</span><br><span class="line">        ll lim=v+<span class="number">2</span>*depth[x];</span><br><span class="line">        <span class="keyword">for</span>(cg=ch=j=i=<span class="number">0</span>;i&lt;L;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(;j&lt;R &amp;&amp; f[l][i].first+f[r][j].second&gt;lim;++j);</span><br><span class="line">            <span class="keyword">if</span>(j==R) <span class="keyword">break</span>;</span><br><span class="line">            g[cg++]=<span class="built_in">mk</span>(f[l][i].second,f[r][j].first);</span><br><span class="line">            h[ch++]=<span class="built_in">mk</span>(f[r][j].first,f[l][i].second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(g,g+cg),j=<span class="built_in">merge</span>(g,g+cg,h,h+ch,tmp)-tmp;</span><br><span class="line">        <span class="keyword">if</span>(!j) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(f[x].<span class="built_in">emplace_back</span>(*tmp),i=<span class="number">1</span>;i&lt;j;++i)</span><br><span class="line">            <span class="keyword">if</span>(tmp[i].second&lt;f[x].<span class="built_in">back</span>().second) f[x].<span class="built_in">emplace_back</span>(tmp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll l=<span class="number">0</span>,r=<span class="number">0</span>,mid;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>,&amp;fa[i],&amp;depth[i]),<span class="built_in">link</span>(i,fa[i]),r+=depth[i],depth[i]+=depth[ fa[i] ];</span><br><span class="line">    <span class="keyword">for</span>(;l&lt;r;<span class="built_in">valid</span>(mid=(l+r)/<span class="number">2</span>) ? r=mid : l=mid+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,l);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>给定初始串 $S_0$ 与目标串 $T$ ，第 $i$ 步将 $S_i$ 变为 $S_{i+1}$ ，其中：</p>
<script type="math/tex; mode=display">S_{i+1}[j]=\begin{cases}S_i[1] &j=1 \\S_i[j] 或 S_{i+1}[j-1] &j>1 \\\end{cases}</script><p>求最少几次操作可以变为目标串</p>
</blockquote>
<p>考虑到 $T$ 中的每个字符来源于 $S_0$ ，有对应关系的边不会相交，且一个字符对应一个区间</p>
<p>可以采取的最优策略是：先尽量右移，移动到需要覆盖的左边界处后向下到底线，再横向覆盖，让路径尽量靠右</p>
<p>再考虑最优补数：从后往前考虑每个 $T$ 中须要匹配的左端点，让路径尽量靠右，若当前层数无法完成，则加一层</p>
<p>具体地，用队列维护上一条路径所有右侧转折点，其横纵坐标单增</p>
<p>当 $S_i\rightarrow T_j$ ，末端弹出所有横坐标在 $j$ 后面的所有转折点</p>
<p>答案是所有转折点纵坐标的最大值 $+1$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">char</span> s[N],t[N];</span><br><span class="line"><span class="keyword">int</span> n,pre[N],p[<span class="number">255</span>],ans,ql,qr;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span>&#123;</span><span class="keyword">int</span> i,j;&#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s%s&quot;</span>,&amp;n,s+<span class="number">1</span>,t+<span class="number">1</span>); <span class="keyword">bool</span> flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>(s[i]!=t[i]) flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>),<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) pre[i]=p[ s[i] ],p[ s[i] ]=i;</span><br><span class="line">    rei ql=<span class="number">1</span>,qr=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=n,las=n+<span class="number">1</span>,c=<span class="number">0</span>;i;--i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[i]==t[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span>(p[ t[i] ]&gt;<span class="built_in">min</span>(las,i)) p[ t[i] ]=pre[ p[ t[i] ] ];</span><br><span class="line">        <span class="keyword">if</span>(!p[ t[i] ]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>),<span class="number">0</span>;</span><br><span class="line">        rei u=p[ t[i] ],v=i;</span><br><span class="line">        <span class="keyword">while</span>(ql&lt;=qr &amp;&amp; v&lt;q[ql].i-c+<span class="number">1</span>) ++ql;</span><br><span class="line">        <span class="keyword">if</span>(las!=u &amp;&amp; u&lt;v) q[++qr]=((Data)&#123;u+c,<span class="number">1</span>-c&#125;);</span><br><span class="line">        <span class="keyword">if</span>(ql&lt;=qr) ans=<span class="built_in">max</span>(ans,q[ql].j+c);</span><br><span class="line">        ++c;las=u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>构造</tag>
        <tag>dp</tag>
        <tag>贪心</tag>
        <tag>数列</tag>
      </tags>
  </entry>
  <entry>
    <title>11801202-AGC008</title>
    <url>/2021/08/11/AGC008/</url>
    <content><![CDATA[<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>给定长度为 $n$ 的序列 $a$ ，求有多少长度为 $n$ 的排列 $p$ 满足 $\forall i : p_i=a_i 或 p_{p_i}=a_i$</p>
</blockquote>
<p>对于排列 $p$ ，将 $i$ 向 $p_i$ 连边，显然每个点入度出度都为 $1$ ，即，形成了若干个环</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/z22bnrwt.png" alt="https://cdn.luogu.com.cn/upload/image_hosting/z22bnrwt.png"></p>
<p>对于其中的一个环：删除所有边并将 $i\rightarrow a_i$ ，由题得 $a_i$ 是其前面的点( $p_i=a_i$ )或前面的前面的点( $p_{p_i}=a_i$ )</p>
<p>分成 $3$ ( $4$ )种：</p>
<ul>
<li>所有 $i$ 的 $a_i$ 都是其前面的点，则环不变</li>
<li><p>所有 $i$ 的 $a_i$ 都是其前面的前面的点</p>
<ul>
<li>环是奇环，则环变成同构的另一环<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/bw5esa22.png" alt="https://cdn.luogu.com.cn/upload/image_hosting/bw5esa22.png"><br>-环是偶环，则环被平均拆成两大小相同的环<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/fd4lyhjw.png" alt="https://cdn.luogu.com.cn/upload/image_hosting/fd4lyhjw.png"></li>
</ul>
</li>
<li><p>有的是前面的点，有的是前面的前面，则构成基环内向树<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/zjpns0w4.png" alt="https://cdn.luogu.com.cn/upload/image_hosting/zjpns0w4.png"></p>
</li>
</ul>
<p>现在有 $a$ 构成的图，反向考虑</p>
<ul>
<li><p>对于环</p>
<p>记录每个大小的环的个数，单独考虑每种大小， $\text{dp}$ 决策第 $k$ 个环合并还是单独组成，最后乘法原理</p>
</li>
<li><p>对基环内向树</p>
<p>考虑两条相邻的链，试图将链塞回环里，该链可以塞到树里的位置就是到下一个链的边，设 $l_2$ 条这样的边， $l_1$ 是该链长度</p>
<script type="math/tex; mode=display">\begin{cases}
l_2<l_1 &ans=0 \\
l_2=l_1 &ans=1 \\
l_2>l_1 &ans=2 \\
\end{cases}</script></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,ans;</span><br><span class="line"><span class="keyword">int</span> a[N],du[N],cir[N],vis[N],chain_len[N],sum[N],f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fix</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123; x&gt;=mod ? x-=mod : <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deal_cirtree</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> now=<span class="number">0</span>,fir_ch=<span class="number">0</span>,la_ch=<span class="number">0</span>,fir_len=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//从x走环到的点，第一个链，上一个链，链长度</span></span><br><span class="line">	<span class="keyword">while</span>(cir[x])&#123;</span><br><span class="line">		++now,cir[x]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(chain_len[x])&#123;</span><br><span class="line">			<span class="keyword">if</span>(!fir_ch) la_ch=fir_ch=now,fir_len=chain_len[x];</span><br><span class="line">			<span class="keyword">else</span>&#123;<span class="comment">//尝试把链塞回环里</span></span><br><span class="line">				<span class="keyword">int</span> kl=(chain_len[x]&lt;now-la_ch)+(chain_len[x]&lt;=now-la_ch);</span><br><span class="line">				ans=(ll) ans*kl%mod,la_ch=now;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		x=a[x];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!fir_ch) ++sum[now];<span class="comment">//简单环</span></span><br><span class="line">	<span class="keyword">else</span>&#123;<span class="comment">//第一个链</span></span><br><span class="line">		<span class="keyword">int</span> kl=(fir_len&lt;now-la_ch+fir_ch)+(fir_len&lt;=now-la_ch+fir_ch);</span><br><span class="line">		ans=(ll) ans*kl%mod;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(du[i]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">int</span> x=i,len=<span class="number">0</span>; <span class="keyword">while</span>(!cir[x]) x=a[x],++len;</span><br><span class="line">		chain_len[x]=len;</span><br><span class="line">	&#125;</span><br><span class="line">	ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>(cir[i]) <span class="built_in">deal_cirtree</span>(i);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;<span class="comment">//对每一种长度的简单环DP</span></span><br><span class="line">		<span class="keyword">if</span>(!sum[i]) <span class="keyword">continue</span>;</span><br><span class="line">		f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=sum[i];++j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i&gt;<span class="number">1</span> &amp;&amp; (i&amp;<span class="number">1</span>)) <span class="built_in">fix</span>(f[j]=f[j<span class="number">-1</span>]+f[j<span class="number">-1</span>]);<span class="comment">//情况1,2</span></span><br><span class="line">			<span class="keyword">else</span> f[j]=f[j<span class="number">-1</span>];<span class="comment">//情况1</span></span><br><span class="line">			<span class="keyword">if</span>(j&gt;<span class="number">1</span>) <span class="built_in">fix</span>(f[j]+=(ll) f[j<span class="number">-2</span>]*(j<span class="number">-1</span>)%mod*i%mod);<span class="comment">//情况3</span></span><br><span class="line">		&#125;</span><br><span class="line">		ans=(ll) ans*f[sum[i]]%mod;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]),++du[ a[i] ];</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">        rei x=i; <span class="keyword">while</span>(!vis[x]) vis[x]=i,x=a[x];</span><br><span class="line">		<span class="keyword">if</span>(vis[x]!=i) <span class="keyword">continue</span>;<span class="comment">//说明i在链上</span></span><br><span class="line">		<span class="keyword">while</span>(!cir[x]) cir[x]=<span class="number">1</span>,x=a[x];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>((cir[i] &amp;&amp; du[i]&gt;<span class="number">2</span>) || (!cir[i] &amp;&amp; du[i]&gt;<span class="number">1</span>)) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>),<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">work</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>给定 $n$ 个点的树，每条边长度为 $1$ 给定 $S$ 表示喜欢的顶点集合，起初所有点为白色，可以做一次操作，其中选择顶v点 $\in S$ 和整数 $d$ 将所有满足 $dis(v,u)\leq d$ 的点 $u$ 染成黑色，求最终能得到多少形态不同的树</p>
</blockquote>
<p>先考虑 $S$ 为全集，即每个点都能以其自身为中心操作，那么最终黑色的点形成一个连通块</p>
<p>注意到不同操作方案可能得出同一种连通块，即，这并不是一一对应的</p>
<p>考虑到操作有一定距离且连通块是树，考虑取直径中点，即，对于每个连通块，看成以其中心为操作中心的操作，同时得到尽可能小的 $d$</p>
<p>当中心是边时，显然一侧为子树，规定以该边靠近叶子的点作为操作中心</p>
<p>而对于整棵树并不计入，仅在最后将答案 $+1$</p>
<p>对于每个顶点 $v$ ，考虑以其为操作中心的操作个数，对于全集 $S$ ，一定有 $d\in [0,sup]$</p>
<p>而对 $d$ 的约束有：</p>
<ul>
<li>$d&lt;f_v$ ，即， $d$ 小于整棵树的深度，以防整棵树被染黑</li>
<li>$d\leq g_v-1$ ，即，$d$ 小于以 $child(v)$ 中点为根的所有子树中第二大深度为 $g_v$ 的 ： 即考虑 $v$ 不是中心的情况，若中心在某子树中，朝根方向走，黑色点的最大深度严格递减，即 $\forall c\in child(v)$ 必须有 $\{u\mid dis(c,u)\leq d-1\}\not =\{u\mid (v,u)\leq d\}$ ，即，至少需要两颗子树存在深度 $\geq d-1$ 的顶点</li>
</ul>
<p>即，$d\leq \min(f_v-1,g_v+1)$ ，对于其余的 $v$ ，换根 $\text{dp}$ 即可</p>
<p>再考虑 $S$ 不是全集，此时 $d$ 要考虑下界</p>
<p>以 $v$ 为操作中心的一些操作可以被 以 $u\in child(v)$ 为中心的操作 $(u,d’)$ 代替，则 $d’\geq d+dis(v,u)&gt;d$</p>
<p>则，子树 $subtree(u)$ 中不能存在深度 $\geq d$ 的顶点，即，操作 $(v,d)$ 至少覆盖了它的一个子节点的子树 $subtree(u)$</p>
<p>这说明 $d$ 至少大于其所有子树中深度最大值的最小值，且保证子树中至少有一个 $S$ 中的点，否则 $v$ 不存在</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[N&lt;&lt;<span class="number">1</span>],Next[N&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line"><span class="keyword">int</span> fa[N],Size[N],f[N],g[N],inf[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line">ll ans=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">const</span> <span class="keyword">int</span> y)</span></span>&#123; x&lt;y ? x=y : <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">const</span> <span class="keyword">int</span> y)</span></span>&#123; x&gt;y ? x=y : <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123; ver[++tot]=v,Next[tot]=head[u],head[u]=tot;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	Size[x]=s[x]&amp;=<span class="number">1</span>;</span><br><span class="line">	inf[x]=(s[x]<span class="number">-1</span>)&amp;INT_MAX;</span><br><span class="line">	<span class="keyword">for</span>(rei i=head[x];i;i=Next[i])&#123;</span><br><span class="line">		rei y=ver[i]; <span class="keyword">if</span>(y==fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">		fa[y]=x; <span class="built_in">dfs1</span>(y); Size[x]+=Size[y];</span><br><span class="line">		f[x]&lt;=f[y] ? (g[x]=f[x],f[x]=f[y]+<span class="number">1</span>) : (<span class="built_in">up</span>(g[x],f[y]+<span class="number">1</span>),<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(Size[y]) <span class="built_in">down</span>(inf[x],f[y]+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fy=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">	rei sup;</span><br><span class="line">	f[x]&lt;=fy ? (g[x]=f[x],f[x]=fy+<span class="number">1</span>) : (<span class="built_in">up</span>(g[x],fy+<span class="number">1</span>),<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(Size[x]&lt;Size[<span class="number">1</span>]) <span class="built_in">down</span>(inf[x],fy+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(inf[x]&lt;=(sup=<span class="built_in">min</span>(f[x]<span class="number">-1</span>,g[x]+<span class="number">1</span>))) ans+=sup-inf[x]+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=head[x];i;i=Next[i])&#123;</span><br><span class="line">		rei y=ver[i]; <span class="keyword">if</span>(fa[y]!=x) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs2</span>(y,f[y]+<span class="number">1</span>==f[x] ? g[x] : f[x]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>,u,v;i&lt;n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v),<span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">dfs1</span>(<span class="number">1</span>),<span class="built_in">dfs2</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>构造</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>21801202-AGC009</title>
    <url>/2021/08/12/AGC009/</url>
    <content><![CDATA[<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>给定一棵树 $T$ ，递归定义一棵树是否为 $k$ -可点分的：$1$ : 包含一个顶点的树是 $0$ -可点分，$2$ :若存在顶点 $v\in T$ ，满足将 $v$ 删去后所有子树均为 $k$ -可点分的，则 $T$ 为 $(k+1)$ -可点分，求最小的 $k$ 使 $T$ 是 $k$ -可点分的</p>
</blockquote>
<p>设每个点在点分治树种深度 $k_i$ ，对于任意两个深度相同的点路径上深度最大的点一定大于 $k_i$</p>
<p>由此得到性质：</p>
<ul>
<li>对于点 $u$ ，如果在其两个不同子树种同时存在 $k$ ，且到 $u$ 的路径上没有超过 $k$ 的点，则其标号一定大于 $k$</li>
<li>如果某个子树种存在一个值 $k$ 且从它到 $x$ 的路径上都没有超过 $k$ 的点，则 $x$ 标号不能为 $k$</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,u,v,ans;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; a[N];</span><br><span class="line"><span class="keyword">int</span> bit[N],f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	rei l=<span class="number">0</span>,Size=a[x].<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;Size;++i)&#123;</span><br><span class="line">		rei u=a[x][i]; <span class="keyword">if</span>(u==fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(u,x);</span><br><span class="line">		l|=(bit[x] &amp; bit[u]);</span><br><span class="line">		bit[x]|=bit[u];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!bit[x]) bit[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;f[x])&lt;l || (<span class="number">1</span>&lt;&lt;f[x])&amp;bit[x]) ++f[x];</span><br><span class="line">		bit[x]=(bit[x]/(<span class="number">1</span>&lt;&lt;f[x]) * (<span class="number">1</span>&lt;&lt;f[x])) | (<span class="number">1</span>&lt;&lt;f[x]);</span><br><span class="line">	&#125;</span><br><span class="line">	ans=<span class="built_in">max</span>(ans,f[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>,u,v;i&lt;n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v),a[u].<span class="built_in">push_back</span>(v),a[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>有 $n$ 个 $0$ 和 $m$ 个 $1$ ，给定 $K\geq 2$ 且 $n+m\equiv \pmod {K+1}$ ，不断选取 $K$ 个数并替换为他们的平均数，求最终得到的数有多少可能的取值</p>
</blockquote>
<p>考虑建出严格 $k$ 叉树，所有 $0$ 的深度为 $a_1,a_2,…,a_N$ ，所有 $1$ 的深度为 $b_0,b_1,…,b_m$ ,则最终所得到的数就等于 $B=\sum_{i=1}^m k^{-b_i}$</p>
<p>设 $A=\sum_{i=1}^n k^{-a_i}$ ，即，将 $0,1$ 翻过来，有 $A+B=1$</p>
<p>将 $B$ 以 $k$ 进制呈现，进位过程中，$\sum$ 数码 $\mod {k-1}$ 的值是不变量，一个必要条件就是 $\sum数码 \equiv \pmod {k-1}$ ，且有 $\sum 数码 \leq m$</p>
<p>则问题转化为求多少个数对 $(A,B)$ 满足 $A+B=1$ ，且 $S_k(A)\equiv N\pmod {k-1} 或 S_k(B)\equiv m\pmod{k-1}或S_k(B)\leq m$ ，其中 $S_k(x)$ 表示 $x$ 在 $k$ 进制下数码和</p>
<p>显然 $S_k(A)\equiv N\pmod {k-1}\Leftrightarrow S_k(B)\equiv m\pmod{k-1}$ ，保证其一即可</p>
<p>由于 $A+B=1$ ，可得 $S_k(A)+S_k(B)=(i-1)\times (k-1)+k=i\times (k-1)+1$ ，即， $S_k(B)\leq m \Leftrightarrow S_k(A)\geq i\times (k-1)+1-m$</p>
<p>至此，所有条件仅与 $S_k(A)$ 有关</p>
<p>做一个简单的数位 $\text{dp}$ ，加前缀和转移即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> A,B,k,f[N&lt;&lt;<span class="number">1</span>][N],g[N&lt;&lt;<span class="number">1</span>][N];</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> &amp;<span class="title">reduce</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123; <span class="keyword">return</span> x+=x&gt;&gt;<span class="number">31</span>&amp;mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> &amp;<span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">const</span> <span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">return</span> x+=y-mod,x+=x&gt;&gt;<span class="number">31</span>&amp;mod;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;A,&amp;B,&amp;k);</span><br><span class="line">	<span class="keyword">if</span>(A&gt;B) A^=B,B^=A,A^=B;</span><br><span class="line">	rei limit=(A+B<span class="number">-1</span>)/--k;</span><br><span class="line">	**f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=limit;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;=A;++j) <span class="built_in">add</span>(g[i][j+<span class="number">1</span>]=g[i][j],<span class="built_in">add</span>(f[i][j]=f[i<span class="number">-1</span>][j],g[i<span class="number">-1</span>][j]));</span><br><span class="line">		<span class="keyword">for</span>(rei j=A;j&gt;=k;--j) <span class="built_in">reduce</span>(g[i][j]-=g[i][j-k]);</span><br><span class="line">		<span class="keyword">for</span>(rei l=<span class="built_in">max</span>(A%k,i*k-B+<span class="number">1</span>),r=i*k-l+<span class="number">1</span>; l&lt;=A &amp;&amp; r&gt;=<span class="number">0</span> ;l+=k,r-=k) ans+=g[i][l];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans%mod);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>构造</tag>
        <tag>dp</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>41801202-AGC010</title>
    <url>/2021/08/14/AGC010/</url>
    <content><![CDATA[<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><blockquote>
<p>$n$ 个数字 $a_i$ ，构成一个环，每次从一个起点出发顺时针给这个环依次 $-1,-2,…,-n$ ，求是否有一种方案使所有数恰好被减到 $0$</p>
</blockquote>
<p><strong>注意这里 $-1,-2,…,-n$ 就要考虑差分</strong></p>
<p>每次对 $i$ 操作使 $d_i-=n-1 , \forall j\in n 有 \ d_j+=1 (j!=i)$</p>
<p>每次操作会使整个数列共减少 $c=\frac{n\times (n+1)}{2}$ 显然必须满足 $\sum a_i \mod c=0$</p>
<p>设 $m_i$ 代表以 $i$ 开头的操作的个数</p>
<script type="math/tex; mode=display">d_i=(\frac{\sum a_i}{c}-m_i)-m_i\times (n-1)=\frac{\sum a_i}{c}-m_i\times n</script><script type="math/tex; mode=display">m_i=\frac{\frac{\sum a_i}{c}-d_i}{n}</script><p>满足 $m_i$ 非负整数即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line">ll a[N],d[N],c,n,sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n); c=(ll) n*(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]),sum+=a[i];</span><br><span class="line">    <span class="keyword">if</span>(sum%c) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>),<span class="number">0</span>;</span><br><span class="line">    sum/=c;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) d[i]=a[i%n+<span class="number">1</span>]-a[i];</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>(d[i]&gt;sum || (sum-d[i])%n)&#123; <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>); <span class="keyword">goto</span> done;&#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">    done:</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="剩下三道博弈论蚌埠住了"><a href="#剩下三道博弈论蚌埠住了" class="headerlink" title="剩下三道博弈论蚌埠住了"></a>剩下三道博弈论蚌埠住了</h2><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>$n$ 个正整数满足 $\gcd(a_1,a_2,…,a_N)=1$ ，两人轮流以下操作：选择 $i\in n且 a_i&gt;2 使 a_i—$ ，设 $g=\gcd(a_1,a_2,…,a_n) : \forall i\in n \ \ \  a_i=\frac{a_i}{g}$<br>当轮到某玩家操作时 $a_1=a_2=…=a_n$ 该玩家负</p>
</blockquote>
<p>从特殊到一般考虑：</p>
<p>已经有一个 $a_i=1$ 时 $\gcd一定1$ ，此时的操作就简化为每个人每次将一个数 $-1$ ，即，此时先手必胜当且仅当偶数的个数为奇数</p>
<p>将偶数个数记为 $d_1$ ，奇数个数记为 $d_0$</p>
<p>在考虑一般情况：如果除的 $\gcd$ 是奇数，则对局面的奇偶性不影响，即， $d_1,d_0$ 都不变</p>
<p>由此，如果在某一方发现 $d_1$ 是奇数，则他希望 $\gcd$ 是奇数</p>
<p>有结论： 若 $2\nmid d_1$ 则先手必胜 ； 若 $2\mid d_1 且 d_0\geq 2 ; 或 2\mid d_1 且 数列中有 1$ 则后手必胜</p>
<p><del>证明被吃掉了Σ(っ °Д °;)っ</del></p>
<p>剩余的情况是：偶数个偶数，且剩一个 $&gt;1$ 的奇数</p>
<p>此时先手一定不操作偶数，否则 $\gcd$ 为奇不改变就行，而后手满足 $2\nmid d_1$ 则后手必胜</p>
<p>先手一定会把奇数 $-1$ <strong>让 $\gcd$ 变成偶数</strong></p>
<p>那么模拟先手的操作，更换先后手，判断新局面即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span>&#123;</span><br><span class="line">    rei c[<span class="number">2</span>]=&#123;<span class="number">0</span>&#125;,g=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> one=<span class="literal">false</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">u</span><span class="params">(v)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x:v) ++c[x&amp;<span class="number">1</span>],one|= x==<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(*c&amp;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(one || c[<span class="number">1</span>]&gt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> &amp;x:u) g=__gcd(g,x&amp;=<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> &amp;x:u) x/=g;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">judge</span>(u);<span class="comment">//换手</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n); a.<span class="built_in">reserve</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,x;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x),a.<span class="built_in">emplace_back</span>(x);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="built_in">judge</span>(a) ? <span class="string">&quot;First&quot;</span> : <span class="string">&quot;Second&quot;</span>);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>一个长度为 $n$ 的数列 $a$ ，$A$ 会将整个序列任意排列，$B$ 选择一个相邻的互质数交换位置。 $A$ 希望最终序列字典序尽可能小， $B$ 希望尽可能大，求最终序列</p>
</blockquote>
<p>考虑到 $B$ 只能交换互质的数，那么，所有不互质的数在 $A$ 确定位置后相对位置不会改变，即，对于 $i,j \ 其中 i&lt;j 且 \gcd(a_i,a_j)\not ={1}$ ，连 $i\rightarrow j$ 以确保 $a_i$ 在 $a_j$ 左边，这构成一个DAG</p>
<p>通过拓扑可以得到合法解，而加入优先队列可以得到后手想要的最大解</p>
<p>注意先手尽可能把较小的往前面放，按权值小到大枚举 $u$ 的儿子 $v$ ，并连 $u\rightarrow v$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2010</span>;</span><br><span class="line"><span class="keyword">int</span> n,c[N],deg[N],G[N][N]; <span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> head[N],Next[N&lt;&lt;<span class="number">1</span>],ver[N&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123; ver[++tot]=v,Next[tot]=head[u],head[u]=tot; ++deg[v];&#125;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    vis[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i] || !G[i][x]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">add</span>(x,i); <span class="built_in">dfs</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topsort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>(!deg[i]) q.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        rei x=q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,c[x]);</span><br><span class="line">        <span class="keyword">for</span>(rei i=head[x];i;i=Next[i]) q.<span class="built_in">push</span>(ver[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;c[i]);</span><br><span class="line">    <span class="built_in">sort</span>(c+<span class="number">1</span>,c+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span>(rei j=i+<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(__gcd(c[i],c[j])==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            G[i][j]=G[j][i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>(!vis[i]) <span class="built_in">dfs</span>(i);</span><br><span class="line">    <span class="built_in">topsort</span>();</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>给定 $n$ 个节点的数，顶点 $i$ 上有 $a_i$ 枚石子，开始前 $A$ 可以选择一个节点并在其上面放一枚棋子，然后 $AB$ 交替以下操作：设棋子当前在点 $v$ ，若当前点 $v$ 行已经没有石子则当前玩家输，否则移除点 $v$ 上的一个石子；将棋子移到相邻的点 $u$。 要求找到所有点 $v$ 使 $A$ 开局前把棋子放到 $v$ 上时必胜</p>
</blockquote>
<p>证明一个神仙结论：任何时候，每个人只会向满足 $A$ 更小的地方走，即，任何人不会向 $A_u\geq A_v$ 的点 $u$ 移动</p>
<ul>
<li><p>不妨设 $A$ 如此移动，即，棋子 $v\rightarrow u$ ，将原树看成以 $v$ 为根的有根树，考虑以 $u$ 为根的子树</p>
<ul>
<li>若 $B$ 在当前有必胜策略，则 $B$ 赢了</li>
<li>若 $B$ 无必胜策略，则 $B$ 的最优策略是逃离 $u$ ，那么 $B:u\rightarrow v$ 如此 $A$ 会失去先手优势</li>
<li>由此， $A$ 不可能取胜，则其不会这么走</li>
</ul>
</li>
</ul>
<p>由上可知，若子树中 $B$ 赢，则原树中 $A$ 赢，反之亦成立</p>
<p>$\text{dfs}$ 判断 ，$O(n^2)$ 解决即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3010</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],Next[N&lt;&lt;<span class="number">1</span>],ver[N&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line"><span class="keyword">int</span> a[N],n;</span><br><span class="line"><span class="keyword">bool</span> first=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123; ver[++tot]=v,Next[tot]=head[u],head[u]=tot;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa=<span class="number">0</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> flag=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=head[x];i;i=Next[i])&#123;</span><br><span class="line">		rei y=ver[i]; <span class="keyword">if</span>(y==fa || a[y]&gt;=a[x]) <span class="keyword">continue</span>;</span><br><span class="line">		flag&amp;=<span class="built_in">dfs</span>(y,x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> !flag;<span class="comment">//经典换手</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>,u,v;i&lt;n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v),<span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>(<span class="built_in">dfs</span>(i)) first ? first=<span class="literal">false</span> : <span class="built_in">putchar</span>(<span class="number">32</span>),<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>构造</tag>
        <tag>贪心</tag>
        <tag>数论</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>61801202-AGC011</title>
    <url>/2021/08/16/AGC011/</url>
    <content><![CDATA[<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>给定一张 $n$ 个点 $m$ 个边的图，现在构成一张 $n^2$ 个点的新图，每个点是一个二元组 $(a,b)$ ,其中，新图中点 $(a,b) , (c,d)$ 有边当且仅当 原图中 $a,c ; b,d$ 有边，求新图中连通块个数</p>
<p>观察新图中两点间有边的条件：<strong>在原图中的两个点 $i,j$ 分别向其相邻的点走一步，到达点 $u,v$ ，那么新图中连边 $(i,j)\rightarrow (u,v)$</strong></p>
<p>考虑单一连通块内部：对于任意点对 $(u,v)$ 可将两点均向中间缩，最后有两种情况：</p>
<ul>
<li>$u,v$ 重合：路径长偶数</li>
<li>$u,v$ 位于边两端：路径长奇数</li>
</ul>
<p>那么，原图的连通块在新图中会形成一个或两个连通块</p>
<p>可以得出神奇的结论：</p>
<ul>
<li>对于一个原图中的独立点 $u$ ，新图的 $(u,v)$ 与 $(v,x)$ 均为独立的点 $( v\in n )$ 。故设原图中独立点数量为 $single$ ，那么独立点对答案的贡献就是 $single\times n+(n-single)\times single$</li>
<li>对于原图中的无奇环联通块，可以与任一联通块组成新图的两个不同联通块。设这种联通块有 $c$ 个，其两两组合对答案的贡献为 $c\times c\times 2$</li>
<li>对于原图中的有奇环联通块，可以与任一联通块组成新图的一个联通块（若与它组合的是无奇环联通块，则两个）。设这种联通块有 $d$ 个，则它对答案的贡献就是 $d*\times (d+c\times 2)$</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[N&lt;&lt;<span class="number">1</span>],Next[N&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line"><span class="keyword">int</span> fa[N],Size[N],n,m,cnt[<span class="number">2</span>];</span><br><span class="line">PII circle[N]; <span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">bool</span> parity[N],odd[N];</span><br><span class="line"><span class="keyword">int</span> single; ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123; ver[++tot]=v,Next[tot]=head[u],head[u]=tot;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> fa[x]==x ? x : fa[x]=<span class="built_in">find</span>(fa[x]);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fath)</span></span>&#123;</span><br><span class="line">    parity[x]=parity[fath]^<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=head[x];i;i=Next[i])&#123;</span><br><span class="line">        rei y=ver[i]; <span class="keyword">if</span>(y==fath) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) fa[i]=i,Size[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,u,v;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(u)!=<span class="built_in">find</span>(v))&#123; <span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u); u=<span class="built_in">find</span>(u),v=<span class="built_in">find</span>(v); fa[u]=v,Size[v]+=Size[u];&#125;</span><br><span class="line">        <span class="keyword">else</span> circle[++num]=<span class="built_in">mk</span>(u,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>(fa[i]==i) <span class="built_in">dfs</span>(i,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=num;++i) <span class="keyword">if</span>(parity[ circle[i].first ]==parity[ circle[i].second ]) odd[ <span class="built_in">find</span>(circle[i].first) ]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[i]!=i) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(Size[i]==<span class="number">1</span>) ++single,ans+=n;</span><br><span class="line">        <span class="keyword">else</span> ++cnt[ odd[i] ];</span><br><span class="line">    &#125;</span><br><span class="line">    ans+=(ll) (n-single)*single + (ll) <span class="number">2</span>*cnt[<span class="number">0</span>]*cnt[<span class="number">0</span>] + (ll) cnt[<span class="number">1</span>]*(cnt[<span class="number">1</span>]+<span class="number">2</span>*cnt[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>有 $n$ 个机器排成一排，每个装置有 $A,B$ 两种状态，一小球从左侧进入该系统。其中 $A$ 使球反弹回原方向，$B$ 无作用，球经过一个装之后装置状态将改变，给定初始状态，求 $k$ 个小球经过后装置最终状态</p>
</blockquote>
<p>先看小一点的情况：</p>
<ul>
<li>第一个是 $A$ ：球弹回去，第一个变成 $B$</li>
<li>第一个是 $B$ ：球继续，如果后面还有 $A$ 则会撞上之前经过的 $B$ 变成的 $A$ 而弹回去</li>
</ul>
<p>可以发现对于一次滚球：删去序列第一个，序列整体取反，末尾加上一个 $A$ 可以完成</p>
<p>再考虑 $k$ ，由于<strong>删除-取反-添加</strong>的操作，整个字符串逐渐从后向前变成 $ABAB…或BABA…$ 的形态</p>
<p>而在 $k&gt;n$ 时，对于 $ABAB…$ 奇数次会变为 $BABA…$ ，偶数次不变，对于 $BABA…$ 形态不会改变</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">4e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,k,num[N],st;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) num[i]=s[i]-<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    st=num[<span class="number">1</span>];</span><br><span class="line">    rei pos=<span class="number">1</span>,cnt=<span class="number">0</span>;<span class="comment">//p表示删到哪里了，cnt是操作次数</span></span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!st) st^=<span class="number">1</span>,num[pos]^=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> ++pos,++cnt,st=num[pos],st^=(cnt&amp;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(pos&gt;n) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(rei i=pos;i&lt;=n;++i) <span class="built_in">putchar</span>(<span class="string">&#x27;A&#x27;</span>+(num[i]^(cnt&amp;<span class="number">1</span>)));</span><br><span class="line">        rei t=pos<span class="number">-1</span>,c=(cnt<span class="number">-1</span>)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(t--) <span class="built_in">putchar</span>(<span class="string">&#x27;A&#x27;</span>+c),c^=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((cnt<span class="number">-1</span>)&amp;<span class="number">1</span>) <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">putchar</span>(<span class="string">&#x27;A&#x27;</span>+(i&amp;<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="built_in">putchar</span>(<span class="string">&#x27;A&#x27;</span>+(k&amp;<span class="number">1</span>)); <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;n;++i) <span class="built_in">putchar</span>(<span class="string">&#x27;A&#x27;</span>+(i&amp;<span class="number">1</span>)); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>定义一个数是“递增的”，当且仅当对于它的任意相邻的两位都有左边小于等于右边。给定一个数 $n\leq 10^{500000}$ 求其最少可以被表示为一个递增的数之和</p>
</blockquote>
<p>考虑找到一个数时递增的充要条件</p>
<p>定义一个数纯一数，如果其所有数码都为 $1$ ， 显然其可被写成 $\frac{1}{9}(10^n-1)$ 的形式。那么一个数时递增的当且仅当它是不超过 $9$ 个纯一数的和，由于 $0$ 也可以被写成该形式，定义纯一数都表示为 $9$ 个形如 $\frac{1}{9}(10^n-1)$ 的数的和</p>
<p>于是 $x=\frac{1}{9}(10^{n_1}-1) + …+\frac{1}{9}(10^{n_9}-1)\ \Leftrightarrow \ 9x+9=10^{n_1}+…+10^{n_9}$</p>
<p>$\therefore$ $9x+9$ 的数码和一定为 $9$</p>
<p>现在需要判断 $n$ 是多少递增数的和，需要算出 $9n$ ，然后加上 $9k$ 其中 $k$ 是答案</p>
<p>假设 $n$ 是 $k$ 个递增数的和， $9\times (n+k)$ 就是不超过 $9k$ 个 $10$ 的幂的和，从而数码和 $\leq 9\times k$ ，反之亦能推出，故这是充要条件</p>
<p>问题转化为：求最小的 $k$ 使 $9(n+k)$ 的数码和 $\leq 9\times k$</p>
<p><strong>对于这种高精的题，尝试直接枚举，以利用均摊复杂度</strong></p>
<p>枚举 $k$ ，每次对 $9n$ 加 $9$ ，加法过程中维护数码和，答案不会超过 $\lg n+O(1)$ ，均摊复杂度为 $O(k+\lg n)=O(\log n)$</p>
<p><del>压位减小常数</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e5</span>+<span class="number">100</span>,BASE=<span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">int</span> n,s[N],f[<span class="number">10000</span>],cur,dsum,ans,len;</span><br><span class="line"><span class="keyword">char</span> str[N],tok[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">digit_sum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> f[x/<span class="number">10000</span>]+f[x%<span class="number">10000</span>];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    tok[<span class="number">8</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;<span class="number">10000</span>;++i) f[i]=f[i/<span class="number">10</span>]+i%<span class="number">10</span>;<span class="comment">//数码和分高低位打表</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str); len=<span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i*<span class="number">8</span>&lt;=len;++i) <span class="built_in">memcpy</span>(tok,str+(len-i*<span class="number">8</span>),<span class="number">8</span>),s[n++]=<span class="built_in">strtol</span>(tok,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span>(len&amp;<span class="number">7</span>) <span class="built_in">memcpy</span>(tok,str,len&amp;<span class="number">7</span>),tok[len&amp;<span class="number">7</span>]=<span class="number">0</span>,s[n++]=<span class="built_in">strtol</span>(tok,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;n+<span class="number">2</span>;++i) cur=s[i]*<span class="number">9</span>+cur,s[i]=cur%BASE,cur/=BASE,dsum+=<span class="built_in">digit_sum</span>(s[i]);</span><br><span class="line">    <span class="keyword">for</span>(ans=<span class="number">1</span>;;++ans)&#123;</span><br><span class="line">        dsum-=<span class="built_in">digit_sum</span>(*s),*s+=<span class="number">9</span>;</span><br><span class="line">        rei i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;s[i]&gt;=BASE;++i) dsum+=<span class="built_in">digit_sum</span>(s[i]-=BASE)-<span class="built_in">digit_sum</span>(s[i+<span class="number">1</span>]++);<span class="comment">//数码和的守恒</span></span><br><span class="line">        dsum+=<span class="built_in">digit_sum</span>(s[i]);</span><br><span class="line">        <span class="keyword">if</span>(dsum&lt;=<span class="number">9</span>*ans)&#123; <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans); <span class="keyword">goto</span> done;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    done:</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>有一条分成 $n$ 段的铁路共有 $n+1$ 个站台，标号为 $0\sim N$ ，其中铁路 $i$ 连接站台 $i-1,i$ ，长度为 $a_i$ ，铁路分为单向双向两种，需要制定一个时间表，满足：</p>
<p>所有火车要么正向要么反向，中途不能掉头</p>
<p>所有火车速度 $1$ 单位，且保持匀速</p>
<p>所有正向，反向火车发车间隔均为 $k$ 且在站 $i$ 上的停靠时间只与 $i$ 有关</p>
<p>对于任意一条单向铁路，不能有正向反向火车在非站台的地方相遇</p>
<p>求一个时间表，使正向火车 $0\sim n$ 的时间加上反向火车 $n\sim 0$ 的时间总合(包括停靠时间)最小</p>
</blockquote>
<p>把铁路放在数轴上考虑，每个站台 $i$ 都有坐标 $x_i=a_1+a_2+…+a_i$ ，且将时间模 $k$ ，在 $\pmod k$ 的范围下讨论</p>
<p>先考虑无解：</p>
<p>一段单项铁路长度 $l&gt;\frac{k}{2}$ 时无解：$\pmod k$ 意义下两个长度 $&gt;\frac{k}{2}$ 的区间并相交，显然正反向列车行车区间相交则无解； 反之，若所有长度 $l\leq \frac{k}{2}$ 则一定有解。</p>
<p>设 $p_0$ 时正向列车发车时刻， $p_i$ 时列车在站台 $i$ 的停靠时间，则正向列车在铁路 $i$ 上的行车区间为 $[p_0+p_1+…+p_{i-1}+x_{i-1} \ ,\ p_0+p_1+…+p_{i-1}+x_i]$</p>
<p>简记 $P_n=\sum_{i=1}^n p_i$ 则区间 $\mathcal{P_i}=[P_{i-1}+x_{i-1}\ ,\ P_{i-1}+x_i]$</p>
<p>而对于反向列车，将整个过程倒过来，设 $-n_0$ 为到达时刻， $n_i$ 为停靠时间，$N_n=\sum_{i=1}^n n_i$ ，则区间 $\mathcal{N_i}=[-N_{i-1}-x_i\ ,\ -N_{i-1}-x_{i-1}]$</p>
<p>考虑环上区间 $[l_1,r_1],[l_2,r_2]$ 不交的充要条件，为 $l_1\in [r_2,l_1+l_2-r_1]$</p>
<p>$\therefore$ 列车不碰撞的条件转化为表达式： $P_{i-1}+x_{i-1}\in [-N_{i-1}-x_{i-1}\ ,\ -N_{i-1}+x_{i-1}-2x_i] \Leftrightarrow P_{i-1}+N_{i-1}\in[-2x_{i-1}\ ,\ -2x_i]$</p>
<p>再考虑最终答案，若不计停靠时间显然为 $2\times x_n$ ，所以需要最小化停靠时间之和 $\sum_{i=1}^{n-1} (p_i+n_i)$</p>
<p>将上述不碰撞区间看为 $R_i$ ，转化为一般问题：</p>
<blockquote>
<p>若干个区间 $R_1,R_2,…,R_n$ 有一个 $\pmod k$ 意义下的数 $x$ ，且初值任意。需要核实的移动 $x$ 使其落入 $R_i$ 中，仅能正向移动，且模 $k$ ，求最小化移动距离</p>
</blockquote>
<p>当起点固定，有贪心：能不移就不移，否则移至区间左端点</p>
<p>由于不知道起点，考虑 $\text{dp}$ ，$f_{i,x}$ 表示前 $i$ 个区间，从最有七点移动到已知终点 $x$ 所需最小总距离</p>
<p>设 $j$ 是最大的使 $x\notin R_j$ 的 $j$ ，整个过程的最后一步就是将 $x$ 从 $R_j$ 的右端点移回 $x$ </p>
<p>$f_{i,x}=f_{j,r_j}+\left(x∸r_j\right)$ ，其中 $a∸b$ 表示 $a-b$ 取 $\pmod k$ 的最小非负剩余</p>
<p>添加区间时依次求出 $f_{1,r_1},f_{2,r_2},…,f_{n,r_n}$ ，最后的位置一定是某个区间的左端点，将所有左端点带入 $x$ 询问即可</p>
<p>最后，考虑如何找到最大的 $j$ 使 $x\notin R_j$ 的 $j$ 最大</p>
<p>对于每个 $x$ ,设 $pre_x=j$ ，考虑操作对 $pre$ 的影响</p>
<p>每一次操作相当于对不在 $[l_i,r_i]$ 的所有数 $e$ 令 $pre_e=i$</p>
<p>这可以看成区间赋值，而查询只需要单点查询，然后就会用到珂朵莉树</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,T;</span><br><span class="line">ll x[N],f[N],ans=LLONG_MAX;</span><br><span class="line">PII seg[N];</span><br><span class="line"><span class="keyword">bool</span> directed[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(ll &amp;x,<span class="keyword">const</span> ll y)</span></span>&#123;x&gt;y ? x=y : <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">fix</span><span class="params">(ll x)</span></span>&#123;<span class="keyword">return</span> x%=T,x+=x&gt;&gt;<span class="number">63</span>&amp;T;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> CTree&#123;</span><br><span class="line">	map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; C;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; C.<span class="built_in">emplace</span>(<span class="number">0</span>,<span class="number">-1</span>),C.<span class="built_in">emplace</span>(T,<span class="number">-1</span>);&#125;</span><br><span class="line">	map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::<span class="function">iterator <span class="title">split</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">		map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator it=C.<span class="built_in">lower_bound</span>(pos),jt=it;</span><br><span class="line">		<span class="keyword">return</span> it-&gt;first==pos ? it : C.<span class="built_in">emplace_hint</span>(it,pos,(--jt)-&gt;second);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator it=<span class="built_in">split</span>(l),jt=<span class="built_in">split</span>(r);</span><br><span class="line">		C.<span class="built_in">erase</span>(it,jt),C.<span class="built_in">emplace</span>(l,v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> h)</span></span>&#123;<span class="keyword">return</span>(--C.<span class="built_in">upper_bound</span>(h))-&gt;second;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rei j,L,R;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;T);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%lld%d&quot;</span>,x+i,&amp;j),directed[i]=j&amp;<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="number">2</span>*x[i]&gt;T) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>),<span class="number">0</span>;</span><br><span class="line">			x[i]+=x[i<span class="number">-1</span>],seg[m++]=<span class="built_in">mk</span>(L=<span class="built_in">fix</span>(<span class="number">-2</span>*x[i<span class="number">-1</span>]),R=<span class="built_in">fix</span>(<span class="number">-2</span>*x[i]));</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">else</span> x[i]+=x[i<span class="number">-1</span>];</span><br><span class="line">	CTree::<span class="built_in">init</span>();</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">		std::<span class="built_in">tie</span>(L,R)=seg[i],j=CTree::<span class="built_in">query</span>(R);</span><br><span class="line">		f[i]=(~j ? f[j]+<span class="built_in">fix</span>(R - seg[j].second) : <span class="number">0</span>);</span><br><span class="line">		L&lt;=R ? (CTree::<span class="built_in">modify</span>(<span class="number">0</span>,L,i),CTree::<span class="built_in">modify</span>(R+<span class="number">1</span>,T,i)) : (CTree::<span class="built_in">modify</span>(R+<span class="number">1</span>,L,i));</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">const</span> PII &amp;e : CTree::C)&#123;</span><br><span class="line">		<span class="keyword">if</span>(e.first&gt;=T) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(!~e.second)&#123; ans=<span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">		<span class="built_in">down</span>(ans,f[e.second]+<span class="built_in">fix</span>(e.first-seg[e.second].second));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans+<span class="number">2</span>*x[n]);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>构造</tag>
        <tag>dp</tag>
        <tag>数论</tag>
        <tag>珂朵莉树</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>71801202-AGC012</title>
    <url>/2021/08/17/AGC012/</url>
    <content><![CDATA[<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><blockquote>
<p>定义一个好字符串 $x$ 满足：$x=yy$ ，给出 $n$ , 求一个串 $s$ 满足 $|s|\leq 200$ ，且每个字符用 $[1,100]$ 的整数表示，且在 $s$ 的所有 $2^{|s|}$ 哥子序列中，恰好有 $n$ 个串是好的</p>
</blockquote>
<p>有一个巧妙的构造方案：</p>
<p>分成前后两部分，后半部分为 $1\sim 100$ ，前半部分为 $1$ 至 $x \ (x\leq 100)$ ，<strong>好序列的个数为前半部分上升子序列的个数</strong></p>
<p>从小到大增加前半部分的字符，放到最前面使方案数 $+1$ ，最后面使方案数 $\times 2$ ，而反向过来就是一个二进制拆分过程</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">210</span>;</span><br><span class="line"><span class="keyword">int</span> p[N],q[N],cnt;</span><br><span class="line">ll n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(~n&amp;<span class="number">1</span>) q[ ++q[<span class="number">0</span>] ]=cnt++,<span class="built_in">solve</span>(n<span class="number">-1</span>);<span class="comment">//放前面,会使数量加1</span></span><br><span class="line">    <span class="keyword">else</span> p[ ++p[<span class="number">0</span>] ]=cnt++,<span class="built_in">solve</span>(n&gt;&gt;<span class="number">1</span>);<span class="comment">//放后面，会使数量 *2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">solve</span>(n); <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cnt+<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=q[<span class="number">0</span>];++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,cnt-q[i]);</span><br><span class="line">    <span class="keyword">for</span>(rei i=p[<span class="number">0</span>];i;--i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,cnt-p[i]);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>$n$ 个球，第 $i$ 个颜色为 $c_i$ ，质量为 $w_i$ ，有两种操作：选择两个同色且质量和不超过 $x$ 的球并交换位置 ; 选择两个异色且质量和不超过 $Y$ 的球并交换位置</p>
<p>求一共能得到多少不同的颜色序列</p>
</blockquote>
<p>对于一种颜色，设所有球质量分别为 $w_1,w_2…w_n$ ，假设 $w_1&lt;w_2&lt;w_n$ ，易得若 $w_1+w_n\leq x$ 则这 $n$ 个球可以任意交换位置（以 $1$ 号球为媒介依次交换 $(1,i),(1,j),(i,1)$</p>
<p>若 $w_1+w_n&gt;x$ 再设 $m$ 为最大的满足 $w_1+w_m\leq x$ 的数，考虑处理 $w_m\sim w_n$</p>
<p>考虑使用全局最小值，指与 $w_i$ 不同颜色的最小值，设为 $w_g$ ，对于要处理的部分，若 $w_g+w_i\leq y$ ，则 $(i,g)$ 可以互换位置（同样以 $1$ 为媒介），也就是数，满足 $w_g+w_i\leq y$ 的 $i$ 与 $1\leq i\leq m$ 的 $i$ 性质一样</p>
<p>但若 $w_g+w_i&gt;y$  则该球不能移动</p>
<p>对于剩下的球，将每种颜色视为整体，质量为所有球的总质量，可以发现其性质与小球一样</p>
<p>答案就是前 $m$ 种颜色的所有球的排列总数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,S,D;</span><br><span class="line"><span class="keyword">int</span> fac[N],facinv[N];</span><br><span class="line">ll ans=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> m,MIN=INF,sec=INF;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">const</span> <span class="keyword">int</span> y)</span></span>&#123; x&gt;y ? x=y : <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">qpow</span><span class="params">(ll x,<span class="keyword">int</span> y)</span></span>&#123; ll ans=<span class="number">1</span>; <span class="keyword">while</span>(y)&#123; <span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod; x=x*x%mod; y&gt;&gt;=<span class="number">1</span>;&#125; <span class="keyword">return</span> ans;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) fac[i]=(ll) fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    facinv[n]=<span class="built_in">qpow</span>(fac[n],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(rei i=n;i;--i) facinv[i<span class="number">-1</span>]=(ll) facinv[i]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;S,&amp;D); <span class="built_in">init</span>();</span><br><span class="line">    <span class="comment">// puts(&quot;here&quot;);</span></span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,c,v;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;c,&amp;v),s[c].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>(s[i].<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="built_in">iter_swap</span>(s[i].<span class="built_in">begin</span>(),<span class="built_in">min_element</span>(s[i].<span class="built_in">begin</span>(),s[i].<span class="built_in">end</span>()));</span><br><span class="line">        <span class="keyword">if</span>(s[i].<span class="built_in">front</span>()&lt;MIN) sec=MIN,MIN=s[i].<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">down</span>(sec,s[i].<span class="built_in">front</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// puts(&quot;here&quot;);</span></span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>(s[i].<span class="built_in">size</span>() &amp;&amp; s[i].<span class="built_in">front</span>()+MIN&lt;=D)&#123;</span><br><span class="line">        rei c=<span class="number">0</span>,v=s[i].<span class="built_in">front</span>()==MIN ? sec : MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u:s[i]) c+=u+s[i].<span class="built_in">front</span>()&lt;=S || u+v&lt;=D;</span><br><span class="line">        m+=c,ans=ans*facinv[c]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// puts(&quot;here&quot;);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans*fac[m]%mod);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>数轴上有 $n(n\leq 2\times 10^5)$ 个绿洲，有一只储水量 $V(V\leq 2\times 10^5)$ 的骆驼，骆驼有两个操作：走到距离 $V$ 以内的一个绿洲；跳到任意绿洲，代价是 $V$ 会变为 $\left\lfloor \frac{V}{2} \right\rfloor$ ，注意当 $V=0$ 时不能跳，骆驼会从每个绿洲出发，对每一个判断能否一次性遍历所有绿洲</p>
</blockquote>
<p>对于 $V,\frac{V}{2},\frac{V}{4},…$ 可以先预处理出此时那些绿洲之间可以直接走</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ntzucbso.png" alt="https://cdn.luogu.com.cn/upload/image_hosting/ntzucbso.png"></p>
<p>每跳一次相当于向下走一层，题目转化为钦定第一条线段，然后从每一层选一条，问是否能覆盖整个区间</p>
<p>神仙状压</p>
<p>设状态 $s$ 的第 $i$ 位为 $1$ 表示从第 $i$ 层选出一条线段， $f_1[s]$ 表示状态 $s$ 时从 $1$ 向右最多能延伸到的位置，$f_2[s]$ 表示状态 $s$ 时从 $n$ 向左做多能延伸到的位置</p>
<p>有转移：</p>
<script type="math/tex; mode=display">\begin{aligned}
f_1[s]=\max(f_1[s],upFind(f_1[s_0])) \\
f_2[s]=\min(f_2[s],downFind(f_2[s_0]-1)) \\
\end{aligned}</script><p>即，从 $s_0$ 加上一条线段能延伸到的位置</p>
<p>检查答案时，对第一层的每一条线段寻找是否有 $s$ 使 $f_1[s],f_2[U-s-1]$ 贺该线段覆盖整个区间。用状态 $s$ 的线段尽可能扩展左半部分，剩下的线段（不包括第一层的）尽可能扩展右半部分</p>
<p>最多会跳 $\log {V+1}$ 所以全集的状态 $U=2^{\log {V+1}}-1$ 所以要开到 $2^{19}$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,S=<span class="number">1</span>&lt;&lt;<span class="number">19</span>;</span><br><span class="line"><span class="keyword">int</span> n,V;</span><br><span class="line">ll d[N];</span><br><span class="line"><span class="keyword">int</span> logV,a[<span class="number">25</span>][N],U,f1[S],f2[S];</span><br><span class="line"><span class="comment">//a[i][j] 表示第i层第j条线段的右端点，而a[i][0]记录第i层线段的条数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">upFind</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//第一个严格大于x的右端点，该端点所在区间一定能延伸当前f_1</span></span><br><span class="line">    rei L=<span class="number">1</span>,R=a[<span class="number">0</span>];<span class="comment">//a[i][0]被用成边界了</span></span><br><span class="line">    <span class="keyword">while</span>(L&lt;R<span class="number">-1</span>)&#123;</span><br><span class="line">        rei mid=L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        a[mid]&lt;=x ? L=mid+<span class="number">1</span> : R=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a[L]&gt;x ? a[L] : a[R];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowFind</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//lowfind(x-1):第一个严格小于x-1的右端点，该点的下一个区间一定能延伸当前的f_2</span></span><br><span class="line"><span class="comment">//特别注意这里不能写lowfind(x) : 要是找到x-1，说明有一段以x-1为右端点的区间以及一段以x为左端点的区间，显然加入前者更优，但却加入后者导致错误</span></span><br><span class="line">    rei L=<span class="number">1</span>,R=a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span>(L&lt;R<span class="number">-1</span>)&#123;</span><br><span class="line">        rei mid=L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        a[mid]&lt;x ? L=mid : R=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a[R]&lt;x ? a[R]+<span class="number">1</span> : a[L]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;V);</span><br><span class="line">    <span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;logV)&lt;=V) ++logV; ++logV;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;d[i]),d[i<span class="number">-1</span>]=d[i]-d[i<span class="number">-1</span>]; d[n]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=logV;++i)&#123;</span><br><span class="line">        a[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">            a[i][ a[i][<span class="number">0</span>] ]=j;</span><br><span class="line">            <span class="keyword">if</span>(d[j]&gt;(V&gt;&gt;(i<span class="number">-1</span>))) ++a[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">1</span>][<span class="number">0</span>]&gt;logV)&#123;</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">puts</span>(<span class="string">&quot;Impossible&quot;</span>);</span><br><span class="line">        <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    U=(<span class="number">1</span>&lt;&lt;logV)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei s=<span class="number">0</span>;s&lt;=U;++s) f1[s]=<span class="number">0</span>,f2[s]=n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei s=<span class="number">0</span>;s&lt;=U;s+=<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;=logV;++i)&#123;</span><br><span class="line">            rei s0=<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span>(s&amp;s0) <span class="keyword">continue</span>;</span><br><span class="line">            f1[s|s0]=<span class="built_in">max</span>(f1[s|s0],<span class="built_in">upFind</span>(a[i],f1[s]));</span><br><span class="line">            f2[s|s0]=<span class="built_in">min</span>(f2[s|s0],<span class="built_in">lowFind</span>(a[i],f2[s]<span class="number">-1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=a[<span class="number">1</span>][<span class="number">0</span>];++i)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">        rei fr=a[<span class="number">1</span>][i<span class="number">-1</span>]+<span class="number">1</span>,to=a[<span class="number">1</span>][i];</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>) fr=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(rei s=<span class="number">0</span>;s&lt;=U&amp;&amp;!flag;s+=<span class="number">2</span>) <span class="keyword">if</span>(fr&lt;=f1[s]+<span class="number">1</span> &amp;&amp; f2[U-s<span class="number">-1</span>]<span class="number">-1</span>&lt;=to) flag=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">for</span>(rei j=fr;j&lt;=to;++j) <span class="built_in">puts</span>(<span class="string">&quot;Possible&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">for</span>(rei j=fr;j&lt;=to;++j) <span class="built_in">puts</span>(<span class="string">&quot;Impossible&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>给定长度为 $2n-1 \ (n\leq 60)$ 的数组 $a$ ，可以重排 $a$ 中的元素，再生成一个长度为 $n$ 的数组 $b$ ，其中 $b_i$ 是 $a_1\sim a_{2\times i-1}$ 的中位数，对于给定的 $a$ 球能生成多少种 $b$ ，对 $998244353$ 取模</p>
</blockquote>
<p>神仙 $\text{dp}$ qwq</p>
<p>可以设 $a_i$ 升序，那么 $b_i$ 有两条性质：</p>
<ul>
<li>$b_i\in \{a_i,a_{i+1},…,a_n,…,a_{2n-i}\}$</li>
<li>不存在 $i&lt;j$ 使 $b_i$ 介于 $b_j,b_{j+1}$ 之间</li>
</ul>
<p>设 $f_{i,j,k}$ 表示当前确定了 $b_i\sim b_n$ 且第 $i$ 层左边还有 $j$ 个不同的数可供选择，右边还有 $k$ 个不同的数可供选择（不含 $b_i$ ），边界为 $f_{n,0,0}=1$</p>
<p>考虑转移：</p>
<ul>
<li>若 $b_{i-1}=b_i$ 则两侧可供选择的数的个数不变，只需加上两侧新增的数 ($le$ 表示 $a_i$ 是否等于 $a_{i-1}$ ，$re$ 同理): $f_{i-1,j+le,k+re}\leftarrow f_{i,j,k}$</li>
<li>若 $b_{i-1}&lt;b_i$ 由性质 $2$ 得之前的 $b_j$ 不能在范围 $(b_{i-1},b_i)$ 之间，那么这些数无用。则右侧可选的数多 $1$ ，左侧可选的数数量在 $0\sim j+le-1$ 任取: $f_{i-1,v,k+1+re}\leftarrow f_{i,j,k} \ \ \ \ (v\in [0,j+le])$</li>
</ul>
<p>答案为当 $i=1$ ，任取 $j,k\in[0,2\times n-1]$ 求和</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">125</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,G,ans;</span><br><span class="line"><span class="keyword">int</span> a[N],f[<span class="number">2</span>][N][N],(*cur)[N]=*f,(*Next)[N]=f[<span class="number">1</span>];<span class="comment">//滚动</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fix</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123; x&gt;=mod ? x-=mod : <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n); G=(n&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=G;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+G);</span><br><span class="line">    Next[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=n;i&gt;<span class="number">1</span>;--i)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(cur,Next); <span class="built_in">memset</span>(Next,<span class="number">0</span>,<span class="keyword">sizeof</span> *f);</span><br><span class="line">        rei le=a[i]!=a[i<span class="number">-1</span>],re=a[G-i+<span class="number">1</span>]!=a[G-i+<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;=n-i&lt;&lt;<span class="number">1</span>;++j)</span><br><span class="line">            <span class="keyword">for</span>(rei k=<span class="number">0</span>;k&lt;=n-i&lt;&lt;<span class="number">1</span>;++k)&#123;</span><br><span class="line">                rei c=cur[j][k]; <span class="keyword">if</span>(!c) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">fix</span>(Next[j+le][k+re]+=c);</span><br><span class="line">                <span class="keyword">for</span>(rei v=<span class="number">0</span>;v&lt;j+le;++v) <span class="built_in">fix</span>(Next[v][k+<span class="number">1</span>+re]+=c);<span class="comment">//右边</span></span><br><span class="line">                <span class="keyword">for</span>(rei v=<span class="number">0</span>;v&lt;k+re;++v) <span class="built_in">fix</span>(Next[j+<span class="number">1</span>+le][v]+=c);<span class="comment">//左边</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;=G;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;=G;++j) <span class="built_in">fix</span>(ans+=Next[i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>构造</tag>
        <tag>dp</tag>
        <tag>贪心</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>81801202-AGC013</title>
    <url>/2021/08/18/AGC013/</url>
    <content><![CDATA[<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><blockquote>
<p>长度为 $l$ 的圆环上有 $n$ 个蚂蚁，位置为 $x_i$ ，运动方向为 $d_i$ ，$1$ 为顺时针，$2$ 为逆时针。每只蚂蚁同时开始以单位速度移动，若两蚂蚁相遇则会改变自身方向，求 $t$ 秒后每只蚂蚁位置</p>
</blockquote>
<p>易知蚂蚁的相对位置不变，将相遇掉头看成交换编号，可以算出 $t$ 秒后的有蚂蚁的位置</p>
<p>记录第一只蚂蚁的 $rank$ ，对于每一只蚂蚁来说，每当一只蚂蚁倒着穿过， $rank—$ ；正着穿过 $rank++$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,l,t,rank_1,rnk[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,w;</span><br><span class="line">&#125;a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;l,&amp;t);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a[i].x,&amp;a[i].w); a[i].w==<span class="number">2</span> ? a[i].w=<span class="number">-1</span> : <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        rei length=a[i].x+a[i].w*t;</span><br><span class="line">        rank_1+=length/l;</span><br><span class="line">        <span class="keyword">if</span>(length%l&lt;<span class="number">0</span>) --rank_1;</span><br><span class="line">        rnk[i]=(length%l+l)%l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(rnk+<span class="number">1</span>,rnk+<span class="number">1</span>+n);</span><br><span class="line">    rank_1=(rank_1%n+n)%n;</span><br><span class="line">    <span class="comment">// for(rei i=1;i&lt;=n;++i) printf(&quot;%d &quot;,rnk[i]);</span></span><br><span class="line">    <span class="comment">// printf(&quot;rank_1:%d\n&quot;,rank_1);</span></span><br><span class="line">    <span class="keyword">for</span>(rei i=rank_1+<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,rnk[i]);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=rank_1;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,rnk[i]);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>盒子里有黑白两种颜色 $n$ 个球，进行 $m$ 次操作，每次操作：从盒子中任取一个球，向盒子里添加黑白球各一个，在任取一个球。初始的球颜色不给出，求取出的 $2m$ 个球有多少种颜色序列</p>
</blockquote>
<p>本质上仅有四种操作：BB；BW；WB；WW</p>
<p>以操作次数为 $x$ 轴，盒子里白球数为 $y$ ，则有</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ox2813ev.png" alt="https://cdn.luogu.com.cn/upload/image_hosting/ox2813ev.png"></p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/au35glpi.png" alt="https://cdn.luogu.com.cn/upload/image_hosting/au35glpi.png"></p>
<p>显然四种操作会形成 $4$ 种不同序列，以任一点为起点画个图</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/rprt0vu0.png" alt="https://cdn.luogu.com.cn/upload/image_hosting/rprt0vu0.png"></p>
<p>设状态 $f_{i,j}$ 表示操作 $i$ 次，盒子里有 $j$ 个白球时序列的情况</p>
<p>但注意以所有盒子里情况为起点时会存在操作相同且最终序列也相同的情况，有结论：只统计白球数量到达过 $0$ 的操作组即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,f[N][N][<span class="number">2</span>],ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fix</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123; x&gt;=mod ? x-=mod : <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) f[<span class="number">0</span>][i][<span class="number">0</span>]=<span class="number">1</span>; f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">		<span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;=n;++j)&#123;</span><br><span class="line">			f[i][j][<span class="number">0</span>]%=mod,f[i][j][<span class="number">1</span>]%=mod;</span><br><span class="line">			<span class="keyword">if</span>(j<span class="number">-1</span>&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(j==<span class="number">1</span>) <span class="built_in">fix</span>(f[i+<span class="number">1</span>][j<span class="number">-1</span>][<span class="number">1</span>]+=f[i][j][<span class="number">0</span>]);</span><br><span class="line">				<span class="keyword">else</span> <span class="built_in">fix</span>(f[i+<span class="number">1</span>][j<span class="number">-1</span>][<span class="number">0</span>]+=f[i][j][<span class="number">0</span>]);</span><br><span class="line">				<span class="built_in">fix</span>(f[i+<span class="number">1</span>][j<span class="number">-1</span>][<span class="number">1</span>]+=f[i][j][<span class="number">1</span>]);</span><br><span class="line">				<span class="keyword">if</span>(j==<span class="number">1</span>) <span class="built_in">fix</span>(f[i+<span class="number">1</span>][j][<span class="number">1</span>]+=f[i][j][<span class="number">0</span>]);</span><br><span class="line">				<span class="keyword">else</span> <span class="built_in">fix</span>(f[i+<span class="number">1</span>][j][<span class="number">0</span>]+=f[i][j][<span class="number">0</span>]);</span><br><span class="line">				<span class="built_in">fix</span>(f[i+<span class="number">1</span>][j][<span class="number">1</span>]+=f[i][j][<span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(j+<span class="number">1</span>&lt;=n)&#123;</span><br><span class="line">				<span class="built_in">fix</span>(f[i+<span class="number">1</span>][j+<span class="number">1</span>][<span class="number">0</span>]+=f[i][j][<span class="number">0</span>]);</span><br><span class="line">				<span class="built_in">fix</span>(f[i+<span class="number">1</span>][j+<span class="number">1</span>][<span class="number">1</span>]+=f[i][j][<span class="number">1</span>]);</span><br><span class="line">				<span class="built_in">fix</span>(f[i+<span class="number">1</span>][j][<span class="number">0</span>]+=f[i][j][<span class="number">0</span>]);</span><br><span class="line">				<span class="built_in">fix</span>(f[i+<span class="number">1</span>][j][<span class="number">1</span>]+=f[i][j][<span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;=n;++i) <span class="built_in">fix</span>(ans+=f[m][i][<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>长度为 $n$ 的木板上有 $m$ 个标记点，距离木板左端点的距离分别为 $x_i$ ，在木板上放置一些不相交正方形满足：边长整数，底面紧贴木板，不能超出木板且覆盖所有木板，标记点的位置不能再两正方形交界处，记贡献为所有正方形面积的乘积，求出所有合法方案的贡献和</p>
<p>具体图例见<a href="https://atcoder.jp/contests/agc013/tasks/agc013_e">原题</a></p>
</blockquote>
<p>转化成神仙组合意义：</p>
<ul>
<li>在 $N+1$ 个间隔（包含位置为 $0$ 和 $N$ 的间隔）中放置若干个隔板。</li>
<li>其中位置 $0$ 和 $N$ 必须放置隔板，且有 $M$ 个位置禁止放置隔板。</li>
<li>对于 $N$ 个格子，每个格子中可以放球，蓝球或者红球。</li>
<li>特别满足：在相邻两个隔板间的每个格子中，蓝球数恰为 $1$，红球数恰为 $1$</li>
</ul>
<p>隔板对应正方形边界，对于长度为 $l$ 的段，放一个蓝球一个红球的方案数恰为 $l^2$</p>
<p>对于一种放置隔板的方案，放球的方案数为 $\prod_{i=1}^k (a_i)^2$ ，那么转化为统计放置隔板和球的方案数</p>
<p>设 $f_{i,j}$ 表示考虑前 $i$ 个格子和前 $i+1$ 个间隔，且最后一个隔板右边的球为 $j$ 个时发放置方案数</p>
<p>显然可以写出 $f[i+1]\leftarrow f[i]$ 的转移式子，取决于第 $i+1$ 个格子右侧是否进制放置隔板</p>
<ul>
<li><p>对于非标记点：</p>
<script type="math/tex; mode=display">\begin{aligned}
f_{i+1,0}=f_{i,0}+f_{i,2} \quad &\text{$i$ 与 $i+1$ 之间放/不放隔板}\\
f_{i+1,1}=2\times f_{i,0}+f_{i,1}+2\times f_{i,2} \quad &\text{放隔板仅由 $f_{i,2}$ 转移 $\times$ 红蓝两种颜色+不放隔板，同理有 $2\times f_{i,0}$}\\
f_{i+1,2}=f_{i,0}+f_{i,1}+2\times f_{i,2} \quad &\text{不放的话三种状态都能转移，放的话只有 $f_{i,2}$ 能转移}\\
\end{aligned}</script></li>
<li><p>对于标记点：</p>
<script type="math/tex; mode=display">\begin{aligned}
f_{i+1,0}=f_{i,0} \\
f_{i+1,1}=2\times f_{i,0}+f_{i,1} \\
f_{i+1,2}=f_{i,0}+f_{i,1}+f_{i,2} \\
\end{aligned}</script></li>
</ul>
<p>考虑到上述转移均为常系数齐次线性递推形式，故写成矩阵：</p>
<ul>
<li><p>对于非标记点</p>
<script type="math/tex; mode=display">\begin{bmatrix}
f_{i+1,0} \\ f_{i+1,1} \\ f_{i+1,2} \\
\end{bmatrix}
=
\underbrace{\begin{bmatrix}
1&0&1 \\ 2&1&2 \\1&1&2\\
\end{bmatrix}}_{A}
\times
\begin{bmatrix}
f_{i,0} \\ f_{i,1} \\ f_{i,2} \\
\end{bmatrix}</script></li>
<li><p>对于标记点</p>
<script type="math/tex; mode=display">\begin{bmatrix}
f_{i+1,0} \\ f_{i+1,1} \\ f_{i+1,2} \\
\end{bmatrix}
=
\underbrace{\begin{bmatrix}
1&0&0 \\ 2&1&0 \\1&1&1\\
\end{bmatrix}}_{B}
\times
\begin{bmatrix}
f_{i,0} \\ f_{i,1} \\ f_{i,2} \\
\end{bmatrix}</script></li>
</ul>
<p>即有 $N$ 个 $A$ 矩阵连乘，其中 $M$ 个被替换为 $B$ 矩阵，求一向量乘矩阵的结果</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line">	ll a[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">	<span class="built_in">Matrix</span>()&#123; <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span> a);&#125;</span><br><span class="line">	<span class="keyword">friend</span> Matrix <span class="keyword">operator</span> *(<span class="keyword">const</span> Matrix &amp;x,<span class="keyword">const</span> Matrix &amp;y)&#123;</span><br><span class="line">		Matrix res;</span><br><span class="line">		<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;<span class="number">3</span>;++j) <span class="keyword">for</span>(rei k=<span class="number">0</span>;k&lt;<span class="number">3</span>;++k)</span><br><span class="line">			res.a[i][j]+=x.a[i][k]*y.a[k][j];</span><br><span class="line">		<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;<span class="number">3</span>;++j) res.a[i][j]%=mod;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Matrix A,B,ans;</span><br><span class="line">    ans.a[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	A.a[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;A.a[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;A.a[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">	A.a[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">2</span>;A.a[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;A.a[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">	A.a[<span class="number">2</span>][<span class="number">0</span>]=<span class="number">1</span>;A.a[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">1</span>;A.a[<span class="number">2</span>][<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">	B.a[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;B.a[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;B.a[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">	B.a[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">2</span>;B.a[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;B.a[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">	B.a[<span class="number">2</span>][<span class="number">0</span>]=<span class="number">1</span>;B.a[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">1</span>;B.a[<span class="number">2</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    rei pre=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>,v;i&lt;=m;++i)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;v);</span><br><span class="line">        rei stp=v-pre<span class="number">-1</span>;</span><br><span class="line">		Matrix z=A;</span><br><span class="line">        <span class="keyword">for</span>(;stp;stp&gt;&gt;=<span class="number">1</span>,z=z*z) <span class="keyword">if</span>(stp&amp;<span class="number">1</span>) ans=z*ans;</span><br><span class="line">		ans=B*ans;</span><br><span class="line">        pre=v;</span><br><span class="line">	&#125;</span><br><span class="line">    rei stp=n-pre<span class="number">-1</span>;</span><br><span class="line">	Matrix z=A;</span><br><span class="line">    <span class="keyword">for</span>(;stp;stp&gt;&gt;=<span class="number">1</span>,z=z*z) <span class="keyword">if</span>(stp&amp;<span class="number">1</span>) ans=z*ans;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans.a[<span class="number">2</span>][<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>给定一个有 $n$ 个二元组的数组 $(A,B)$ ，数组 $C$ 包含 $n+1$ 个正整数，有 $q$ 个独立操作，每次向 $(A,B)$ 中加入一个二元组，需要：对 $(A,B)$ 中每个二元组选定一个元素 $L_i$ 为该二元组的值，将 $L,C$ 中的数两两匹配，当 $L$ 能匹配 $C$ 当且仅当 $L_i\leq C_i$ ，若成功，获得的分数为第 $1$ 步中取 $A$ 作为值的二元组的数量，对于每个操作，操作后给出最大可能分数，无解 $-1$</p>
</blockquote>
<p>神仙贪心题qwq</p>
<p>为偷懒，将范围从 $1\sim n+1$ 扩展至 $0\sim n$</p>
<p>由于只需要大小关系，考虑将 $C$ 离散化，假设 $C_i=i-1$ ，考虑 $L$ 是否能与 $0\sim n$ 匹配</p>
<p>一个显然的贪心是：排序后若始终有 $L_i\leq i$ 则成立，把匹配看成括号序列，将 $L_i$ 看成左括号权值 $1$， $i$ 看成右括号权值 $-1$ ，合法序列为前缀和处处非负</p>
<p>可以把 $L_i$ 看成对区间 $[L_i,n)$ 的所有数 $+1$ ，即正覆盖 ；$i$ 对区间 $[i,n)$ 所有数 $-1$ ，即负覆盖</p>
<h3 id="先考虑只有一种情况"><a href="#先考虑只有一种情况" class="headerlink" title="先考虑只有一种情况"></a>先考虑只有一种情况</h3><p>对于二元组 $(A_i,B_i)$ 保证 $B_i\leq A_i$</p>
<p>先固定 $L_i=A_i$ ，做正覆盖，而最终的数中若还有负的，就需要最若干次 $[B_i,A_i)$ 的正覆盖来保证合法</p>
<p>问题转化为：</p>
<blockquote>
<p>给定长度为 $n(0\sim n-1)$ 的序列 ，有 $n$ 个区间 $[B_i,A_i)$ 需要做尽可能少的正覆盖使所有数非负，求这个最小值</p>
</blockquote>
<p>从左到右考虑每个 $x_i&lt;0$ ， 设已经完成 $1\sim i-1$ 的部分，即，不需关心区间的左端点，有贪心：<strong>每次选择当前能覆盖 $i$ ，右端点最右的区间进行正覆盖直到 $x_i\geq 0$</strong> ，正确性显然</p>
<p>考虑用堆来维护右端点，$0\sim n-1$ 枚举左端点 $i$ ，填入可行的右端点，不断选择最右的区间覆盖</p>
<p>若最终仍有负数则无解，否则用 $n$ 减去’额外的正覆盖次数’就是答案</p>
<h3 id="再考虑如何处理多组询问"><a href="#再考虑如何处理多组询问" class="headerlink" title="再考虑如何处理多组询问"></a>再考虑如何处理多组询问</h3><p>对于加入的数组 $(D,E)$ ，称<strong>补给正覆盖</strong>为其对原数组的影响</p>
<p>对于询问的数对，枚举其使用的时左/右侧元素以避免动态覆盖</p>
<p>对于询问的数对，选择正覆盖区间 $[\lambda,n)$ ，会转化为原序列中令 $x_\lambda,…,x_{n-1}$ 都 $+1$ 后的原问题</p>
<p>显然，$\lambda$ 越小，正覆盖的次数就越小，即这个区间只能靠补给正覆盖，即原来的区间正覆盖无法使 $x_i$ 非负</p>
<p>覆盖完后设 $i$ 是最小的满足 $x’_i=-1$ ，则显然必须有 $\lambda\leq i$</p>
<p>先前的正覆盖从左至右进行，现在需要从右至左考虑是否能删去一些正覆盖，仅考虑 $i$ 位置做过正覆盖时</p>
<ul>
<li><p>最终 $x’_i=0$</p>
<p>此时 $[i,n]$ 存在补给正覆盖</p>
<p><strong>每个位置至多去掉一个</strong>，只考虑右端点 $r$ 最小(即1最后一次覆盖)的区间能否删去</p>
<p>即，判断 $[i,r)$ 是否有 $0$ 的地方：</p>
<ul>
<li>$x_i’=-1$ ，在补给正覆盖后 $x_i’=0$</li>
<li>枚举到 $i_0$ 时区间被删去一个，从而 $x_{i_0}’=0$</li>
</ul>
<p>所以枚举当前 $x_i’=0$ 的最左位置，与 $r$ 比较，若删除成功更新最左位置</p>
</li>
<li><p>最终 $x_i=-1$</p>
<p>仅更新最左位置</p>
</li>
</ul>
<p>对于每个 $\lambda \in [0,n)$ 求出补给正覆盖为 $[\lambda,n)$ 时额外正覆盖次数最小值 $ans_{\lambda}$</p>
<p>对每个询问 $(D_i,E_i)$ 答案就是 $n-\min\{ans_D,ans_E\}$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,Q;</span><br><span class="line"><span class="keyword">int</span> c[N],C[N],x[N],last[N],ans[N];</span><br><span class="line"><span class="keyword">int</span> cur=<span class="number">0</span>,cov=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">PII a[N];</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">const</span> <span class="keyword">int</span> y)</span></span>&#123; x&gt;y ? x=y : <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pos</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">lower_bound</span>(x,x+n,val)-x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n),++n;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a[i].first,&amp;a[i].second);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x[i]);</span><br><span class="line">	<span class="built_in">sort</span>(x,x+n);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;n;++i) <span class="built_in">down</span>(a[i].second=<span class="built_in">pos</span>(a[i].second),a[i].first=<span class="built_in">pos</span>(a[i].first));</span><br><span class="line">	<span class="built_in">fill</span>(c,c+n,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;n;++i) ++c[a[i].first],<span class="built_in">swap</span>(a[i].first,a[i].second);</span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>,a+n);</span><br><span class="line">	<span class="keyword">for</span>(rei j=<span class="number">1</span>,i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(cur+=c[i];j&lt;n &amp;&amp; a[j].first==i;++j) q.<span class="built_in">emplace</span>(a[j].second);</span><br><span class="line">        rei r=INF;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>() &amp;&amp; q.<span class="built_in">top</span>()&gt;i &amp;&amp; cur&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            r=q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            ++cur,++cov; --c[r];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>() &amp;&amp; q.<span class="built_in">top</span>()&lt;=i) q.<span class="built_in">pop</span>();</span><br><span class="line">		C[i]=cur,last[i]=r;</span><br><span class="line">		<span class="keyword">if</span>(cur &lt; <span class="number">-1</span>)&#123; flag=<span class="literal">true</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;Q);</span><br><span class="line">	<span class="keyword">if</span>(flag)&#123; <span class="keyword">for</span>(;Q;--Q) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    rei j;</span><br><span class="line">	<span class="keyword">for</span>(rei r=n<span class="number">-1</span>,i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i) ~C[i] ? last[i]&lt;=r&amp;&amp;(r=i,--cov) : (r=j=i) ,ans[i]=cov;</span><br><span class="line">	<span class="built_in">memset</span>(ans+(j+<span class="number">1</span>),<span class="number">63</span>,(n-j+<span class="number">5</span>)&lt;&lt;<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        rei d,e,MIN;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;d,&amp;e),MIN=<span class="built_in">min</span>(ans[ <span class="built_in">pos</span>(d) ],ans[ <span class="built_in">pos</span>(e) ]+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,MIN&gt;=INF ? <span class="number">-1</span> : n-MIN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>构造</tag>
        <tag>dp</tag>
        <tag>贪心</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>32801202-AGC016</title>
    <url>/2021/08/23/AGC016/</url>
    <content><![CDATA[<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>给定一序列 $a$ ，每次操作可以使指定位置的数变成整个序列的异或和，求达到目标序列的最少次数</p>
</blockquote>
<p>设初始时异或和为 $x$ ，转化为每次将 $a_i$ 变为 $x$ 并将 $a_i$ 拿在手上下一次替换</p>
<p>显然有解当且仅当 $a\cup \{x\} \in b$</p>
<p>再考虑替换的过程，<strong>最后一定要用 $b_i$ 替换掉 $a_i$ ，这启发连边 $b_i\rightarrow a_i$ ，再从 $x$ 开始遍历每一条边</strong></p>
<p>如果图是一个包含 $x$ 的连通块，则一定有一条 $1$ 欧拉路径覆盖所有边</p>
<p>如果不连通，或 $x$ 是孤立点/不在连通块内，则答案就是 $边数+连通块数-(x不是孤立点)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],b[N],x;</span><br><span class="line"><span class="keyword">int</span> cnt,edge_cnt,block_cnt;</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line">map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	vis[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> y:G[x]) <span class="keyword">if</span> (!vis[y]) <span class="built_in">dfs</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]),++mp[ a[i] ],x^=a[i];</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]),--mp[ b[i] ];</span><br><span class="line">    ++mp[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it:mp) <span class="keyword">if</span>(it.second&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>),<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;it:mp) it.second=++cnt;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span>(a[i]!=b[i])&#123;</span><br><span class="line">            rei u=mp[ b[i] ],v=mp[ a[i] ];</span><br><span class="line">            G[u].<span class="built_in">push_back</span>(v),G[v].<span class="built_in">push_back</span>(u); ++edge_cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=cnt;++i) <span class="keyword">if</span>(G[i].<span class="built_in">size</span>()) <span class="keyword">if</span>(!vis[i]) ++block_cnt,<span class="built_in">dfs</span>(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,edge_cnt+block_cnt-(!G[ mp[x] ].<span class="built_in">empty</span>()));</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>$2\leq N\leq 400$ 只火鸡， $m$ 个人，每人指定两只火鸡2 $x,y$ ，若两只都活着，则会等概率随机吃掉一只；若只活着一只，则悲吃掉；若都死亡则不做操作。第 $1$ 个人到第 $m$ 个人依次操作，求有多少 $(i,j)$ 满足最终时刻 $i,j$ 可能都活着</p>
</blockquote>
<p>考虑如何使 $i$ 存活：第 $I$ 人选中 $i,j$ 只，则必须让 $j$ 死亡 ，则在第 $1\sim I-1$ 中第 $j$ 只不能死亡</p>
<p>而如果选择了 $(i,j),(i,k)$ 则如果前面的人选择 $(j,k)$ ，则第 $i$ 只必死</p>
<p>对于第 $i$ 只，设 $S_i$ 表示为了使 $i$ 存活需要保护的鸡的编号，从后往前扫到 $(x,y)$ ：</p>
<ul>
<li>初始时 $S_i=\{i\}$</li>
<li>不妨设 $x\in S_i , y\notin S_i$ ，则将 $y$ 加入 $S_i$</li>
<li>若 $x,y\in S_i$ ，则 $i$ 一定会死亡</li>
</ul>
<p>再考虑鸡 $(i,j)$ 的存活：枚举 $i,j$ 并判断 $S_i\cap S_j$ 是否为空</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,ans,x[N],y[N],dead[N];</span><br><span class="line">bitset&lt;410&gt; f[<span class="number">401</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=m;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x[i],&amp;y[i]);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		f[i][i]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(rei j=m;j;--j)&#123;</span><br><span class="line">			rei u=f[i][ x[j] ],v=f[i][ y[j] ];</span><br><span class="line">            u&amp;&amp;v ? dead[i]=<span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">			u ? f[i][ y[j] ]=<span class="number">1</span> : (v ? f[i][ x[j] ]=<span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(dead[i]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span>(rei j=i+<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dead[j]) <span class="keyword">continue</span>;</span><br><span class="line">			ans+=!((f[i]&amp;f[j]).<span class="built_in">count</span>());</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>02801202-AGC014</title>
    <url>/2021/08/20/AGC014/</url>
    <content><![CDATA[<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>$n$ 个顶点的树，初始时每条边为蓝色，执行 $n-1$ 次操作：选定只包含蓝色边的路径 $u\rightarrow v$ ，并移除路径上的某一条蓝边，并加入一条 $u\rightarrow v$ 的红边。问是否能让最终的红树与给定的红树相同</p>
</blockquote>
<p>开始时状态不好考虑，先考虑最后一步操作时：蓝边一定同时存在于蓝树和红树上</p>
<p>可以找到任意一条这样的边，分别在红蓝图上合并两端的点，剩下继续处理子问题</p>
<p>用并查集合并节点，暴力遍历出度数小的点进行启发式合并</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,d[N];</span><br><span class="line">queue&lt;PII&gt; q;</span><br><span class="line">set&lt;<span class="keyword">int</span>&gt; e[N];</span><br><span class="line">map&lt;PII,<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DSU</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> fa[N];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> fa[x]==x ? x : fa[x]=<span class="built_in">find</span>(fa[x]);&#125;</span><br><span class="line">&#125;dsu;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> PII <span class="title">get</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">mk</span>(<span class="built_in">min</span>(x,y),<span class="built_in">max</span>(x,y));&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	e[x].<span class="built_in">insert</span>(y),e[y].<span class="built_in">insert</span>(x);</span><br><span class="line">	PII now=<span class="built_in">get</span>(x,y); ++s[now];</span><br><span class="line">	<span class="keyword">if</span>(s[now]==<span class="number">2</span>) q.<span class="built_in">push</span>(now);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    dsu.<span class="built_in">init</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>,u,v;i&lt;n*<span class="number">2</span><span class="number">-1</span>;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v),<span class="built_in">ins</span>(u,v);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>,x,y;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!q.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>),<span class="number">0</span>;</span><br><span class="line">            PII top=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">			x=dsu.<span class="built_in">find</span>( top.first ),y=dsu.<span class="built_in">find</span>( top.second );</span><br><span class="line">			<span class="keyword">if</span>(x!=y) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(e[x].<span class="built_in">size</span>()&gt;e[y].<span class="built_in">size</span>()) x^=y,y^=x,x^=y;</span><br><span class="line">		dsu.fa[x]=y;</span><br><span class="line">        s.<span class="built_in">erase</span>(<span class="built_in">get</span>(x,y)),e[y].<span class="built_in">erase</span>(x);</span><br><span class="line">		<span class="keyword">for</span>(set&lt;<span class="keyword">int</span>&gt;::iterator it=e[x].<span class="built_in">begin</span>();it!=e[x].<span class="built_in">end</span>();++it)&#123;</span><br><span class="line">			rei t=dsu.<span class="built_in">find</span>(*it);</span><br><span class="line">			<span class="keyword">if</span>(t==y) <span class="keyword">continue</span>;</span><br><span class="line">			s.<span class="built_in">erase</span>(<span class="built_in">get</span>(x,t)); <span class="built_in">ins</span>(t,y);</span><br><span class="line">			e[t].<span class="built_in">erase</span>(x),e[x].<span class="built_in">erase</span>(t);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>给定长度 $n$ 排列 $P$ ，对其进行奇怪排序直至升序：</p>
<p>对于每一轮： 找到序列 $P$ 的所有前缀最大值（ $P_i$ 为前缀最大值当且仅当 $\forall 1\leq j\leq i \quad 有 P_j\leq P_i$），取出所有前缀最大值并按照原顺序移到队尾</p>
<p>求至少需要多少轮才能对 $P$ 排序</p>
</blockquote>
<p>定义 $high$ 为前缀最大值, $low$ 为前缀最小值</p>
<p>假设忽略 $1$ ，用 $T$ 次排列好 $[2,n]$ ，答案就是 $T/T+1$</p>
<p>考虑 $T-1$ 轮后序列状态：设 $f$ 为第一个数，如果 $1$ 出现在 $f,2$ 之间则答案为 $T$ ，否则为 $T-1$</p>
<ul>
<li><p>结论 $1$ : $f$ 不会出现：不在第一个位置且为 $high$ 的情况</p>
<p>反证法易得</p>
</li>
<li><p>结论 $2$ : 定义循环序列 $(a,b,c)=(b,c,a)=(c,a,b)$ ，则 $1,2,f$ 在前 $T-1$ 次组成的，关于位置的循环序列不变</p>
</li>
</ul>
<p>考虑 $[i,n]$ ，设 $T_i$ 为对该序列排序需要的操作数</p>
<p>设 $f_i$ 为 $T_i-1$ 次操作后的第一个整数 ，$q_i$ 为 $i$ 在初始序列中的位置( $p_{q_i}=i$ ) 。按照 $i=n\sim 1$ 的顺序计算 $T_i,f_1$ ，答案就为 $T_1$</p>
<ul>
<li>若 $T_{i+1}=0$<ul>
<li>若 $q_i&gt;q_{i+1}$ ，则 $T_i=1,f_i=i+1$</li>
<li>否则 $T_i=0,f_i无$</li>
</ul>
</li>
<li>否则<ul>
<li>若 $q_{f_{i+1}},q_i,q_{i+1}$ 处于循环顺序，则 $T_i=T_{i+1},f_i=f_{i+1}$</li>
<li>否则 $T_i=T_{i+1}+1,f_i=i+1$</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> q[N],p[N],n,T[N],f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p[i]),q[ p[i] ]=i;</span><br><span class="line">	<span class="keyword">for</span>(rei i=n<span class="number">-1</span>;i;--i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!T[i+<span class="number">1</span>])</span><br><span class="line">			<span class="keyword">if</span>(q[i]&gt;q[i+<span class="number">1</span>]) T[i]=<span class="number">1</span>,f[i]=i+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> T[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			rei cnt=<span class="number">0</span>;</span><br><span class="line">			cnt+=q[ f[i+<span class="number">1</span>] ]&lt;q[i];</span><br><span class="line">			cnt+=q[i]&lt;q[i+<span class="number">1</span>];</span><br><span class="line">			cnt+=q[i+<span class="number">1</span>]&lt;q[ f[i+<span class="number">1</span>] ];</span><br><span class="line">			<span class="keyword">if</span>(cnt==<span class="number">2</span>) T[i]=T[i+<span class="number">1</span>],f[i]=f[i+<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">else</span> T[i]=T[i+<span class="number">1</span>]+<span class="number">1</span>,f[i]=i+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,T[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>构造</tag>
        <tag>贪心</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title>CF的dp题</title>
    <url>/2021/07/01/CF%E7%9A%84dp%E9%A2%98/</url>
    <content><![CDATA[<h2 id="CF1515E-Phoenix-and-Computers"><a href="#CF1515E-Phoenix-and-Computers" class="headerlink" title="CF1515E Phoenix and Computers"></a>CF1515E Phoenix and Computers</h2><details>
    <summary>我们始终不知道EI是怎么写的</summary>
        <pre><code>
        #include<bits/stdc++.h>
        #define R(X,Y) X=(X+Y)%P;
        int64_t g[410],n,P,k,a,f;int main()&#123;std::cin>>n>>P;g[0]=f=k=1;for(--n;n>=0;n-=2,++k)&#123;for(int i=1;i<=n;++i)R(g[i],g[i-1]*k*2)f=f*k%P;R(a,g[n]*f)&#125;printf("%d\n",a);&#125;
        </code></pre>
</details>


<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>要开启 $n$ 台电脑，若第 $i-1,i+1$ 台被开启，第 $i$ 台自动开，询问打开所有电脑的方案数</p>
<h3 id="解"><a href="#解" class="headerlink" title="解"></a>解</h3><p>题解里有一个吊打标算的 $O(n^2)$ 做法</p>
<p><del>上面EI的代码好像也是 $O(n^2)$</del></p>
<p>设 $dp_{i,j}$ 表示已开机 $i$ 台，形成 $j$ 个连续段，每段距离 $&gt;1$ 且不确定</p>
<p>考虑转移：</p>
<ul>
<li><p>新建段</p>
<ul>
<li>$dp_{i+1,j+1}=\sum dp_{i,j}*(j+1)$ ，即在 $j+1$ 个间隔中选择一个打开</li>
</ul>
</li>
<li><p>扩展段</p>
<ul>
<li>$dp_{i+1,j}=\sum dp_{i,j}\cdot j\cdot2$ ，即在一段的边界+1处开</li>
<li>$dp_{i+2,j}=\sum dp_{i,j}\cdot j\cdot2$ ，即在一段的边界+2处开</li>
</ul>
</li>
<li><p>合并段（仅当 $j\geq 2$ 时）</p>
<ul>
<li>$dp_{i+2,j-1}=\sum dp_{i,j}\cdot(j-1)\cdot2$ ，即当两边距离为 $2$ 时有两种开法</li>
<li>$dp_{i+3,j-1}=\sum dp_{i,j}\cdot (j-1)$ ，即两边距离为 $3$ 时开中间</li>
</ul>
</li>
</ul>
<h2 id="CF1516D-Cut"><a href="#CF1516D-Cut" class="headerlink" title="CF1516D Cut"></a>CF1516D Cut</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定长度为 $n$ 的序列，$q$ 次询问，对于 $[l,r]$ 区间最少能分成多少个子序列满足，子序列中数的乘积等于它们的 $\text{lcm}$</p>
<h3 id="解-1"><a href="#解-1" class="headerlink" title="解"></a>解</h3><p>很显然子序列中所有数互质，有贪心：从左往右尽可能多的选取直至会加入与原区间不互质的数</p>
<p>设 $Next_i$ 代表从 $i$ 开始的序列停止的位置，即向以 $i$ 开始的子序列中加入 $Next_i$ 会使序列中的数不再互质</p>
<p>$dp_{i,l}$ 表示从 $l$ 开始，跳 $Next_i$ $2^i$ 次到达的位置</p>
<h2 id="CF1516E-Baby-Ehab-Plays-with-Permutations"><a href="#CF1516E-Baby-Ehab-Plays-with-Permutations" class="headerlink" title="CF1516E Baby Ehab Plays with Permutations"></a>CF1516E Baby Ehab Plays with Permutations</h2><h3 id="前置芝士"><a href="#前置芝士" class="headerlink" title="前置芝士"></a>前置芝士</h3><ul>
<li><p>置换</p>
<p>简单来说是对一个序列进行重排列，</p>
<script type="math/tex; mode=display">\begin{pmatrix}
1 & 2 & 3 & \dotsb & i & \dotsb & n \\
a_1 & a_2 & a_3 & \dotsb & a_i & \dotsb & a_n\\
\end{pmatrix}</script><p>即 $[1,n]$ 到 $[1,n]$ 的一一映射</p>
<ul>
<li><p>$1.$</p>
<p>置换可以分解为若干循环，具体为连边：$1\rightarrow a_1 \ ,\ 2\rightarrow a_2 \ ,\ \dotsb \ ,\ i\rightarrow a_i \ ,\ \dotsb \ ,\ n\rightarrow a_n$</p>
<p>形成的图中会有若干个环，即，置换可以被分解成不相交循环的积</p>
<p>一个循环可以被拆成 $环长-1$ 个对换，所以通过 $环长-1$ 步可以还原该循环</p>
</li>
</ul>
</li>
<li><p>关于第一类斯特林数的计算</p>
<p><a href="https://mathworld.wolfram.com/StirlingNumberoftheFirstKind.html">$\displaystyle{s(n,m)=\sum_{k=0}^NaN \  (-1)^ k\ \binom{k+n-1}{k+n-m} \binom{2n-m}{n-k-m} S(k-m+n,k)}$</a></p>
<p>变形得</p>
<script type="math/tex; mode=display">(-1)^{n-m} s(n,m)=\sum_{k=0}^{n-m} (-1)^k \binom{n-1+k}{m-1} \binom{(n-m)+n}{(n-m)-k} S((n-m+k),k)</script><p>即</p>
<script type="math/tex; mode=display">(-1)^{n-m} \begin{bmatrix} n \\ m \end{bmatrix}=\sum_{k=0}^{n-m} (-1)^k \binom{n-1+k}{m-1} \binom{(n-m)+n}{(n-m)-k} \begin{Bmatrix} (n-m)+k \\ k \end{Bmatrix}</script></li>
</ul>
<h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给出长为 $n$ 的序列 $p$ 满足 $p_i=i$，进行 $k$ 次操作，每次可以选取序列中两个位置并交换，对于 $1\sim k$ 的每个值，输出最终可能有几个序列</p>
<h3 id="解-2"><a href="#解-2" class="headerlink" title="解"></a>解</h3><p>$dp$ 方程难以表达，不能直接求出总排列数</p>
<p>反向思考，求经过 $k$ 次交换后恰好能排好序的排列数</p>
<p>由置换与群可知，若该排列 $p$ 中有 $c$ 个循环，需要 $n-c$ 步来还原</p>
<p>$\therefore$ 需要 $k$ 来还原的排列中存在 $n-k$ 个循环</p>
<p>由第一类斯特林数定义可知，满足条件的排列数就是 $\begin{bmatrix}n \\ n-k\end{bmatrix}$</p>
<p>$\therefore$ 对于 $1\sim k$ 的询问，答案依次为</p>
<script type="math/tex; mode=display">\begin{bmatrix}n\\n-1\end{bmatrix} ,\begin{bmatrix}n\\n\end{bmatrix}+\begin{bmatrix}n\\n-2\end{bmatrix} , \begin{bmatrix}n\\n-1\end{bmatrix}+\begin{bmatrix}n\\n-3\end{bmatrix}\dotsb</script><p>然而由于递推求斯特林数 $O(n^2)$，由于 $k\leq 200$，当 $n-m$ 较小时，利用上方的求值公式 $O(k^2)$ 求第二类斯特林数，再 $O(n^3)$ 求第一类</p>
<h2 id="CF1521D-Nastia-Plays-with-a-Tree"><a href="#CF1521D-Nastia-Plays-with-a-Tree" class="headerlink" title="CF1521D Nastia Plays with a Tree"></a>CF1521D Nastia Plays with a Tree</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给定一颗树，每次操作删去任意一条边并加上任意一条边，求多少次操作后会形成一条链，输出次数及任一方案</p>
<h3 id="解-3"><a href="#解-3" class="headerlink" title="解"></a>解</h3><p>设答案为 $x$</p>
<p>则删去树上的 $x$ 条边并加上新的 $x$ 条边会构成链</p>
<p>把删去与添加分开看，在删去 $x$ 条边后会形成一个 $x+1$ 棵树的森林，若添加 $x$ 条边能合并为链，则森林由 $x+1$ 条链构成</p>
<p>转化为找到最少分割次数使这棵树形成全为链的森林</p>
<p>设当前在处理点 $i$ ，其有 $c_i$ 个儿子，父节点为 $fa_i$</p>
<ul>
<li>若 $c_i\leq 1$ ，不需任何操作</li>
<li>若 $1\leq c_i \leq2$ ，断开 $i$ 与 $fa_i$ 的关系</li>
<li>若 $c_i &gt;2$ ，不仅断开 $i$ 与 $fa_i$ ，且断开 $i$ 的任意儿子直至 $c_i\leq 2$</li>
</ul>
<p>实现的时候注意边的存储</p>
<h2 id="CF1523D-Love-Hate"><a href="#CF1523D-Love-Hate" class="headerlink" title="CF1523D Love-Hate"></a>CF1523D Love-Hate</h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>有 $n$ 个人，$m$ 种货币，每个人只喜欢其中不超过 $p$ 种货币，求一种选货币的方案，使选的每一种货币都喜欢的人数不小于 $\lceil\frac{n}{2}\rceil$</p>
<h3 id="解-4"><a href="#解-4" class="headerlink" title="解"></a>解</h3><p>先去除喜欢人数 $&lt;\lceil\frac{n}{2}\rceil$ 的货币，将枚举的货币状态降至 $2^30$，用 $\text{bitset}$ 存喜欢每一种货币的人的状态，暴力搜索并减去不合法的即可</p>
<h2 id="CF1525E-Assimilation-IV"><a href="#CF1525E-Assimilation-IV" class="headerlink" title="CF1525E Assimilation IV"></a>CF1525E Assimilation IV</h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>给定一些城市与点两两之间距离</p>
<p>每回合随机选择一个城市设立纪念碑，辐射范围随回合数增加而增加，即第 $1$ 回合设立的，在第 $2$ 回合可以辐射到与之距离 $\leq 2$ 的所有点</p>
<p>求所有城市设立纪念碑后所有被辐射到的点的期望值</p>
<h3 id="解-5"><a href="#解-5" class="headerlink" title="解"></a>解</h3><p>分开算每个点的期望值</p>
<p>若直接求能辐射到该点的城市则情况不易讨论，考虑求补集</p>
<p>对于每个点，不被辐射到需要满足：对于第 $1$ 回合选择距离在 $n+1$ 以外的点，其余回合同理</p>
<p>那么把城市选择顺序视为一个排列，求出不能到达的方案数，最后 $1-$ 并 $\div n!$ 求期望即可</p>
<h2 id="CF1527E-Partition-Game"><a href="#CF1527E-Partition-Game" class="headerlink" title="CF1527E Partition Game"></a>CF1527E Partition Game</h2><h3 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h3><p>定义连续子序列 $t$ 的代价是</p>
<script type="math/tex; mode=display">cost(t)=\sum_{t\in set(t)} last(x)-first(x)</script><p>$set$ 表示子序列的元素集合，$last,first$ 表示 $x$ 在子序列中最后/第一次出现的位置</p>
<p>给定长度 $n$ 的序列，分成 $k$ 个<strong>连续的</strong>子序列，求 $\min cost$</p>
<h3 id="解-6"><a href="#解-6" class="headerlink" title="解"></a>解</h3><p>显然有 $O(kn^2\log n)$ 的朴素转移：</p>
<script type="math/tex; mode=display">dp_{i,j}=\min \limits_{k<j}(dp_{i-1,k}+c_{k+1,j})</script><p>含义明显</p>
<p>考虑优化 $cost$ 的计算过程</p>
<p>首先，$cost$ 具有决策单调性，即 $cost(i,j)+cost(i+1,j+1) \leq cost(i+1,j)+cost(i,j+1)$</p>
<p>证明不是太会，可以枚举一下最优情况分别位于 $(i,j),(i,j+1),(i+1,j),(i+1,j+1)$ 时，能得出结论：右边的总会优于左边</p>
<p>得到决策单调性后考虑分治，枚举 $dp_{mid}$ 的最优决策点</p>
<p>即用 $\text{solve}(l,r,x,y)$ 计算区间 $[l,r]$ ，最优决策点在 $[x,y]$ 间的所有 $dp_i$</p>
<p>对于 $\text{calc}$ 每次调用的时候左端点单增 $\Rightarrow$ 考虑移动双指针指向队首队尾，每次 $O(1)$ 暴力转移</p>
<p><del>也可以用deque当懒狗</del></p>
<h2 id="CF1535E-Gold-Transfer"><a href="#CF1535E-Gold-Transfer" class="headerlink" title="CF1535E Gold Transfer"></a>CF1535E Gold Transfer</h2><p>十分显然的题</p>
<p>题面中 $It’s \ guaranteed \ that \ p_i \ exists \ and \ c_i&gt;c_{p_i}.$ 表明从越靠近根节点开始买值越小</p>
<p>倍增跳 $anc$ 时检查是否有值即可</p>
<h2 id="CF1539E-Game-with-Cards"><a href="#CF1539E-Game-with-Cards" class="headerlink" title="CF1539E Game with Cards"></a>CF1539E Game with Cards</h2><h3 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h3><p>两个数 $a,b$ 初始为 $0$</p>
<p>进行 $n$ 次操作，每次用 $k$ 去替换 $a,b$ 中任意一个，要求操作后满足 $a_{l,i} \leq a \leq b_{l,i} , a_{r,i} \leq b \leq b_{r,i}$</p>
<p>输出是否可以完成所以操作，若可以，输出任一方案</p>
<h3 id="解-7"><a href="#解-7" class="headerlink" title="解"></a>解</h3><p>先考虑朴素做法</p>
<p>设 $dp_{L,i,j}=1$ 表示第 $i$ 张牌替换左手，第 $j$ 张是上一张用来替换右手的牌</p>
<p>$dp{R,i,j}=1$表示第 $i$ 张牌替换右手，第 $j$ 张是上一张用来替换左手的牌</p>
<p>由于只判断可行性，所以不需要存下所有的 $dp$ 状态，用 $集合f_0 = \left\langle k[j],j\right\rangle$存下 $dp_{L,i,j}=1$ 的情况，$f_1$ 同理</p>
<p>考虑 $f_0 [i]$ 与 $f_1 [i]$ 的计算 $\Rightarrow$ 先考虑 $f_0 [i+1]$ , $f_1 [i+1]$ 同理</p>
<p>先假设第 $i+1$ 张卡可以给左手（确保 $f_0 [i+1]$ 不空） ，且第 $i+1$ 回合右手可以替换为任意卡（稍后再处理）</p>
<p>若 $f_1 [i]$ 不空，可以将 $\langle k[i],i\rangle$ 添加到 $f_0 [i+1]$ 中，即左手拿第 $i+1$ 张使状态 $(j(上一次改变的),i) \Rightarrow (i+1,i)$</p>
<p>同时 $f_0 [i+1]$ 会继承 $f_0 [i]$ 的状态，即 $(i,j) \Rightarrow (i+1,j)$</p>
<p>转移后处理那些无法被成功转移的，由于 $set$ 结构，分别从 $\min$ 和 $\max$ 来 $erase$ 那些 $\leq l$ 或 $\geq r$ 的 $pair$</p>
<h2 id="CF1540B-Tree-Array"><a href="#CF1540B-Tree-Array" class="headerlink" title="CF1540B Tree Array"></a>CF1540B Tree Array</h2><h3 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h3><ul>
<li><p>一颗树，开始时从中等概率选择一点，随后每次等概率选择一点不与选择过的点重复且与任一选择的点相连。</p>
</li>
<li><p>点编号按选择的先后顺序排序，求期望逆序对数</p>
</li>
</ul>
<hr>
<h3 id="解-8"><a href="#解-8" class="headerlink" title="解"></a>解</h3><p>考虑开始时随机选点，显然可以枚举每一点作为根，求出期望值后 $\div n$ 得到</p>
<p>求每个序列中的期望逆序对数，并不需要知道每个序列，即考虑每一对逆序对</p>
<p>设逆序点对为 $(x,y)$ ，其中 $y&gt;x$，当沿树向下进行时，直到 $x,y$ 的 $lca$ 之前概率相等，所以只需要考虑从 $lca$ 到 $x,y$ 两点的概率，即从 $lca$ 先到 $x$ 的概率</p>
<p>参照官方题解，转化成以下模型</p>
<p>存在两个栈，每次有 $p$ 概率弹出 $栈1$ 中的一个，$p$ 的概率弹出 $栈2$ 中的一个，还有 $1-2*p$ 的概率不做任何操作</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/tozqrh74.png" alt=""></p>
<p>既然满足到 $x,y$ 的概率相等，则可以由上方的值 $\div 2$ 推出</p>
<p>所以可以写出式子</p>
<script type="math/tex; mode=display">dp_{i,j}=\frac{dp_{i-1,j}+dp_{i,j-1}}{2}</script><p>其中 $i,j$ 表示逆序点对与 $lca$ 的距离</p>
<p>$dp_{0,j}=1$ ，即 $i$ 位置代表的点先被到达时会形成逆序点对</p>
<p>至此，流程为：预处理 $dp_{i,j}$ $\Rightarrow$ 枚举根 $\Rightarrow$ 枚举逆序点对并统计 $dp$ 值 $\Rightarrow$ 总值 $\div n$ 得到概率（期望，这里说不清了）</p>
<h2 id="CF1510D-Digits"><a href="#CF1510D-Digits" class="headerlink" title="CF1510D Digits"></a>CF1510D Digits</h2><h3 id="题意-8"><a href="#题意-8" class="headerlink" title="题意"></a>题意</h3><p>给定 $n$ 个数，求能使其中一些数使其乘积最大且最后一位以 $d$ 结尾</p>
<p>输出具体方案</p>
<hr>
<h3 id="解-9"><a href="#解-9" class="headerlink" title="解"></a>解</h3><p>一个显然的想法是令 $d_{i,j}$ 表示前 $i$ 个数,末位为 $j$ 的最大乘积, $dp$ 转移的时候记录路径即可,可惜会爆 $ll$</p>
<p>一个在模拟赛里见过的 $trick$ 是使用对数</p>
<p>如果 $a&gt;b$ , 那么 $\log(a)&gt;\log(b)$ ,且 $\log(a\times b)=\log(a)+\log(b)$ ,转换成了加法</p>
<p>$\therefore$ 只需记录最大的和</p>
<p>令 $d_{i,j}$ 表示前 $i$ 个数,末位为 $j$ 的最大乘积的 $\log$ 值, $dp$ 转移的时候记录路径即可.</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>dp</tag>
        <tag>贪心</tag>
        <tag>数论</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title>12801202-AGC015</title>
    <url>/2021/08/21/AGC015/</url>
    <content><![CDATA[<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>给定正整数 $A,B \quad (1\leq A,B\leq 2^{60})$ ，令 $S=\{A,A+1,A+2,…,B-1,B\}$ ，求 $S$ 的所有非空子集的元素按位或的结果有多少不同取值</p>
</blockquote>
<p>首先有 $A=B$ 时答案为 $1$</p>
<p>设 $AB$ 最高的不一样的位为第 $b$ 位，则 $A$ 的第 $b$ 位一定为 $0$ ， $B$ 的第 $b$ 位一定是 $1$</p>
<p>考虑比 $b$ 高的那些位，无论取 $S$ 中的哪些数，其比 $b$ 高的位结构相同，或的结果也相同，所以不必考虑这些位，只考虑前 $b$ 位</p>
<p>设 $U$ 在第 $b$ 位为 $0$ ，$b-1\sim 1$ 位为 $1$ ； $V$ 在第 $b$ 位为 $1$ ，$b-1\sim 1$ 位为 $0$</p>
<p>$S$ 子集或的结果有：</p>
<ul>
<li><p>第 $b$ 位为 $0$</p>
<p>只能使用 $A\sim U$ 的元素，设 $T=\{A,A+1,…,U\}$ ，或的结果（或闭包）显然包含 $T$</p>
<p>又由于 $a\mid b\geq \max(a,b)$ 所以或闭包中所有元素均 $\geq A$ ，且 $T$ 中所有数值可能为 $1$ 的位只有 $0,1,…,b-1$ 位，于是结果的每个数中，值为 $1$ 的为是这些位的子集，所以它们 $\leq T$</p>
<p>综上， $T$ 就是 $T$ 的或闭包，共 $|T|$ 个</p>
</li>
<li><p>第 $b$ 位为 $1$</p>
<p>首先，$T\cup \{V\}$ 的或闭包中，考虑第 $b$ 位为 $1$ 的元素，和上面类似可知是 $\{V+A,V+A+1,…,V+U\}=[V+A,2V)$ 而它们的或闭包是 $[V,2V)$ ，即 $\left[2^b,2^{b+1}\right)$ 的子集，于是剩下的元素只有 $[V,V+A)$</p>
<p>考虑「或闭包」在这个区间中的表现</p>
<p><strong>注意此时不能使用 $T$ 中的元素</strong></p>
<p>于是，只需要考虑 $V\sim B$ 中的元素，而这是原问题的一个子问题。从而，我们把 $V$ 和 $B$ 相同的位删掉 —— 即找到 $B$ 中除了 $b$ 外最高为 $1$ 的位，记为 $d$</p>
<p>它们的或闭包就是 $\left[0,2^{d+1}\right)$ ，这部分的贡献就是 $\left[V,V+2^{d+1}\right)$</p>
<p>综上，该部分答案就是 $\left[V,V+2^{d+1}\right)\cup [V+A,2V)$</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> b, d; ll L, R;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">doz</span><span class="params">(ll x)</span></span>&#123; <span class="keyword">return</span> ~(x&gt;&gt;<span class="number">63</span>)&amp;x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;L,&amp;R);</span><br><span class="line">	<span class="keyword">if</span>(L==R) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>),<span class="number">0</span>;</span><br><span class="line">	b=__lg(L^R),L&amp;=~(<span class="number">-2ll</span>&lt;&lt;b),R&amp;=~(<span class="number">-1ll</span>&lt;&lt;b),d=R ? __lg(R)+<span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(<span class="number">2ll</span>&lt;&lt;b)-L-<span class="built_in">doz</span>(L-(<span class="number">1ll</span>&lt;&lt;d)));</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>数轴上有 $N$ 个点，每个点初始时在位置 $X_i$ ，以 $V_i$ 的速度向数轴正方向前进。 初始时刻，选择一些点为其染色，之后的行走过程中，染色的点会将其碰到的所有点都染上色，之后被染上色的点亦是如。此<br>在所有 $2^N$ 种初始染色方案中，问有多少种初始染色方案，能使得最终所有的点都被染色</p>
</blockquote>
<p>按 $x_i$ 将所有点排序，第 $i$ 个点被选中后，对于 $j<i且v_j>v_i 和 j&gt;i且v_j<v_i$ 的点会被直接打上标记，而对于 $j>i,v_j\leq \max_{k\leq i} v_k$ 的点都会被间接打上标记</p>
<p>考虑初始时最靠右的标记点 $i$ ，由于 $i$ 对右侧影响最强，故点 $j,j&lt;i$ 被打标记当且仅当 $v_j\max{k\leq i} \ v_k$ 。只需要确保 $[1,i-1]$ 的点使 $j&lt;i,v_j&lt;\min_{k\geq i} \ v_k$ 的点都被打标记</p>
<p>设 $f_i$ 表示操纵 $[1,i-1]$ 的点使 $j&lt;i ,v_j&lt;\min_{k\geq i} \ v_k$ 的点都被打标记的方案数， 设 $j$ 是初始时 $[1,i-1]$ 内最靠右被打上标记的点，满足 $\max_{j&lt;k&lt;i\ ,\ v_k&lt;\min_{t\geq i}\ v_t} \ v_k&lt;\max_{1\leq k\leq j} \ v_k$</p>
<p>考虑用 $f_j$ 转移：合法的 $j$ 是一段右端点为 $i$ 的区间，考虑左端点：设 $mx$ 表示最大的 $mx$ 满足 $mx&lt;i,v_{mx}&lt;\min_{t\leq i} \ v_t$ 的 $v_{mx}$</p>
<p>对于 $v_{mx}$ 可以作为 $j$ 左侧只需要考虑 $\max_{1\leq k\leq j} \ v_k&gt;v_{mx}$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>,INF=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> x,<span class="keyword">const</span> <span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">return</span> x+y&lt;mod ? x+y : x+y-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dec</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> x,<span class="keyword">const</span> <span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">return</span> x&lt;y ? x-y+mod : x-y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,f[N],sf[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,v;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node &amp;a,<span class="keyword">const</span> node &amp;b)&#123; <span class="keyword">return</span> a.x&lt;b.x;&#125;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="keyword">int</span> id[N];</span><br><span class="line"><span class="keyword">int</span> premn[N],sufmn[N],premx[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">return</span> a[x].v&lt;a[y].v;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a[i].x,&amp;a[i].v);</span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">	premn[<span class="number">0</span>]=sufmn[n+<span class="number">1</span>]=INF;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) premn[i]=<span class="built_in">min</span>(premn[i<span class="number">-1</span>],a[i].v);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) premx[i]=<span class="built_in">max</span>(premx[i<span class="number">-1</span>],a[i].v);</span><br><span class="line">	<span class="keyword">for</span>(rei i=n;i&gt;=<span class="number">1</span>;--i) sufmn[i]=<span class="built_in">min</span>(sufmn[i+<span class="number">1</span>],a[i].v);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i) id[i]=i;</span><br><span class="line">	<span class="built_in">sort</span>(id+<span class="number">1</span>,id+n+<span class="number">1</span>,cmp);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>,j=<span class="number">1</span>,p1=<span class="number">0</span>,p2=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i!=<span class="number">1</span>) <span class="keyword">if</span>(a[i<span class="number">-1</span>].v&lt;sufmn[i]) <span class="keyword">if</span>(!p1 || a[i<span class="number">-1</span>].v&gt;a[p1].v) p1=i<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">while</span>(j&lt;=n &amp;&amp; a[ id[j] ].v&lt;sufmn[i])&#123;</span><br><span class="line">			<span class="keyword">if</span>(id[j]&lt;i) <span class="keyword">if</span>(!p1||a[ id[j] ].v&gt;a[p1].v) p1=id[j];</span><br><span class="line">			++j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(p2&lt;=n &amp;&amp; a[p2].v&lt;a[p1].v) ++p2;</span><br><span class="line">		<span class="keyword">if</span>(p1)&#123;</span><br><span class="line">			rei p=<span class="built_in">min</span>(p2,p1);</span><br><span class="line">			f[i]=<span class="built_in">dec</span>(sf[i<span class="number">-1</span>],sf[p<span class="number">-1</span>]);</span><br><span class="line">			sf[i]=<span class="built_in">add</span>(sf[i<span class="number">-1</span>],f[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> f[i]=<span class="built_in">add</span>(sf[i<span class="number">-1</span>],<span class="number">1</span>);</span><br><span class="line">		sf[i]=<span class="built_in">add</span>(sf[i<span class="number">-1</span>],f[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[n+<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>定义 $E(x,y)$ 是对 $x,y$ 进行 $\text{Euclid}$ 算法需要的步数。其中 $E(a,b)=E(b,a) \forall a,b\in \N$ ; $E(0,a)=0$ ; 若 $0&lt;a\leq b$ ，则 $E(a,b)=E(b\mod a,a)+1$ 。 有多次询问，每次给定 $x,y\in \N^+$ 求出 $\displaystyle{M=\max_{1\leq x\leq X} \max_{1\leq y\leq Y} E(x,y)}$ 以及 $\displaystyle{C_M=\sum_{x=1}^X\sum_{y=1}^Y [E(x,y)=M]}$</p>
</blockquote>
<p>只会打表找结论，具体的数学过程参见yhx的博客</p>
<ul>
<li><p>结论 $1$ :</p>
<p>$f(Fib(x),Fib(x+1))=x$ ，且不存在 $i,j \forall i,j\in \N 使 f(i,j)\geq x,i&lt;Fib(x),j&lt;Fib(x+1)$</p>
</li>
<li><p>结论 $2$ :<br>定义一个二元组 $(x,y)$ 是好的，当且仅当 不存在 $(i,j)$ 满足 $i<x,j<y,f(i,j)>f(x,y)$</p>
<p>一个二元组 $(x,y)$ 是优秀的，当且仅当 $x,y\leq Fib(v+2)+Fib(v-1)$ ，其中 $v=f(x,y)$</p>
<p>那么：<strong>一个好的二元组进行一次 $\text{Euclid}$ 后一定变为一个优秀二元组</strong>，反证法易得</p>
</li>
</ul>
<p>预处理所有优秀二元组就好qwq</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;PII&gt; t[N];</span><br><span class="line"><span class="keyword">int</span> n,m,q,f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    t[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="built_in">mk</span>(<span class="number">1</span>,<span class="number">2</span>)),t[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="built_in">mk</span>(<span class="number">1</span>,<span class="number">3</span>)),t[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="built_in">mk</span>(<span class="number">1</span>,<span class="number">4</span>));</span><br><span class="line">    f[<span class="number">0</span>]=f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;=<span class="number">100</span>;++i) f[i]=f[i<span class="number">-1</span>]+f[i<span class="number">-2</span>];</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;++i)</span><br><span class="line">        <span class="keyword">for</span>(rei j=<span class="number">0</span>,l=t[i].<span class="built_in">size</span>()<span class="number">-1</span>;j&lt;=l;++j)&#123;</span><br><span class="line">            rei x=t[i][j].second,y=t[i][j].first+x;</span><br><span class="line">            <span class="keyword">while</span>(y&lt;=f[i+<span class="number">3</span>]+f[i]) t[i+<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="built_in">mk</span>(x,y)),y+=x;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;m); <span class="keyword">if</span>(n&gt;m) n^=m,m^=n,n^=m;</span><br><span class="line">        rei pos=<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(f[pos+<span class="number">1</span>]&lt;=n &amp;&amp; f[pos+<span class="number">2</span>]&lt;=m) ++pos;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,pos);</span><br><span class="line">        <span class="keyword">if</span>(pos==<span class="number">1</span>)&#123; <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n%mod*m%mod); <span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">for</span>(rei j=<span class="number">0</span>,l=t[pos<span class="number">-1</span>].<span class="built_in">size</span>()<span class="number">-1</span>;j&lt;=l;++j)&#123;</span><br><span class="line">            rei x=t[pos<span class="number">-1</span>] [j].first,y=t[pos<span class="number">-1</span>][j].second;</span><br><span class="line">            <span class="keyword">if</span>(y&lt;=n) ans=(ans+(m-x)/y)%mod;</span><br><span class="line">            <span class="keyword">if</span>(y&lt;=m) ans=(ans+(n-x)/y)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>构造</tag>
        <tag>dp</tag>
        <tag>数论</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>min-max容斥</title>
    <url>/2020/12/04/minmax%E5%AE%B9%E6%96%A5/</url>
    <content><![CDATA[<h2 id="minmax容斥"><a href="#minmax容斥" class="headerlink" title="minmax容斥"></a>minmax容斥</h2><ul>
<li><p>用途</p>
<p>已知集合的最小值 (<strong>期望</strong>) 求最大值</p>
<p>$eg:$ $n$ 个元素，每个元素出现概率 $p_i$，求每个元素都出现的期望时间</p>
</li>
<li><p>结论</p>
<script type="math/tex; mode=display">\max\{S\}=\sum_{T\subset S}(-1)^{|T|+1} \min\{T\}</script><p>即</p>
<script type="math/tex; mode=display">E\left(\max\{S\}\right)=\sum_{T\subset S}(-1)^{|T|+1} E\left(\min\{T\}\right)</script></li>
<li><p>证明</p>
<p>设容斥系数 $g\left(|T|\right)$</p>
<p>即 $\displaystyle{\max\{S\}=\sum_{T\subset S}g\left(|T|\right) \min\{T\}}$</p>
<p>考虑当排名为 $k$ 的数作为集合 $T$ 的最小值时，集合 $T$ 中所有值都 $\geq k$</p>
<p>所以对于第$k$大数 ， 在大小为 $|T|$ 的集合中， $\max$ 的选取方案为 $\displaystyle{\binom{k-1}{|T|-1}}$</p>
<p>考虑集合大小为 $1\sim k$ ，则第 $k$ 数的总贡献为</p>
<p>$\displaystyle{\sum_{i=1}^k \binom{k-1}{i-1}} * g(i)=[k=1] \qquad \text{即只有最大值对 max 有贡献}$</p>
<p>由二项式反演得</p>
<script type="math/tex; mode=display">\begin{aligned}
g(k)&=\sum_{i=1}^k (-1)^{k-i} \binom{k-1}{i-1} [i=1] \\
&=(-1)^{k+1} \\
\end{aligned}</script><span id="more"></span>
</li>
<li><p>变式</p>
<ul>
<li><p>由 $\max \Rightarrow \max$</p>
<script type="math/tex; mode=display">\min(S)=\sum_{T\subseteq S,\ T \neq \varnothing} (-1)^{|T|-1} \max(T)</script></li>
<li><p>扩展 $\min\max容斥$</p>
<script type="math/tex; mode=display">\text{kthmax}\{S\}=\sum_{T\subseteq S}(-1)^{|T|-k} \binom{|T|-1}{k-1} \min\{T\}</script><ul>
<li><p>证明</p>
<p>目的是找到容斥系数满足 $\text{kthmax}\{S\}=\sum_{T\subseteq S} f(|T|) \min\{T\}$</p>
<p>考虑第 $x$ 大元素，受原式启发得到</p>
<script type="math/tex; mode=display">\sum_{i=1}^t \binom{t-1}{i-1} f(i)=[t=k]</script><script type="math/tex; mode=display">\therefore 经反演易得 f(n)=(-1)^{n-k} \binom{n-1}{k-1}</script><p><a href="https://oi-wiki.org/math/inclusion-exclusion-principle/#min-max"><del>并不会用到的扩展minmax容斥</del></a></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><ul>
<li><p><a href="https://www.luogu.com.cn/problem/P3175">P3175 [HAOI2015]按位或</a></p>
<ul>
<li><p>题意</p>
<p>设 $\min\{S\}$ 表示二进制数 $S$ 中，第一个元素变为 $1$ 所需时间，$\max\{S\}$ 表示最后一个元素变为 $1$ 所需时间</p>
<p>题为求 $E(\max\{U\})$ ,其中 $U$ 为全集，$U=2^n-1$</p>
</li>
<li><p>解</p>
<p>由公式易知 $\displaystyle{E(\max\{U\})=\sum_{S\subseteq U}(-1)^{|S|-1} \ \sum E(\min\{S\})}$</p>
<p>$\therefore$ 求 $\min$</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><a href="https://www.luogu.com.cn/problem/P5643">P5643 [PKUWC2018]随机游走</a></p>
<ul>
<li><p>题意:</p>
<p>给出一棵树，从根节点出发每次等概率选择并走向一条相邻边</p>
<p>多次询问中，每次给定点集 $S$ ,求从根出发直到 $S$ 中所有点至少经过一次的期望步数</p>
</li>
<li><p>解:</p>
<p>由 $\min-\max$ 容斥得：$\displaystyle{E[ \max(S’) ]=\sum_{T’\in S’}(-1)^{|T’|+1}E[ \min(T’) ]}$</p>
<p>易知 $E[ \max(S’) ]$ 表示走完集合 $S$ 期望步数， $E[ \min(S’) ]$ 表示第一次走到集合 $S$ 的期望步数</p>
<p>设 $f_{S,x}$ 表示从 $x$ 出发，第一次访问到集合 $S$ 的期望步数</p>
<ul>
<li><p>考虑预处理所有 $f_{S,x}$</p>
<p>设 $f_x$ 为点 $x$ 到 $S$ 的最早期望时间</p>
<p>对于 $x\in S$ 有 $f_x=0$</p>
<p>对于 $x\not\in S$ 有 $\displaystyle{f_x=1+\frac{1}{\deg x}\sum_{(x,y)\in E} f_y }$</p>
<p>这里需要 $O(n^3)$ 的高斯消元，考虑到特殊的树形结构，以起点 $root$ 为根，用一次函数分离父子关系</p>
<p>即设 $\displaystyle{f_x=f_{fa_x} \times A_x + B_x }$</p>
<p>$\therefore$ 对于 $x \not\in S$ 有 $\displaystyle{f_x=1+\frac{1}{\deg x} \left(f_{fa_x} + \sum_{y\in son_x}(A_y\times f_x + B_y) \right) }$</p>
<p>化简得</p>
<script type="math/tex; mode=display">\begin{aligned}

​      A_x&=\frac{1}{\deg x-\sum_{y\in son_x}A_x} \\\

​      B_x&=\frac{\deg x+\sum_{y\in son_x}B_x}{\deg x-\sum_{y\in son_x}A_x} \\

 \end{aligned}</script><p>由此，对于给定的询问点集 $S$ ,答案就是 $\sum_{T\in S} (-1)^{|T|+1} f_{T,root}$</p>
</li>
<li><p>再考虑优化询问</p>
<p>由 $n\leq 18$ 提示可以状压点集，并预处理对于每个点集 $S$ 的 $\sum_{T\in S}(-1) ^{|T|+1} f_{T,root}$</p>
<p>那么预处理高维前缀和即可</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>minmax</tag>
      </tags>
  </entry>
  <entry>
    <title>42801202-AGC017</title>
    <url>/2021/08/24/AGC017/</url>
    <content><![CDATA[<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>一个 $N$ 节点的树，两人轮流选择一条树上的边并断开，删除不包含 $1$ 号点的连通块，当一人不能操作时输，求胜者</p>
</blockquote>
<p>树上 $\text{nim}$ 游戏，每个节点的 $\text{sg}$ 值是所有儿子 $\text{sg}$ 值 $+1$ 的异或和，判断根节点 $\text{sg}$ 函数值是否为 $1$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa=<span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    rei res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y:G[x]) <span class="keyword">if</span>(y!=fa) res^=<span class="built_in">dfs</span>(y,x)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>,u,v;i&lt;n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v),G[u].<span class="built_in">push_back</span>(v),G[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="built_in">dfs</span>(<span class="number">1</span>) ? <span class="string">&quot;Alice&quot;</span> : <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>有 $n$ 块不规则拼图，每块拼图看成连接在一起的三个宽度为 $1$ 的矩形，如图<img src="https://atcoder.jp/img/agc017/2b6cd7f4500d3621bc18de407f167522.png" alt="https://atcoder.jp/img/agc017/2b6cd7f4500d3621bc18de407f167522.png"><br>具体地，其中中间的矩形的高度为 $H$ ，左侧矩形的高度为 $A_i$ ，距离中间矩形底部 $C_i$ ，右侧矩形的高度为 $B_i$ ，距离中间矩形底部 $D_i$<br>将这些拼图放入一个边长为 $10^{100}$<br> 的正方形中，需要满足如下条件：</p>
<ul>
<li><p>所有 $N$ 块拼图都必须用上</p>
</li>
<li><p>所有拼图的中间矩形的下底面需要和正方形的下底面对齐</p>
</li>
<li><p>对于非中间的部分的下底面，要么和正方形的下底面对齐，要么和另一块拼图的非中间部分的上顶面对齐</p>
</li>
<li><p>拼图只能平移，不能旋转或翻转</p>
</li>
</ul>
</blockquote>
<p>对于一块拼图，如果其一侧的小矩形不接地，那么这个小矩形一定与另一拼图接地的小矩形相接，即，其高度无关紧要，只关心非 “接地” 小矩形的 $C_i,D_i$</p>
<p>而对于接地的小矩形有 $C_i=0 / D_i=0$ ，此时需要关注高度</p>
<p>于是，对于每块拼图的一侧，我们可以给它对应到个参数：如果是接地的，称它是 $下A_i$ 或 $下B_i$ ，否则，称它为 $上C_i$或 $上D_i$</p>
<p>显然有： $上x$ 的一侧与某矩形 $下x$ 相接，且最两端矩形的两侧是 $下x$</p>
<p>考虑到 $上下x$ 相连没有什么好性质，不妨利用左右矩形：对于左侧小矩形，点 $N_x$ 表示 $上x$ ，点 $P_x$ 表示 $下x$ ；右侧矩形则相反，点 $P_x$ 表示 $上x$ ，点 $N_x$ 表示 $下x$</p>
<p>两个拼图的连接处就是相同的点：全为 $P_x$ 或全为 $N_x$</p>
<p>那么，对于拼图 $(u,v)$ 连接 $u\rightarrow v$ ，那么一连串拼图构成的组对应所得的图上的一条有向边，且路径起点为 $P_x$ ，终点为 $N_x$</p>
<p>那么转化为<strong>判断整张图是否能被拆分成若干个从 $P_x$ 连向 $N_x$ 的有向路径即可</strong></p>
<p>考虑建立超级点 $S$ ，能向所有形如 $P_x$ 的点不断提供入边，也能使足够多的 $N_x$ 连向它</p>
<p>那么对于路径 $P_x\rightarrow v_1\rightarrow v_2\rightarrow …\rightarrow N_y$ ，在两侧分别补上 $N_y\rightarrow S$ 和 $S\rightarrow P_x$ ，如此得到一个有向圈</p>
<p>那么在连接若干条与 $S$ 的边后，图 $G$ 将变为 $\text{Euler}$ 图</p>
<p>考虑到 $\text{Euler}$ 图的性质: $\forall v\in G , 有 d^+(v)=d^-(v)$</p>
<p>由此：在删去 $S$ 及其关联的边后， $\forall P_x\in G , 有d^-(P_x)\leq d^+(P_x)$ ，$\forall N_x\in G , 有d^-(N_x)\geq d^+(N_x)$</p>
<p>首先，如果一张图满足上述条件，那么我们将 $S$ 点与若干个点连边后，可以得到一张 $\text{Euler}$ 图 (且这个方案事实上是唯一的，即我们可以算出 $S$ 该向每个点连多少条边)。</p>
<p>其次，由 $\text{Euler}$ 图的性质，可得到 $S$ 的若干条 $\text{Euler}$ 回路 (这里用若干的原因是 $G$ 不一定连通)。</p>
<p>那么，考虑其中的每个圈 (注意与回路的区别)：</p>
<ul>
<li><p>如果它经过 $S$ ，那么将 $S$ 点去掉后，就得到一个可行的路径。</p>
</li>
<li><p>如果这个圈不经过点 $S$</p>
<p>那么，如果这个圈可以和一个包含 $S$ 点的圈合并，得到一个大的回路，那么这个回路也满足条件，即，边不重复。于是，希望这些圈尽可能地进行合并</p>
<p>所以，考虑最终得到的每个图的连通分量 ($\text{Euler}$ 图的强连通性保证这里的强连通分量和弱连通分量是同一个)，如果存在一个不包含 $S$ 的连通分量，则问题是无解的 —— 因为这个圈/回路不包含 $S$ ，从而不可能找到一条对应的路径经过 $S$ 和圈/回路中所有的边。</p>
<p>而反之，如果所有连通分量都包含 $S$ (从而只有一个连通分量)，那么问题就是有解的了。</p>
</li>
</ul>
<p>于是，我们使用并查集维护一下连通性就可以了。注意到，在满足性质的条件下，一个点和 $S$ 相连当且仅当它的入度和出度不相等。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">410</span>;</span><br><span class="line"><span class="keyword">int</span> n,H,V;</span><br><span class="line"><span class="keyword">int</span> fa[N],in[N],out[N];</span><br><span class="line"><span class="keyword">bool</span> dicyc[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_anc</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x ? x : fa[x]=<span class="built_in">get_anc</span>(fa[x]);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> Lu,Ld,Ru,Rd,L,R;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;H); V=H&lt;&lt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">iota</span>(fa,fa+V,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;Lu,&amp;Ru,&amp;Ld,&amp;Rd);</span><br><span class="line">		++out[ L=(Ld ? Ld+H : Lu)<span class="number">-1</span> ];</span><br><span class="line">        ++in[ R=(Rd ? Rd : Ru+H)<span class="number">-1</span> ];</span><br><span class="line">		fa[ <span class="built_in">get_anc</span>(L) ]=<span class="built_in">get_anc</span>(R);</span><br><span class="line">    &#125;</span><br><span class="line">	rei i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;H &amp;&amp; in[i]&lt;=out[i] &amp;&amp; in[i+H]&gt;=out[i+H];++i);</span><br><span class="line">	<span class="keyword">if</span>(i!=H) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>),<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;V;++i) dicyc[ <span class="built_in">get_anc</span>(i) ] |= in[i]!=out[i] || !in[i];</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;V &amp;&amp; (fa[i]!=i || dicyc[i]);++i);</span><br><span class="line">    <span class="built_in">puts</span>(i==V ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    <span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>你有一个由 $\frac{n(n+1)}{2}$ 个点组成的等边三角形。 在 $(i,j)$ 点左下的是 $(i+1,j)$ 点， 右下的是 $(i+1,j+1)$ 点. 现在在上面画 $m$ 条从 $(1,1)$ 开始，$(n,p)$ 结束的连续路径 $(p\in[1,n])$ ， 满足对于任意 $1\leq i\leq j\leq m$, 第 $j$ 条线的任意一个部分不在第 $i$ 条线的左边。<br><img src="https://atcoder.jp/img/agc017/8d354fb1a389a0aa5b64ba93f6ca7801.png" alt="https://atcoder.jp/img/agc017/8d354fb1a389a0aa5b64ba93f6ca7801.png"><br>另外，还有 $k$ 个限制 , 第 $i$ 个限制形如 $A_i,B_i,C_i$ ，表示第 $A_i$ 条路径， 在第 $B_i$ 次决策的时候， 如果 $C_i=0$ ​则必须走左下， 否则必须走右下。</p>
<p>求出一共有多少种不同的画路径的方案满足以上的要求。</p>
</blockquote>
<p>有一个朴素状压 $\text{dp}$ ，用 $O(m\times 4^n)$ 直接枚举状态转移</p>
<p>而直接枚举状态显然多余考虑了很多不合法状态</p>
<p>有神仙思路如下：</p>
<p>设 $0$ 为向左走，$1$ 为向右走，不考虑方向的限制，合法转移后的状态一定满足任何一个前缀 $1$ 的个数都大于之前状态前缀 $1$ 的个数</p>
<p>那么设 $dp_{i,j,k}$ 表示第 $i$ 条路径的第 $j$ 条转移，转移状态的前 $j$ 位与 $k$ 相同，考虑向右的情况：直接把后面的第一个 $1$ 变为 $0$ ，然后提到前面，如此，中间段取 $1/0$ 都满足要求，不会向左越过原来的，总复杂度 $O(n\times m\times 2^n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">21</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k,all,last=<span class="number">1</span>,cur,ans;</span><br><span class="line"><span class="keyword">int</span> dir[N][N],dp[<span class="number">2</span>][<span class="number">1</span>&lt;&lt;N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fix</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123; x&gt;=mod ? x-=mod : <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x&amp;(-x);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);--n;</span><br><span class="line">	all=(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>,x,y,foo;i&lt;=k;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;foo),dir[x][y<span class="number">-1</span>]=foo+<span class="number">1</span>;</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=m;++i) <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">		<span class="built_in">swap</span>(last,cur);</span><br><span class="line">		rei foo=<span class="number">1</span>&lt;&lt;j,bar=all^((foo&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">for</span>(rei s=<span class="number">0</span>;s&lt;=all;++s) dp[cur][s]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(rei s=<span class="number">0</span>;s&lt;=all;++s)&#123;</span><br><span class="line">			<span class="keyword">if</span>(dp[last][s])&#123;</span><br><span class="line">				<span class="keyword">if</span>(dir[i][j]!=<span class="number">2</span> &amp;&amp; (!(foo&amp;s))) <span class="built_in">fix</span>(dp[cur][s]+=dp[last][s]);<span class="comment">//左</span></span><br><span class="line">				<span class="keyword">if</span>(dir[i][j]!=<span class="number">1</span>)&#123;<span class="comment">//右</span></span><br><span class="line">					rei x;</span><br><span class="line">					<span class="keyword">if</span>(foo&amp;s) x=s;<span class="comment">//必须右</span></span><br><span class="line">					<span class="keyword">else</span>&#123;</span><br><span class="line">						<span class="keyword">if</span>(!(bar&amp;s)) x=s|foo;</span><br><span class="line">						<span class="keyword">else</span> x=(s|foo)^<span class="built_in">lowbit</span>(bar&amp;s);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="built_in">fix</span>(dp[cur][x]+=dp[last][s]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;=all;++i) <span class="built_in">fix</span>(ans+=dp[cur][i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	<span class="built_in">getchar</span>(),<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>构造</tag>
        <tag>dp</tag>
        <tag>博弈论</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>loj#6274.数字</title>
    <url>/2021/07/08/loj-6274%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h3 id="重点说一下与运算中的转移"><a href="#重点说一下与运算中的转移" class="headerlink" title="重点说一下与运算中的转移"></a>重点说一下与运算中的转移</h3><p>考虑在当前位两数分别为 $\langle 1,0 \rangle$ 或 $ \langle 0,1 \rangle$</p>
<p>显然这两种选择的 $\And$ 与 $|$ 操作所得结果相同，由此可知会不同选择中有包含关系</p>
<p>从 $\langle 1,0 \rangle$ 与 $\langle 0,1 \rangle$ 所得情况等价入手</p>
<p>记 $\langle 1,0 \rangle$ 为情况 $S_1$ , 其中 $1$ 是第一个数的选择，$0$ 是第二个数字的选择 ,</p>
<p>$\langle 0,1 \rangle$ 为情况 $S_2$</p>
<p>由于 $S_2$ 中的 $0$ 可知，$S_1$ 选择 $1$ 取不到 $\max$，即无论后面的位如何取都取不到上界</p>
<p>同理，由于 $S_1$ 中的 $1$，$S_2$ 选择 $0$ 取不到 $\min$，即无法取到下界</p>
<ul>
<li><p>假设后面会有情况选择 $\langle 1,1 \rangle$，考虑到第二个数字取不到 $\max$ ，所以等同于选择了 $\langle 1,0 \rangle$</p>
</li>
<li><p>假设后面会有情况选择 $\langle 0,1 \rangle$，考虑到第二个数字取不到 $\min$ ，所以等同于选择了 $\langle 1,1 \rangle$</p>
</li>
</ul>
<p>所以对于与结果为 $0$ 的合法情况，取其结果的最大值即可</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈论</title>
    <url>/2021/02/04/%E5%8D%9A%E5%BC%88%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="博弈论游戏及其的变形"><a href="#博弈论游戏及其的变形" class="headerlink" title="博弈论游戏及其的变形"></a>博弈论游戏及其的变形</h1><h2 id="请熟背以下结论（因为没看懂推导）"><a href="#请熟背以下结论（因为没看懂推导）" class="headerlink" title="请熟背以下结论（因为没看懂推导）"></a>请熟背以下结论（因为没看懂推导）</h2><hr>
<h2 id="巴什博弈"><a href="#巴什博弈" class="headerlink" title="巴什博弈"></a>巴什博弈</h2><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul>
<li>只有一堆 $n$ 个物品，两个人轮流取</li>
<li>每次至少取一个，最多取 $m$ 个。</li>
<li>最后取光者得胜</li>
</ul>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>$n \mod (m+1)$ 为 $0$ 先手必败否则必胜</p>
<hr>
<h2 id="威佐夫博弈"><a href="#威佐夫博弈" class="headerlink" title="威佐夫博弈"></a>威佐夫博弈</h2><h3 id="规则-1"><a href="#规则-1" class="headerlink" title="规则"></a>规则</h3><ul>
<li>有两堆各若干个物品</li>
<li>两个人轮流从某一堆取至少一个或同时从两堆中取同样多的物品</li>
<li>最后取光者得胜</li>
</ul>
<h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><p>先手必败态的两堆石子之差依次递增，且每个自然数仅出现一次</p>
<p>如果局势为 $(a,b)$，记 $k=(a−b)$，</p>
<p>若 $a=\frac{1+\sqrt{5}}{2}*k$ （这里是等于符号）</p>
<p>则为必胜局势</p>
<hr>
<h2 id="尼姆博弈"><a href="#尼姆博弈" class="headerlink" title="尼姆博弈"></a>尼姆博弈</h2><h3 id="规-则"><a href="#规-则" class="headerlink" title="规 则"></a>规 则</h3><ul>
<li>$n$ 堆石子</li>
<li>两人轮流在任意一堆中取任意石子，不能不取，最多取完，</li>
<li>取到最后一颗石子者胜</li>
</ul>
<h3 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h3><p>$n$ 堆石子数量异或和为 $0$ 则先手必败,否则必胜</p>
<hr>
<h2 id="anti-SG与SJ（贾志豪）定理"><a href="#anti-SG与SJ（贾志豪）定理" class="headerlink" title="anti-SG与SJ（贾志豪）定理"></a>anti-SG与SJ（贾志豪）定理</h2><h3 id="规则-2"><a href="#规则-2" class="headerlink" title="规则"></a>规则</h3><ul>
<li><p>桌子上有 $n$ 堆石子，游戏者轮流取石子。</p>
</li>
<li><p>每次只能从一堆中取出任意数目的石子，但不能不取。</p>
</li>
<li><p>取走最后一个石子者败。</p>
</li>
</ul>
<h3 id="结论-3"><a href="#结论-3" class="headerlink" title="结论"></a>结论</h3><p>先手必胜当且仅当：</p>
<ol>
<li><p>所有堆的石子数都为 $1$ 且游戏的 SG 值为 $0$；</p>
</li>
<li><p>有些堆的石子数大于 $1$ 且游戏的 SG 值不为 $0$。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;tmp);</span><br><span class="line">        <span class="keyword">if</span>(tmp&gt;=<span class="number">2</span>) flag=<span class="number">1</span>;</span><br><span class="line">        ans^=tmp;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span>((ans&amp;&amp;flag) || (!ans&amp;&amp;!flag))</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;John&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Brother&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>P4279 [SHOI2008]小约翰的游戏</p>
<p>UVA1566 John(双倍经验)</p>
<hr>
<h2 id="multi-SG"><a href="#multi-SG" class="headerlink" title="multi-SG"></a>multi-SG</h2><h3 id="规则-3"><a href="#规则-3" class="headerlink" title="规则"></a>规则</h3><ul>
<li>有 $n$ 堆石子</li>
<li>可以从任意一堆石子中拿任意石子(不能不拿)</li>
<li>或者把一堆数量不少于 $2$ 石子分为两堆不为空的石子。</li>
</ul>
<h3 id="结论-4"><a href="#结论-4" class="headerlink" title="结论"></a>结论</h3><p>$SG\left(x\right) =<br>\begin{cases}<br>x-1 &amp; ( x \mod 4=0)<br>\\ x &amp; ( x \mod 4=1 \lor 2)<br>\\ x+1 &amp; ( x \mod 4=3)<br>\end{cases}$</p>
<p>注：$1 \lor 2$ -&gt; $1$ || $2$</p>
<p><del>对这个结论我有绝佳的证明，但我要去玩DDLC了</del></p>
<p><del>Update:更好看且对齐的Latex</del></p>
<h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p>P3185 [HNOI2007]分裂游戏 <del>(关系并不大的样子)</del></p>
<p>P3235 [HNOI2014]江南乐 (未做qwq) (现在做过了qwq)</p>
<hr>
<h2 id="阶梯SG"><a href="#阶梯SG" class="headerlink" title="阶梯SG"></a>阶梯SG</h2><h3 id="规则-4"><a href="#规则-4" class="headerlink" title="规则"></a>规则</h3><ul>
<li>有若干级阶梯，每级阶梯上有一个单个游戏</li>
<li>每次可以对一个阶梯操作并将操作中失去的东西丢到下一级阶梯上。</li>
</ul>
<h3 id="应用范围"><a href="#应用范围" class="headerlink" title="应用范围"></a>应用范围</h3><p>对于单个游戏状态，若操作集合可逆（即上一级丢给这级的东西在这级可以再丢掉），则可以应用。</p>
<h3 id="结论-5"><a href="#结论-5" class="headerlink" title="结论"></a>结论</h3><p>令最低级阶梯为第 $0$ 级，对奇数级阶梯上的游戏 SG 值取异或和，为 $0$ 先手必败，否则先手必胜。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">rei sg=<span class="number">0</span><span class="comment">/*本行sg值*/</span>,tot=<span class="number">0</span><span class="comment">/*连续石头的个数*/</span>;</span><br><span class="line"><span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">rei C=<span class="number">20</span>-m+<span class="number">1</span>;<span class="comment">//空格个数</span></span><br><span class="line"><span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=m;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x),st[x]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=<span class="number">20</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])&#123;<span class="comment">//石头不再连续</span></span><br><span class="line">            <span class="keyword">if</span>((--C)&amp;<span class="number">1</span>) sg^=tot;<span class="comment">//奇数行</span></span><br><span class="line">            tot=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ++tot;</span><br><span class="line">&#125;</span><br><span class="line">ans^=sg;</span><br></pre></td></tr></table></figure>
<h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h3><p>P2575 高手过招</p>
<p>P3480 [POI2009]KAM-Pebbles 需要一些转化技巧</p>
<hr>
<h2 id="k-SG"><a href="#k-SG" class="headerlink" title="k-SG"></a>k-SG</h2><h3 id="规则-5"><a href="#规则-5" class="headerlink" title="规则"></a>规则</h3><ul>
<li>有 $n$ 堆石子</li>
<li>每次可以从不超过 $k$ 堆中按规定规则各取一些石子</li>
<li>不能操作者败。</li>
</ul>
<h3 id="结论-6"><a href="#结论-6" class="headerlink" title="结论"></a>结论</h3><p>将每堆石子的 SG 值设为 $s_i$ 。</p>
<p>将所有 $s_i$ 二进制第 $j$ 位上的数相加得到 $r_1,r_2,\dots,r_J$（ $J$ 为所有 $s_i$ 二进制最高位的位数）</p>
<p>如果 $\forall i \in [1,J]$ 有 $r_i \equiv 0\pmod{k+1}$ ，那么先手必败；否则先手必胜。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;=<span class="number">16</span>;++i)</span><br><span class="line">    <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;=n-k;++j)<span class="comment">//能使用的最多石子</span></span><br><span class="line">        <span class="keyword">for</span>(rei x=<span class="number">0</span>; (<span class="number">1ll</span>&lt;&lt;i)*x*(d+<span class="number">1</span>) &lt;= n-k <span class="comment">/*所取的石子不多于题目限制*/</span>&amp;&amp;<span class="comment">/*所取的石子不多于总堆数 -&gt; 每堆每次只能减1*/</span> x*(d+<span class="number">1</span>) &lt;= k/<span class="number">2</span>; ++x)</span><br><span class="line">        <span class="comment">//从k/2个堆中选出x*(d+1)个，使其石子数二进制在i位为1</span></span><br><span class="line">        <span class="comment">//贡献的方案数为C[k/2][x*(d+1)]</span></span><br><span class="line">            dp[i+<span class="number">1</span>][ j+ (<span class="number">1ll</span>&lt;&lt;i)*x*(d+<span class="number">1</span>) ] = (dp[i+<span class="number">1</span>][ j+ (<span class="number">1ll</span>&lt;&lt;i)*x*(d+<span class="number">1</span>) ] + <span class="number">1ll</span>*dp[i][j]*C[k/<span class="number">2</span>][x*(d+<span class="number">1</span>)]%mod )%mod;</span><br></pre></td></tr></table></figure>
<h3 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h3><p>P2490 [SDOI2011]黑白棋</p>
<hr>
<h2 id="翻棋子游戏"><a href="#翻棋子游戏" class="headerlink" title="翻棋子游戏"></a>翻棋子游戏</h2><h3 id="规则-6"><a href="#规则-6" class="headerlink" title="规则"></a>规则</h3><ul>
<li>在一些棋子中，有的正面朝上，有的反面朝上</li>
<li>每次操作可以翻其中一颗正面朝上的棋子，会带动一些其他棋子的组合翻面。</li>
</ul>
<h3 id="结论-7"><a href="#结论-7" class="headerlink" title="结论"></a>结论</h3><p>局面的 SG 值为局面中每个正面朝上的棋子单一存在时的 SG 值的异或和。</p>
<p>具体问题具体分析吧qwq</p>
<p>将 每颗棋子翻面后可能影响的棋子组成的游戏 作为一个后继状态，<br>对每颗棋子求 SG 值，然后求所有正面朝上的棋子 SG 值的异或和，为 $0$ 先手必败，否则先手必胜</p>
<h3 id="例题-4"><a href="#例题-4" class="headerlink" title="例题"></a>例题</h3><p>P3179 [HAOI2015]数组游戏 （需要数论芝士，未做qwq）</p>
<p>P4077 [SDOI2016]硬币游戏</p>
<hr>
<h2 id="斐波那契博弈"><a href="#斐波那契博弈" class="headerlink" title="斐波那契博弈"></a>斐波那契博弈</h2><h3 id="规则-7"><a href="#规则-7" class="headerlink" title="规则"></a>规则</h3><ul>
<li><p>两人互相取一堆石子，取完者胜</p>
</li>
<li><p>第一次不能取完,至少取 $1$ 颗</p>
</li>
<li><p>从第二次开始,每个人取的石子数至少为1,至多为对手刚取的石子数的 $2$ 倍。</p>
</li>
</ul>
<h3 id="结论-8"><a href="#结论-8" class="headerlink" title="结论"></a>结论</h3><p>当 $n$ 为 $\text{fibonacci}$ 数时，先手必败</p>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><ul>
<li><p>先考虑 $n$ 为斐波那契数 $f_i$</p>
<ul>
<li><p>当 $i=2,n=2$ 显然有 先手必败</p>
</li>
<li><p>设当 $i&lt;=k$ 时结论成立</p>
<p>当 $i=k+1 , f_i=f_k+f_{k-1}$ ,一定可以将这堆石子看成两堆：$k-1,k$，因为 $2\times f_{k-1}&gt;f_k$ ,若 $\geq f_{k-1}$ 则后手可以直接取完 $f_k$ ； 若先手第一次取得石子 $&lt;f_{k-1}$，则后手一定最后取，考虑后手最多取石子 $x$ 个：</p>
<p>那么先手应取尽可能多的石子，来使后手取更多的石子，再在后手取完 $堆k-1$ 后，能使先手取完 $堆k$</p>
<p>那么让先手取 $y\geq \frac{f_{k-1}}{3}$，此时后手可以直接取完 $堆k-1$，$\therefore x=f_{k-1}-y\leq \frac{2}{3}\times f_{k-1}$</p>
<p>易知 $\frac{2}{3}\times f_{k-1}&lt;\frac{1}{2}\times f_k$ ,即，后手取完 $堆k-1$ 后，先手不能一次取完 $堆k$，则 $i=k+1$ 时，结论仍成立</p>
</li>
</ul>
</li>
<li><p>再考虑 $n$ 不为斐波那契数</p>
<ul>
<li><p>齐肯多夫定理：</p>
<p>任何正整数可以表示为若干个<strong><em>\</em>不连续**</strong>的 $\text{fibonacci}$ 数之和 <strong><em>\</em>（优先选取最大的）**</strong></p>
</li>
</ul>
<p>由于对每次取石子的最少数量没有限制，所以可以将 $n$ 按照以上定理拆成多组，每组是一个斐波那契数，并把该拿的一堆石子转化为拿多组石子</p>
<p>由于所取的数不连续，所以有 $f_{i}&gt;2\times f_{i-1}$</p>
</li>
</ul>
<p>​      令先手先取完 $i$ 最小的 $f_i$ ,此时后手不能取完 $f_{i+1} 这一堆$，相当于面临子游戏，且为必败态(有 $f_{i+1}$ 个，且后手先取)，则先手必胜</p>
<p>​       以此类推，先手必胜</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>卢神的神题选讲</title>
    <url>/2021/05/14/%E5%8D%A2%E7%A5%9E%E7%9A%84%E6%9D%82%E9%A2%98%E9%80%89%E8%AE%B2/</url>
    <content><![CDATA[<h2 id="P6962-NEERC2017-Knapsack-Cryptosystem"><a href="#P6962-NEERC2017-Knapsack-Cryptosystem" class="headerlink" title="P6962 [NEERC2017]Knapsack Cryptosystem"></a>P6962 [NEERC2017]Knapsack Cryptosystem</h2><p>依据数据范围分成两部分</p>
<ul>
<li><p>折半算法 $O(2^{\frac{n}{2}})$</p>
<p>将 $n$ 个数分为 $\left\lfloor \frac{n}{2} \right\rfloor$ 和 $\left\lceil \frac{n}{2} \right\rceil$ 两组，对每组中的每个子集计算和</p>
<p>再枚举其中一组，判断另一组</p>
</li>
<li><p>$O(2^{64-n} \cdot n)$</p>
<p>发现$b_i$ 与 $a_i$ 对应，枚举 $a_1$ 取值并以此解出 $r$ , 再解出 $a_2’,a_3’ \cdots a_n’$</p>
<p>从大到小贪心枚举，判断 $a’$ 是否满足条件</p>
<ul>
<li><p>注：</p>
<p>求解 $r$ 时，根据 $a_1\cdot r\equiv b_1\pmod{2^{64}} \quad \text{式1}$</p>
<p>设 $k=\text{__builtin_ctz}(b_1)$ (即，$b_1$ 二进制下末尾 $0$ 的个数)</p>
<p>$\displaystyle{\because r 是奇数 \qquad \text{注：r,q 互质}}$</p>
<p>$\therefore \text{__builtin_ctz}(a_1)=k$</p>
<p>式 $1$ 两边同除以 $2^k$ 得： $a_1 \cdot r \cdot 2^{-k} = b_1 \cdot 2^{-k} \pmod{2^{64}-k}$</p>
<p>$\therefore 得到的 r 只能保证前 64-k 位正确$</p>
<p>$\therefore 再继续枚举后 k 位$</p>
<p>注意到 $a_1$ 末尾恰好有 $k$ 个 $0$，所以枚举的时候每次加上 $2^{k+1}即可$</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="P6938-ICPC2017-WF-Son-of-Pipe-Stream"><a href="#P6938-ICPC2017-WF-Son-of-Pipe-Stream" class="headerlink" title="P6938 [ICPC2017 WF]Son of Pipe Stream"></a>P6938 [ICPC2017 WF]Son of Pipe Stream</h2><p>先忽略 $v$ , 因为当 $v\not ={1}$ 时，将 $v=1$ 的答案 $\cdot v^{-\alpha}$ 即可</p>
<ul>
<li><p>证：</p>
<p>$\because v\cdot f_i+w_i \leq c_i,\\ \therefore把 v 看成 1 相当于 f_i少算了 \frac{1}{v}$</p>
<p>$\because F^{\alpha}\\ \therefore \cdot v^{-\alpha}$</p>
</li>
</ul>
<p>易知若流 $(F,W)$ 合法，当且仅当 $F\leq F_{max},W\leq W_{max},F+W\leq S$</p>
<p>有解 $(F_{max},S-F_{max})$ 和 $(S-W_{max},W_{max})$</p>
<blockquote>
<p>看成增广时优先增广其中一边</p>
</blockquote>
<p>设函数 $V(F)=F^{\alpha} \cdot (S-W)^{\alpha}$ , V的最大值就是所求答案</p>
<p>当 $F=\alpha S$ 时 $V$ 有最大值</p>
<ul>
<li><p>证明 （%%%@神仙ljr</p>
<p>对 $V$ 求导</p>
<script type="math/tex; mode=display">\begin{aligned}
V(F)^{\prime}
&= (F^\alpha)^{\prime} \cdot (C-F)^{1-\alpha} + \left((C-F)^{1-\alpha} \right)^{\prime} \cdot F^{\alpha} \\
&=\alpha F^{\alpha-1} \cdot \left(\frac{1}{C-F}\right)^{\alpha-1} +  (-(1-\alpha))(C-F)^{-\alpha} \cdot x^{\alpha} \\
&=\alpha \cdot \left(\frac{F}{C-F} \right)^{\alpha-1} + (\alpha-1) \cdot \left(\frac{F}{C-F} \right)^{\alpha} \\
&=\left(\frac{F}{C-F} \right)^{\alpha-1} \cdot \left(\alpha + (\alpha-1) \cdot \frac{F}{C-F} \right) \\
\end{aligned}</script><p>当 $V(F)^{\prime}=0$ 时，V有 $\max$</p>
<p>$\therefore F=0 或 F=\alpha C$</p>
</li>
</ul>
<p>所以构造出流 $(F_0,S-F_0)$ ，其中 $F_0$ 是与 $\alpha \cdot S$ 最接近的</p>
<ul>
<li><p>实现</p>
<ol>
<li><p>分别以 $1,2$ 为源跑一次最大流，得 $Flubber$ 和 $Water$ 的最大流量 $F_{max},W_{max}$</p>
</li>
<li><p>再新建源连向 $1,2$ ，跑一次 $Flubber+Water$ 的最大混合流量 $S$ ，最优的 $F$ 就是在 $[S−W_{max},F_{max}]$ 里最贴近 $\alpha \cdot S$ 的值，于是得到新的 $F^{\prime}$ ，然后 $W^{\prime}=S−F^{\prime}$ ，可以证明这两个流量是一定可以得到且一定是最优的</p>
</li>
<li><p>然后考虑构造解，新建源连向 $1,2$ 容量分别为 $F^{\prime},W^{\prime}$ ，跑一次最大流，然后根据这次结果新建图，新图中每条边的方向就是这次流的方向，容量就是这次的流量</p>
</li>
<li><p>超级源点只连 $1$ 容量 $F^{\prime}$ 跑一次得到每条边 $Flubber$ 的流量，只连 $2$ 容量 $W^{\prime}$ 跑一次得到每条边 $Water$ 的流量</p>
</li>
</ol>
</li>
</ul>
<hr>
<h2 id="P6944-ICPC2018-WF-Gem-Island"><a href="#P6944-ICPC2018-WF-Gem-Island" class="headerlink" title="P6944 [ICPC2018 WF]Gem Island"></a>P6944 [ICPC2018 WF]Gem Island</h2><p>最终状态出现次数相等，均为 $d!$ 次</p>
<p>不同操作方案有 $n\cdot (n+1)\cdot \cdots (n+1-1)=\frac{(n+d-1)!}{(n-1)!}$</p>
<p>先求出不同的最终状态，再进行处理</p>
<p>$\therefore$ 转化为求和为 $n+d$ 的 $n$ 个数，且满足每个数 $\geq$ $1$ 的所有方案的前 $r$ 个数的和</p>
<p>起初每个人都为 $1$ 个，和为 $n$</p>
<p>选 $s_1$ 个人变成 $2$ 个，和为 $n+s_1$，方案数 $\ast$= $\dbinom{n}{s_1}$</p>
<p>在 $s_1$ 个人中选 $s_2$ 个，和为 $n+s_1+s_2$ ，方案数 $\ast$= $\dbinom{s_1}{s_2}$</p>
<p>$\cdots$</p>
<p>每一次对前 $r$ 大的贡献为 $\min(r,s_x)$ ，其中 $s_x$ 为当前加入的个数</p>
<hr>
<h2 id="P6922-ICPC2016-WF-Longest-Rivers"><a href="#P6922-ICPC2016-WF-Longest-Rivers" class="headerlink" title="P6922 [ICPC2016 WF]Longest Rivers"></a>P6922 [ICPC2016 WF]Longest Rivers</h2><p>对于叶子节点 $i$ ，一定有从其到根的一条路径,距离为 $d_i$</p>
<p>要满足剖分 $D$ 中叶子节点 $j$ 所在链长 $l_{D,j} &gt; d_i$ 的链 $l$ 的数量最小</p>
<p>对于每个节点 $i$ ，如果存在一条河流比 $d_i$ 长，那么让它延伸会使答案最小，否则要选择一条最短的河流来进行延伸。</p>
<p>设 $f_i$ 表示每个节点往外延伸的河流的长度的最小值，通过树形DP求。</p>
<p>将 $d$ 升序，临界点自下向上收束，对每个 $d_i$ ，所有超过了上一个 $d$ 的限制，但是满足当前的 $d$ 限制的临界点，这些点将不再是临界点。</p>
<p>若一个点所有的儿子都不是临界点，则它变为临界点。</p>
<p>用堆按 $f$ 从小到大维护临界点，答案就是临界点个数+1，也就是堆中元素个数+1。</p>
<hr>
<h2 id="P4348-CERC2015-Cow-Conﬁnement"><a href="#P4348-CERC2015-Cow-Conﬁnement" class="headerlink" title="P4348 [CERC2015]Cow Conﬁnement"></a>P4348 [CERC2015]Cow Conﬁnement</h2><p>扫描线 <del>显然</del></p>
<p>考虑从右往左扫，维护 $f_y$：</p>
<ul>
<li><p>当 $y+1$ 处是栅栏，$(x,y)$ 处的答案就是 $f_y$</p>
</li>
<li><p>若不是，$f_y$ 是 $(x,y)$ 比 $(x,y+1)$ 多出来的值</p>
</li>
<li><p>看成差分</p>
<p>向下累加 $y$ 直到栅栏</p>
<ul>
<li><p>牛 $\Rightarrow$ 查询</p>
</li>
<li><p>花 $\Rightarrow$ $+1$</p>
</li>
<li><p>栅栏 $(x_l,y_l,x_r,y_r)$</p>
<p>在 $x_r$ 处清空 $[y_l,y_r]$ , $y_l-1$ 处加上 $y_l$ 的值,记录 $y_r+1$ 的值</p>
<p>在 $x_l-1$ 处清空 $[y_l,y_r]$ , $y_l-1$ 减去在 $x_r$ 处记录的 $y_r+1$ 的值，防止没有栅栏阻挡而重复计算</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="P7024-NWRRC2017-Fygon-2-0"><a href="#P7024-NWRRC2017-Fygon-2-0" class="headerlink" title="P7024 [NWRRC2017]Fygon 2.0"></a>P7024 [NWRRC2017]Fygon 2.0</h2><p>神仙图论题</p>
<p>考虑语句<code>for i in range(a,b):</code></p>
<p>它创建了变量 $i,a,b$ 并给出它们的大小关系 $a\leq i \ , \ i\leq b$</p>
<p>对于条件 $x\leq y$ ，由 $x$ 向 $y$ 连出有向边</p>
<p>在整张图上，若出现强连通分量就必须满足其中的每个点取值相同(即 $a\leq b\leq c \cdots \leq a$) $\Rightarrow$ 考虑缩点</p>
<p>缩点后得到一个DAG，考虑到有向无环且每个点的值都可以在 $1\to n$ 中取，那么DAG的顶点数即为 $k$</p>
<p>而DAG的一个拓扑序 (即DAG上点的一种大小关系) 对应一个合法的 $k$ 元组</p>
<p>设拓扑序有 $N$，则 $f(n)\geq N \cdot \dbinom{n}{k}$</p>
<p>$\displaystyle{\because \lim_{n \to \infty}\frac{f(n)}{C \cdot n^k}=1 \And \lim_{n \to \infin} \frac{n^{\underline{k}}}{n^k}=1}$</p>
<p>那么 $C=\frac{N}{k!}$</p>
<p>最后用状压求拓扑序个数</p>
<p>注:   输入: <code>I</code><br>        输出:  <code>I</code><br>        输入: <code>I qwq</code><br>       输出: <code>I</code><br>即，当 <code>cin&gt;&gt;string</code> 时，会因为 <code>[space]</code> 而停止，但不会因为最前面的 <code>space</code> 停止</p>
<hr>
<h2 id="P7016-CERC2013-Captain-Obvious-and-the-Rabbit-Man"><a href="#P7016-CERC2013-Captain-Obvious-and-the-Rabbit-Man" class="headerlink" title="P7016 [CERC2013]Captain Obvious and the Rabbit-Man"></a>P7016 [CERC2013]Captain Obvious and the Rabbit-Man</h2><p>这是人做的？</p>
<p><del>并不会<a href="https://www.cnblogs.com/Winniechen/p/10246295.html">特征多项式与常系数线性齐次递推</a></del></p>
<p>GG</p>
<p>$f_2,f_3,\cdots ,f_{k+1}$ 互不相同，$\therefore \{a_n\}_{n\geq 1}$ 是一个 $n$ 阶的常系数线性齐次递推数列</p>
<p>特征多项式为 $\displaystyle{P(x)=(x-f_2)\cdot(x-f_3)\cdots(x-f_{k+1})}$</p>
<p>设 $\displaystyle{P(x)=x^k-b_1x^{k-1}-b_2x^{k-2}-\cdots -b_{k-1}x-b_k}$</p>
<p>则 $a_{k+1}=b^1a_k+b_2a_{k-1}+\cdots +b^ka_1$</p>
<p>所以计算出 $P(x)$ 系数再带入即可</p>
<hr>
<h2 id="P4354-CERC2015-Ice-Igloos"><a href="#P4354-CERC2015-Ice-Igloos" class="headerlink" title="P4354 [CERC2015]Ice Igloos"></a>P4354 [CERC2015]Ice Igloos</h2><p>对每个圆，与之相交的直线只会在其周围的4个方格中出现</p>
<p>那么对每个线段，枚举其经过的方格，查看在当前单元格中出现的圆是否与该直线相交</p>
<p>垃圾暴力复杂度 $\Theta(m\ast 4\ast 1000)$ <del>但够过了</del></p>
<p><del>实现好烦</del></p>
<hr>
<h2 id="P7054-NWRRC2015-Graph"><a href="#P7054-NWRRC2015-Graph" class="headerlink" title="P7054 [NWRRC2015]Graph"></a>P7054 [NWRRC2015]Graph</h2><p>神仙图论题</p>
<p>贪心，从开头到末尾依次贪心，让第一个位置的字典序最大，再让第二个最大</p>
<p>对某个拓扑层来说，需要对该点中最小节点加边</p>
<p>用一个最大堆存暂时无法连边的节点，之后无法拓扑时从中取出顶，将拓扑序的结尾点连向该顶</p>
<hr>
<h2 id="P4351-CERC2015-Frightful-Formula"><a href="#P4351-CERC2015-Frightful-Formula" class="headerlink" title="P4351 [CERC2015]Frightful Formula"></a>P4351 [CERC2015]Frightful Formula</h2><ul>
<li><p>题意</p>
<script type="math/tex; mode=display">f_{i , j} = \begin{cases} l_i & j = 1 \\ t_j & i = 1 \\ a \cdot f_{i, j - 1} + b \cdot f_{i - 1, j} + c & \text{otherwise} \end{cases}</script><p>求 $f_{n,n}$</p>
<p>取模 $1e6+3$</p>
</li>
<li><p>解</p>
<ul>
<li><p>先考虑 $c=0$</p>
<p>该情况是典型的<a href="https://www.cnblogs.com/p-b-p-b/p/14184761.html">格路计数</a></p>
<p>从 $(1,1)$ 到 $(n,m)$ 的路径数为 $\displaystyle{C_{n+m-2}^{n-1}}$</p>
<ul>
<li><p>证：</p>
<p>一条 $(1,1)$ 到 $(n,m)$ 的自由路可以唯一对应到一个含有 $n-1$ 个右步 $L$ 和 $m-1$ 个下步 $U$ 的序列</p>
<p>每个这种序列也可唯一对应一条自由路</p>
<p>$\therefore$ $(n,m)$ 自由路的条数等于从 $n+m-2$ 个位置中选出 $n-1$ 个 $L$ 的方案数</p>
</li>
</ul>
<p>考虑右步贡献 $\ast a$ , 下步贡献 $\ast b$</p>
<p>$\therefore$ 总贡献是 $C_{n+m-2}^{n-1}\cdot a^{n-1}\cdot b^{m-1}$</p>
<p>由于第一行/列初始贡献不同，所以对每个起点都要计算</p>
</li>
<li><p>考虑 $c\not ={0}$</p>
<p>考虑消掉常数 $c$</p>
<p>找到 $x$ 满足 $x=ax+bx+c$ , 则设 $g_{i,j}=f_{i,j}-x=a\cdot (f_{i,j-1}-x)+b\cdot (f_{i-1,j}-x)$</p>
<p>将 $g_{n,n}$ 用上面的方法求出再加上 $x=\frac{c}{1-a-b}$ 即可</p>
</li>
<li><p>观察 $x$ 的值，仅当 $a+b \not\equiv 1\pmod {10^6+3}$</p>
<p>式子转化为 $f_{i,j}=a\cdot f_{i,j-1}+(1-a)f_{i-1,j}+c$</p>
<p>此时两项系数和相等，下标和相等，所以考虑一个与 $i+j$ 有关的函数 $h_{i,j}$</p>
<p>易得 $h_{i,j}=k\cdot (i+j)=k\cdot (i+j-1)+c$ , $\therefore k=c$</p>
<p>$\therefore (f_{i,j}-h_{i,j})=a\cdot(f_{i,j-1}-h_{i,j-1})+(1-a)\cdot(f_{i-1,j}-h_{i-1,j})$</p>
<p>令 $g_{i,j}=f_{i,j}-h_{i,j}$ ，用最上面的方法求 $g_{n,n}$ ，最后加上 $2n\cdot c$</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="P6943-ICPC2018-WF-Conquer-The-World"><a href="#P6943-ICPC2018-WF-Conquer-The-World" class="headerlink" title="P6943 [ICPC2018 WF]Conquer The World"></a>P6943 [ICPC2018 WF]Conquer The World</h2><p>具体思想可参考 $\text{WC}2019$ 论文</p>
<p>把<strong>需要军队的地方</strong>称为老鼠，<strong>军队</strong>为洞，转化为使所有老鼠进洞的总代价最小</p>
<p>为每一个老鼠设一个额外代价 $-\infty$ ，其中 $-\infty$ 是一个足够小的数，表示该老鼠和某个洞匹配后的代价。</p>
<p>因为会最小化总代价，可以保证所有老鼠进洞</p>
<p>只需要最后把答案加上 $-\infty \cdot M$ 即可，其中 $M$ 是老鼠个数</p>
<p>记节点 $i$ 到根的距离为 $depth_i$ ，树上 $Lca$ 为 $z$ 的点 $x,y$ 之间的路径长度为 $depth_x+depth_y-2\times depth_z$</p>
<p>考虑在 $z$ 子树中的所有老鼠和洞，仅需要数值，而不关心具体位置</p>
<p>上述额外代价 $-\infty$ 可与 $depth_x$ 或 $depth_y$ 累加，看做固有属性，记为 $value_x,value_y$</p>
<p>每当我们找到可以使当前总代价减小的匹配，即 $value_x+value_y-2\times depth_z&lt;0$ 的匹配，选取，答案将会变优</p>
<p>但这样找到的匹配可能不是最终答案 $\Rightarrow$ 需要一个反悔</p>
<p>考虑撤销本次匹配的代价，我们可以重新计算得到新的 $value’_x=2\times depth_z-value’_y,value’_y=2\times depth_z-value_x$</p>
<p>所以解法：即从叶子结点出发，向上进行贪心</p>
<p>用两个小根堆来维护子树内 $value_x,value_y$ 的集合，在合并两棵子树的同时合并它们对应的堆。当堆顶元素满足 $value_x+value_y-2\times depth_z&lt;0$ 时更新答案，并删除堆顶元素，加入 $value’_x,value’_y$</p>
<p>可以发现，若一对已经在 $z$ 处匹配的老鼠和洞同时反悔，那么 $z$ 的父边将会被老鼠正反经过两次，因此不反悔是更优的，从而<strong>不可能出现同时反悔的情况</strong></p>
<hr>
<h2 id="P6899-ICPC2014-WF-Pachinko"><a href="#P6899-ICPC2014-WF-Pachinko" class="headerlink" title="P6899 [ICPC2014 WF]Pachinko"></a>P6899 [ICPC2014 WF]Pachinko</h2><p>模型是网格图的随机游走</p>
<p>考虑高斯消元，有 $w\cdot h$ 个未知数，对网格 $(i,j)$ 可以设值为 $X_{i\ast w+j}$</p>
<p>则有公式 $X_{i\ast w+j}=u\cdot X_{w\ast (i-1)+j} + l\cdot X_{w\ast i+(j-1)} + r\cdot X_{w\ast i-(j+1)} + d\cdot X_{w\ast (i+1)+j} + P_{直接选到该格子}$</p>
<p>其中</p>
<script type="math/tex; mode=display">P=\begin{cases}
    \frac{1}{满足该条件的格子数} &i==0 \And \And mp_{i,j}==\text{'.'} \\
    0 &\text{otherwise} \\
\end{cases}</script><p>考虑高斯消元</p>
<p>每个方程只有 $5$ 个未知数，则有值的位置形成了一个带状矩阵</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/fz1t6hbc.png" alt=""></p>
<blockquote>
<p>偷一张<a href="https://ctp314.github.io/2020/10/14/WF2014H-Pachinko/">卢神的图</a></p>
</blockquote>
<p>$\therefore$ 一个未知数只有上 $w$ 行与下 $w$ 行之间的系数不为 $0$</p>
<hr>
<h2 id="P7011-CERC2013-Escape"><a href="#P7011-CERC2013-Escape" class="headerlink" title="P7011 [CERC2013]Escape"></a>P7011 [CERC2013]Escape</h2><p>神仙题</p>
<ul>
<li><p>先考虑最简单的链情况</p>
<p>  $blood$ 的变化为 $w_1,w_1+w_2,w_1+w_2+w_3+\cdots ,w_1+w_2+\cdots+w_n$，只有当所有数均 $\geq 0$ 时游戏胜利</p>
<p>  做一条折线图反映血量变化</p>
<p>  <img src="https://cdn.luogu.com.cn/upload/image_hosting/efbuhkq9.png" style="zoom: 33%;" /></p>
<p>  可以发现中间的部分对我们没有用，有用的是最低值(决定了是否可行)，以及最终能得到的最高值(中间的加减可忽略掉)</p>
<p>  所以可以处理得到</p>
<p>  <img src="https://cdn.luogu.com.cn/upload/image_hosting/43lz9r7u.png" style="zoom:33%;" /></p>
<p>  所以维护这个链上所能得到的最大前缀和以及最小前缀和即可</p>
<p>  所以可以把一条链简化成一个 $pair$ 数组 $[(a_1,b_1),(a_2,b_2),\cdots]$</p>
<p>  注意：这里 $a_1,b_1$ 等<strong>都是正数</strong></p>
<p>  表示折线方向为 $-a_1+b_1-a_2+b_2\cdots$ ，为统一，规定 $a_1$ 一定向下</p>
</li>
<li><p>再考虑树上</p>
<p>  每棵树总可分成多条链来考虑，只考虑两条链即可</p>
<p>  设两条链分别为 $[(a_1,b_1),(a_2,b_2),\cdots]$ 和 $[(c_1,d_1),(c_2,d_2),\cdots]$ ，<del>显然</del>第一步走 $\min(a_1,c_1)$ 是一个不劣的选择</p>
<p>  考虑向 $[(a_1,b_1),(a_2,b_2),\cdots]$ 中插入一个 $pair (x,y)$</p>
<p>  <strong>应该放到最后一个满足 $a_i &lt; x$ 的位置的后面，原因是靠前会影响前缀最小值，使无法继续向下走；靠后则不能充分利用走该处所带来的 $-x+y$ 的优势</strong></p>
</li>
<li><p>具体实现</p>
</li>
</ul>
<ol>
<li>使最终能到 $t$ 点，则设 $t$ 点权值 $\text{INF}$<ol>
<li>显然 $t$ 的子树不需要考虑</li>
<li>选用了 $\text{map}$ 存放 $\text{pair}$ ，即 $mp[a_i]=b_i$</li>
</ol>
</li>
</ol>
<h2 id="P6970-NEERC2016-Game-on-Graph"><a href="#P6970-NEERC2016-Game-on-Graph" class="headerlink" title="P6970 [NEERC2016]Game on Graph"></a>P6970 [NEERC2016]Game on Graph</h2><p>概括题意：</p>
<script type="math/tex; mode=display">\begin{cases}
    A:无限循环>A赢>B赢 \\
    B:B赢>A赢>无限循环 \\
\end{cases}</script><p>设 $v_A$ 表示在节点 $v$ 且 $A$ 先手，$v_B$ 同理</p>
<p>用 $\N+(v)$ 表示 $v$ 通过一条边可到达的所有点集合</p>
<p>定义 $\N+(v_A)$ 中的点表示下一轮轮到 $B$</p>
<ul>
<li><p>先考虑无限循环</p>
<p>对点 $v_A$ 来说，无限循环需要满足 $\exist v_B\in \N+(v_A)$ 使 $v_B$ 无限进行</p>
<p>对点 $v_B$ 来说，需要满足 $\N+(v_B) \not =\empty \And\And \forall v_A\in \N+(v_B)$ 都有 $v_A$ 满足无限循环</p>
<p>出度为 $0$ 的点可以在刚开始时分出胜负，那么不断迭代即可</p>
<p><a href="https://yhx-12243.github.io/OI-transit/records/lg6970%3Bgym101190G.html">可以剩余的点一定为无限循环点</a></p>
</li>
<li><p>考虑胜负</p>
<p>将所有无限进行的状态从图中删去，得到新图，若一个点存在先负的后继状态，则它一定是先胜；若一个点的所有后继状态都是先胜 (含没有后继状态)，则它是先负。</p>
<p>如果遇到圈则一定为 $A$ 赢</p>
</li>
</ul>
<hr>
<h2 id="P6932-ICPC2017-WF-Money-for-Nothing"><a href="#P6932-ICPC2017-WF-Money-for-Nothing" class="headerlink" title="P6932 [ICPC2017 WF]Money for Nothing"></a>P6932 [ICPC2017 WF]Money for Nothing</h2><ul>
<li><p>题意</p>
<p>这道题有个很妙的题意转化</p>
<p>即给定 $m$ 个 $A$ 点的坐标(表示生产商)， $n$ 个 $B$ 点的坐标(消费商)，求一个边与坐标轴平行的矩形，其以 $A$ 类点为右上角， $B$ 类点为左下角，且其面积最大</p>
</li>
<li><p>先考虑显然的单调性</p>
<p>对 $A$ 来说，若存在 $\{x_1,y_1\} , \{x_2,y_2\}$ 满足 $x_2\geq x_1 , y_2\geq y_1$，则只保留 $\{x_2,y_2\}$， $B$ 同理</p>
<p>只维护 $A$ 的左上单调集和 $B$ 的右下单调集</p>
<p>设 $A$ 点 $(x_A,y_A)$，$B$ 点 $(x_B,y_B)$，其形成的矩形面积</p>
<script type="math/tex; mode=display">
\begin{cases}
-\infty & x_b\leq x_r \wedge y_b\leq y_r \\
(x_b-x_r) \cdot (y_b-y_r) & \text{otherwise}
\end{cases}</script><p>易得若有一个 $A$ 点与所有 $B$ 点围成的矩形都为 $-\infty$ 则根据单调性，其余点也只能围成 $-\infty$ 的矩形，故此时答案为 $0$</p>
</li>
<li><p>考虑决策单调性</p>
<p>设 $(x_B,y_B)$ 是与 $A$ 类点 $(x_A,y_A)$ 配对的矩阵面积最大的 $B$ 类点，则对于 $x^{\prime}<x_A , y^{\prime}>y_A ; a^{\prime}&gt;x_B , b^{\prime}&lt;y_B$ ，有 $\displaystyle{\left(a’-x’\right) \cdot \left(b’-y’\right) &lt; \left(x_B-x’\right) \cdot \left(y_B-y’\right)}$</p>
</li>
</ul>
<p>所以可以考虑整体二分</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>学不会的生成函数</title>
    <url>/2021/05/05/%E5%AD%A6%E4%B8%8D%E4%BC%9A%E7%9A%84%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="不知道怎么开始"><a href="#不知道怎么开始" class="headerlink" title="不知道怎么开始"></a>不知道怎么开始</h2><ul>
<li><p>$a=\langle1,1,1,1,1…\rangle$的生成函数是</p>
<script type="math/tex; mode=display">f(x)=x+x^2+x^3+x^4+...</script><p>限定 $x\in(-1,1)$</p>
<script type="math/tex; mode=display">f(x)=\lim_{n\to \infty} \frac{1-x^n}{1-x} = \frac{1}{1-x}</script><p>同理得,函数</p>
<script type="math/tex; mode=display">f(x)=1+x^2+x^4+x^6...=\frac{1}{1-x^2}</script><script type="math/tex; mode=display">f(x)=1+2x+3x^2+4x^3...=\frac{1}{\left(1-x \right)^2}</script><script type="math/tex; mode=display">f(x)=1+3x+6x^2+10x^3+15x^4...=\frac{1}{\left(1-x\right)^3}</script><p>推广有：</p>
<script type="math/tex; mode=display">\frac{1}{\left(1-x\right)^k} 的生成数列是 \sum_i^\infty C_{i+k-1}^{k-1} x^i</script></li>
</ul>
<p>设 $F(z) , G(z)$ 是数列 $\langle \ f_n \ \rangle , \langle \ g_i \ \rangle$ 的生成函数</p>
<ul>
<li><p>相加</p>
<script type="math/tex; mode=display">\begin{aligned}
\alpha F(z)+ \beta G(z)
&= \alpha \sum_n f_nz^n + \beta \sum_ng_nz^n \\
&=\sum_n (\alpha f_n + \beta g_n) z^n\\
\end{aligned}</script><p>得到数列 $\langle \ \alpha f_n+\beta g_n \  \rangle$ 的生成函数</p>
</li>
<li><p>平移生成函数</p>
<ul>
<li><p>向右 $m$ 位</p>
<p>即，构造前面有 $m$ 个 $0$ 的数列 $\langle \ \underbrace{0,\cdots}_{m个},g_0,g_1,\cdots \ \rangle = \langle \ g_{n-m} \ \rangle$ 的生成函数</p>
<p>直接用 $z_m$ 乘</p>
<script type="math/tex; mode=display">z_m \cdot G(z) = \sum_n g_nz^{n+m} = \sum_n g_{n-m}z^n</script></li>
<li><p>向左 $m$ 位</p>
<p>即，构造前面 $m$ 个元素被删除的数列 $\langle \ g_m,g_{m+1},g_{m+2},\cdots \ \rangle$ 的生成函数</p>
<p>减去前 $m$ 项，并用 $z_m$ 来除</p>
<script type="math/tex; mode=display">\frac{G(z)-g_0-g_1z-\cdots -g_{m-1}z^{m-1}}{z^m} = \sum_{n\geq m} g_nz^{n-m} = \sum_{n\geq 0} g_{n+m}g^z</script></li>
</ul>
</li>
<li><p>常数倍的 $z$</p>
<script type="math/tex; mode=display">G(cz) = \sum_ng_n(cz)^n = \sum_n g_nz^n</script><p>即，数列 $\langle \ c^ng_n  \ \rangle$ 的生成函数</p>
<p>当 $c=-1$ 时特别有用</p>
</li>
<li><p>相乘</p>
<script type="math/tex; mode=display">\begin{aligned}
F(z)G(z)
&=(f_0+f_1z+f_2z^2+\cdots ) \cdot (g_0+g_0z+g_0z^2+\cdots) \\
&=(f_0 \cdot g_0) + (f_0\cdot g_1 + f_1 \cdot g_0)z + (f_0\cdot g_2 + f_1\cdot g_1 + f_2 \cdot g_0) z^2 + \cdots \\
&=\sum_n \left(\sum f_k \cdot g_{n-k} \right) z^n \\
\end{aligned}</script><p>求得数列 $\langle \ h_n \ \rangle$ 的生成函数，即数列 $\langle \ f_n \ \rangle , \langle \ g_i \ \rangle$ 的卷积的生成函数</p>
<p>和式 $\displaystyle{h_n=\sum_{k=0}^n f_k \cdot g_{n-k}}$</p>
</li>
</ul>
<p><strong>具体参见具体数学P280 , 表7-1，7-2</strong></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/2021/01/04/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="背包9讲（大概"><a href="#背包9讲（大概" class="headerlink" title="背包9讲（大概"></a>背包9讲（大概</h1><h2 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0/1背包"></a>0/1背包</h2><ul>
<li><p>模型</p>
<p>多种物品,每种物品只有一个.求能获得的最大总价值.</p>
</li>
<li><p>思路</p>
<p>不选择第 $i$ 件物品,就相当用 $i-1$ 件物品,填充了体积为 $v$ 的背包.</p>
<p>选择第 $i$ 件物品，相当于对 $i-1$ 件物品填充得到的体积为  $v-c[i]$ 的背包,再填充第 $i$ 个物品得到体积为 $v$ 的背包.</p>
</li>
<li><p>转移方程</p>
<script type="math/tex; mode=display">f[i][v]=\max(f[i-1][v],f[i-1][v-c[i]]+w[i])</script><p>$f[i][v]$ 代表用 $i$ 件物品填充为体积为 $v$ 的背包得到的最大价值.</p>
</li>
<li><p>注</p>
<p>一般考虑倒序枚举</p>
<p>这样 $f_i$ 不会被 $i$ 以前的状态影响,更新也不会影响其他位置的状态.</p>
</li>
</ul>
<p>-代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//枚举物品</span></span><br><span class="line">	<span class="keyword">for</span>(rei j=V;j&gt;=c[i];j--)<span class="comment">//枚举体积</span></span><br><span class="line">		f[j]=<span class="built_in">max</span>(f[j],f[j-c[i]]+w[i]);<span class="comment">//状态转移方程.</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><ul>
<li><p>模型</p>
<p>每种物品有无限多个,可重复选取.</p>
</li>
</ul>
<p><del>- 思路没有了（与0/1类似（逃</del></p>
<ul>
<li><p>转移方程</p>
<script type="math/tex; mode=display">f[i][v]=\max(f[i-1][v],f[i-1][j-k\ast c[i]]+k\ast w[i])</script></li>
<li><p>注</p>
<p>顺序枚举</p>
<p><a href="https://www.luogu.com.cn/blog/RPdreamer/post-01-bei-bao-yu-wan-quan-bei-bao-di-mei-ju-shun-xu-di-fou-tong-chu">01背包与完全背包的枚举顺序的不同处</a></p>
</li>
<li><p>代码</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//枚举物品</span></span><br><span class="line">	<span class="keyword">for</span>(rei j=c[i];j&lt;=V;j++)<span class="comment">//枚举体积</span></span><br><span class="line">		f[j]=<span class="built_in">max</span>(f[j,f[j-c[i]]]+w[i]);<span class="comment">//状态转移.</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><ul>
<li><p>模型</p>
<p>有了个数的限制</p>
</li>
</ul>
<p><del>- 思路不想写了</del></p>
<pre><code>朴素做法就是把每种物品都拆成 size 个物品跑0/1背包
</code></pre><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul>
<li><p>二进制拆分</p>
<p>易知 $size_i=2^0+2^1+2^2+2^3…+2^x+y$</p>
<p>其 $k$ 是任意数，$y$ 是一个不为2的整数次幂的数</p>
<p>所以在多重背包中，可以将个数的限制如此分解</p>
<p>每个分解看成一个物品</p>
<p>(如： $2^2$ 看成 $1$ 个物品，该物品 $val=4\cdot val_i \space, \space w=4\cdot w_i$)</p>
<p>如此进行后就是 $\log (size)$</p>
<ul>
<li><p>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Good</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,w;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Good&gt; g;</span><br><span class="line"></span><br><span class="line">···</span><br><span class="line"><span class="comment">//对每个读入的v,w,s</span></span><br><span class="line"><span class="keyword">for</span>(rei k=<span class="number">1</span>;k&lt;=s;k*=<span class="number">2</span>)&#123;</span><br><span class="line">    s-=k;</span><br><span class="line">    g.<span class="built_in">push_back</span>(&#123;v*k,w*k&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(s) g.<span class="built_in">push_back</span>(&#123;v*s,w*s&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//总dp</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> good:g)&#123;</span><br><span class="line">    <span class="keyword">for</span>(rei j=m;j&gt;=good.v;--j)&#123;</span><br><span class="line">        f[j]=<span class="built_in">max</span>(f[j],f[j-good.v]+good.w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>单调队列优化</p>
<p>这是一个最基本的转移式子</p>
</li>
</ul>
<p>$f[i][j]=\max(f[i−1][j],f[i−1][j−k\ast c[i]]+k\ast w[i])$</p>
<p>其中 $k \in [1,\min(\left\lfloor\frac{V}{c[i]}\right\rfloor,num[i])]$</p>
<p>下面用 $lim$ 表示 $\min(\left\lfloor\frac{V}{c[i]}\right\rfloor,num[i])$</p>
<p>易得 $f[i][j−k\cdot c[i]]$ 会被 $f[i][j−(k+1)\cdot c[i]]$ 影响</p>
<p>(体积为 $c[i]$ 的物品填充体积为 $j−(k+1)\cdot c[i]$ 的背包,会得到体积为 $j−k\cdot c[i]$ 的背包)</p>
<p>$f[i][j]$ 将会影响 $f[i][j+k\cdot c[i]]　(j+k\cdot c[i]\leq V)$</p>
<p>注意这里影响的传导，往取模上想</p>
<p>所以我们可以根据对 $c[i]$ 取模得到的余数进行分组.</p>
<p>即可分为 $0,1,2,3…c[i]−1$ 共 $c[i]$ 组</p>
<p>每组之间的状态互相没有影响</p>
<p>且每组中位置靠后的受前面的影响</p>
<ul>
<li><p>进行一些推导</p>
<p>注： $\frac{j}{c[i]}即是全选状态下的物品个数$</p>
<script type="math/tex; mode=display">\because j=\frac{j}{c[i]} \ \cdot \ c[i] \ +\ j\% c[i]</script><script type="math/tex; mode=display">\therefore j−k∗c[i]=\frac{j}{c[i]}\cdot c[i] \ +\ j\% c[i] \ −\ k\cdot c[i]</script><script type="math/tex; mode=display">\space \space \space \space \space \space \space \space \space =(\frac{j}{c[i]} \ −\ k)\cdot c[i]+j \% c[i]</script><p>令 $(\frac{j}{c[i]}−k)=k^{‘}$</p>
<p>最原始的状态转移方程中第二状态 :</p>
<p>$f[i][j−k\cdot c[i]\ ]+k\cdot w[i]$ 代表选择 $k$ 个当前 $i$ 物品</p>
<p>根据单步容斥 ：全选−不选=选</p>
<p>因此 $\frac{j}{c[i]} \ −\ (\frac{j}{c[i]}−k)=k$</p>
<script type="math/tex; mode=display">\because (\frac{j}{c[i]}−k)=k^{'}</script><script type="math/tex; mode=display">\therefore f[i][j]=\max( \ f[i−1][\ k^{'}\cdot c[i]+j \% c[i] \ ] \ + \ \frac{j}{c[i]}\cdot w[i]−k^{'}\cdot w[i])</script><p>而其中 $\frac{j}{c[i]}\cdot w[i]$ 为一个常量(因为 $\frac{j}{c[i]}$ 已知)</p>
<p>要求的状态变为</p>
<script type="math/tex; mode=display">f[i][j]=\max(f[i−1][ \ k^{'}\cdot c[i]+j\% c[i] \ ]−k^{'}\cdot w[i])+\frac{j}{c[i]}\cdot w[i]</script><script type="math/tex; mode=display">\because k \in [1,lim]</script><script type="math/tex; mode=display">\therefore k^{'} \in [\frac{j}{c[i]}−k,\frac{j}{c[i]}]</script><p>当前的 $f[i][j]$ 求解的就是为 $lim+1$ 个数对应的 $f[i−1][k^{‘}\cdot c[i]+j\% c[i] \ ]−k^{‘}\cdot w[i]$ 的最大值.</p>
<p>(之所以为 $lim+1$ 个数,是包括当前这个 $j$ ,还有前面的物品数量)</p>
<p>将 $f[i][j]$ 前面所有的 $f[i−1][k^{‘}\cdot c[i]+j\% c[i]\ ]−k^{‘}\cdot w[i]$ 放入一个队列.</p>
<p>问题转化为求这个最长为 $lim+1$ 的队列的最大值 $+\frac{j}{c[i]}\cdot w[i]$</p>
</li>
<li><p>代码</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">//枚举物品种类</span></span><br><span class="line">    cin&gt;&gt;c[i]&gt;&gt;w[i]&gt;&gt;num[i];<span class="comment">//c,w,num分别对应 体积,价值,个数</span></span><br><span class="line">    <span class="keyword">if</span>(V/c[i] &lt; num[i]) num[i]=V/c[i];<span class="comment">//求lim</span></span><br><span class="line">    <span class="keyword">for</span>(rei p=<span class="number">0</span>;p&lt;c[i];p++)&#123;<span class="comment">//枚举余数</span></span><br><span class="line">        head=tail=<span class="number">0</span>;<span class="comment">//队列初始化</span></span><br><span class="line">        <span class="keyword">for</span>(rei k=<span class="number">0</span>;k&lt;=(V-p)/c[i];k++)&#123;</span><br><span class="line">            rei x=k;</span><br><span class="line">            rei y=f[k*c[i]+p]-k*w[i];</span><br><span class="line">            <span class="keyword">while</span>(head&lt;tail &amp;&amp; q[head].pos&lt;k-num) ++head;<span class="comment">//限制长度</span></span><br><span class="line">            <span class="keyword">while</span>(head&lt;tail &amp;&amp; q[tail<span class="number">-1</span>].value&lt;=y) --tail;</span><br><span class="line">            q[tail].value=y,q[tail].pos=x;</span><br><span class="line">            ++tail;</span><br><span class="line">            f[k*c[i]+p]=q[head].value+k*w[i];</span><br><span class="line">            <span class="comment">//单调队列维护的是前i-1种的状态最大值.</span></span><br><span class="line">            <span class="comment">//因此这里加上k*w[i].</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="混合背包"><a href="#混合背包" class="headerlink" title="混合背包"></a>混合背包</h2><ul>
<li><p>思路</p>
<p>拆开分别算即可</p>
</li>
<li><p>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">    rei v,w,s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;v,&amp;w,&amp;s);</span><br><span class="line">    <span class="keyword">if</span>(s&lt;<span class="number">0</span>) things.<span class="built_in">push_back</span>(&#123;<span class="number">-1</span>,v,w&#125;);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!s) things.<span class="built_in">push_back</span>(&#123;<span class="number">0</span>,v,w&#125;);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(rei k=<span class="number">1</span>;k&lt;=s;k*=<span class="number">2</span>)&#123;</span><br><span class="line">            s-=k;</span><br><span class="line">            things.<span class="built_in">push_back</span>(&#123;<span class="number">-1</span>,v*k,w*k&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s&gt;<span class="number">0</span>) things.<span class="built_in">push_back</span>(&#123;<span class="number">-1</span>,v*s,w*s&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> thing : things)&#123;</span><br><span class="line">    <span class="keyword">if</span>(thing.kind&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(rei j=m;j&gt;=thing.v;--j)</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-thing.v]+thing.w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(rei j=thing.v;j&lt;=m;++j)</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-thing.v]+thing.w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="二维费用背包"><a href="#二维费用背包" class="headerlink" title="二维费用背包"></a>二维费用背包</h2><ul>
<li><p>模型</p>
<p>有容量 $v$ 与重量 $w$ 两个限制</p>
</li>
<li><p>思路</p>
<p>限制扩展到二维即可</p>
</li>
<li><p>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">    rei a,b,c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    <span class="keyword">for</span>(rei j=v;j&gt;=a;--j)</span><br><span class="line">        <span class="keyword">for</span>(rei k=m;k&gt;=b;--k)</span><br><span class="line">            f[j][k]=<span class="built_in">max</span>(f[j][k],f[j-a][k-b]+c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h2><ul>
<li><p>模型</p>
<p>每组若干个物品，每个物品组内的物品互斥（只能选一个）</p>
</li>
<li><p>转移方程</p>
<script type="math/tex; mode=display">f[k][v]=\max(f[k-1][v],f[k-1][v-c[i]]+w[i])</script></li>
<li><p>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//每一组</span></span><br><span class="line">    rei s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;s);</span><br><span class="line">    <span class="keyword">for</span>(rei j=<span class="number">0</span>;j&lt;s;++j) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;v[j],&amp;w[j]);</span><br><span class="line">    <span class="keyword">for</span>(rei j=m;j&gt;=<span class="number">0</span>;--j)<span class="comment">//枚举体积</span></span><br><span class="line">        <span class="keyword">for</span>(rei k=<span class="number">0</span>;k&lt;s;++k)<span class="comment">//枚举物品</span></span><br><span class="line">            <span class="keyword">if</span>(j&gt;=v[k])</span><br><span class="line">                f[j]=<span class="built_in">max</span>(f[j],f[j-v[k]]+w[k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="有依赖的背包"><a href="#有依赖的背包" class="headerlink" title="有依赖的背包"></a>有依赖的背包</h2><ul>
<li><p>模型</p>
<p>物品间有依赖关系，且依赖关系组成一棵树</p>
<p>为选取某节点，必须选取该节点的父节点</p>
<p>eg:<strong>选课问题</strong></p>
</li>
<li><p>思路</p>
<p>对每个点，dfs其子节点再dp</p>
<p>特别注意子节点dp体积时要给父节点留下空间</p>
<p>详见代码</p>
</li>
<li><p>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(rei i=head[u];i!=<span class="number">-1</span>;i=Next[i])&#123;</span><br><span class="line">        rei son=ver[i];</span><br><span class="line">        <span class="built_in">dfs</span>(son);</span><br><span class="line">        <span class="keyword">for</span>(rei j=m-v[u];j&gt;=<span class="number">0</span>;--j)<span class="comment">//注意，这里要留出当前点的体积再去dp其子节点</span></span><br><span class="line">            <span class="keyword">for</span>(rei k=<span class="number">0</span>;k&lt;=j;++k)</span><br><span class="line">                f[u][j]=<span class="built_in">max</span>(f[u][j],f[u][j-k]+f[son][k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=m;i&gt;=v[u];--i) f[u][i]=f[u][i-v[u]]+w[u];<span class="comment">//加上当前点</span></span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;v[u];++i) f[u][i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title>树链剖分</title>
    <url>/2021/07/01/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/</url>
    <content><![CDATA[<h2 id="关于长链剖分中指针的理解"><a href="#关于长链剖分中指针的理解" class="headerlink" title="关于长链剖分中指针的理解"></a>关于长链剖分中指针的理解</h2><p>与指针有关的变量：$\ast dp[N],tmp[N]$,$\ast pos$</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pos=tmp;<span class="comment">//将pos指向tmp空间</span></span><br><span class="line">dp[<span class="number">1</span>]=pos, pos+=height[<span class="number">1</span>];</span><br><span class="line">   <span class="comment">//改变后pos加上dp[1]所需的长度，防止内存冲突</span></span><br></pre></td></tr></table></figure>
<p>可以把 $*dp[1]$ 看成指向 $tmp$ 上一段长为 $height[1]$ 的指针</p>
<p>那么指针 $dp[1]$ 与 $tmp[\ 0,…height[1]-1 \ ]$ 共同构成了 $dp[1][\ 0,…,height[1]-1\ ]$</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dp[to]=pos, pos+=len;</span><br></pre></td></tr></table></figure>
<p>与上面相同，在进入 $dfs2$ 前开好 $dp[to]$ 所需的空间，即以 $to$ 为起点的链，其长度为 $len$</p>
<p>而对于链上其他点(即点 $to$ 的长儿子，其长儿子的长儿子，…)，不会进入当前行，即不需开新空间</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dp[son[cur]] = dp[cur] + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>即继承长儿子的答案: $dp[i][j]=dp[lson][j-1]$</p>
<p>数组指针形式：$dp[\ i\ ]=dp[\ lson[\ i\ ]\ ]-1$</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dp[cur][j+<span class="number">1</span>] += dp[to][j];</span><br></pre></td></tr></table></figure>
<p>暴力合并轻儿子的值</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/utbnpeqk.png" alt=""></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>确实不会的多项式</title>
    <url>/2021/05/05/%E7%A1%AE%E5%AE%9E%E4%B8%8D%E4%BC%9A%E7%9A%84%E5%A4%9A%E9%A1%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="写总结的地方"><a href="#写总结的地方" class="headerlink" title="写总结的地方"></a>写总结的地方</h2><ul>
<li>将式子转化为卷积形式: $\displaystyle{\sum_{i=1}^n A_i B_{n-i}}$</li>
</ul>
<h3 id="P3338-ZJOI2014-力"><a href="#P3338-ZJOI2014-力" class="headerlink" title="P3338 [ZJOI2014]力"></a><a href="https://www.luogu.com.cn/problem/P3338">P3338 [ZJOI2014]力</a></h3><ul>
<li><p>题意：<br>求 $E_j=\displaystyle{\sum_{i=1}^{j-1}\frac{q_j}{\left(i-j\right)^2} - \sum_{i=j+1}^n \frac{q_j}{\left(i-j\right)^2}}$</p>
<p>$q_i被消掉了qwq$</p>
</li>
<li><p>解：</p>
<ul>
<li><p>先简化数据范围</p>
<script type="math/tex; mode=display">\sum_{i=1}^{j-1} \Rightarrow \sum_{i=0}^{j}</script></li>
<li><p>化成能算的样子</p>
<p>设 $f[i]=q_j \ , f’[i]=f[n-i] \ , \ g[i]=\frac{1}{i^2}$</p>
<script type="math/tex; mode=display">\begin{aligned}
原式
&=\underbrace{\sum_{i=1}^j f[i] \cdot g[j-i]}_{\rm 已经是卷积形式} - \sum_{i=j}^n f[i] \cdot g[i-j] \\
&=\sum_{i=1}^j f[i] \cdot g[j-i] - \underbrace{\sum_{i=0}^{n-j} f[i+j] \cdot g[i]}_{\rm 然而还不能算} \\
&设 t=n-j \\
&=\sum_{i=1}^j f[i] \cdot g[j-i] - \sum_{i=0}^t f'[t-i] \cdot g[i] \\
\end{aligned}</script></li>
</ul>
<p>$\bf{Trick:}$ <strong>翻转数列</strong> </p>
<p>&amp;&amp; 把函数设成数组以看起来更好算</p>
</li>
</ul>
<h3 id="P3723-AH2017-HNOI2017-礼物"><a href="#P3723-AH2017-HNOI2017-礼物" class="headerlink" title="P3723 [AH2017/HNOI2017]礼物"></a><a href="https://www.luogu.com.cn/problem/P3723">P3723 [AH2017/HNOI2017]礼物</a></h3><ul>
<li><p>题意：</p>
<p>给定两个序列 $a,b$ ，顺序可以移动，求 $\displaystyle{\sum_{i=1}^n \left(a_i-b_i+c \right)^2}$ 最小值</p>
</li>
<li><p>解：</p>
<script type="math/tex; mode=display">原式=\underbrace{\sum_{i=1}^n a_i^2+\sum_{i=1}^n b_i^2}_{\rm [一]可以预处理} - \underbrace{\sum_{i=1}^n a_ib_i}_{\rm [二]见下面} + \underbrace{nc^2 + 2c\left(\sum_{i=1}^na_i - \sum_{i=1}^nb_i \right)}_{\rm [三]关于 c 的二次函数}</script><p>由题：要取 $\displaystyle{\sum_{i=1}^n a_ib_i}$ 的最大值</p>
<p>考虑移动 $k$ 位时：</p>
<p>先把环 $b$ 变为链 $\Rightarrow$ $b[i+n]=b[i]$</p>
<p>转化为考虑 $\displaystyle{\sum_{i=1}^n a_ib_{i+k} }$</p>
<p>翻转 $a$ 得 $\displaystyle{\sum_{i=1}^n b_{i+k} \cdot a_{n-i+1}}$ ， 符合卷积形式</p>
<p>$\therefore \tt{FFT}\left(a_{reserved}\right),\tt{FFT}(b)$</p>
<p>$\bf{Trick:}$ 由于 $c$ 是整数，用二次函数对称轴来算 [式三],比枚举 $-100\leq c \geq 100$ 更好</p>
<p>算出$\left\lfloor -\frac{a}{b} \right\rfloor$ 和 $\left\lceil -\frac{a}{b} \right\rceil$ ， 取 $\min$</p>
</li>
</ul>
<h3 id="P5488-差分与前缀和"><a href="#P5488-差分与前缀和" class="headerlink" title="P5488 差分与前缀和"></a><a href="https://www.luogu.com.cn/problem/P5488">P5488 差分与前缀和</a></h3><ul>
<li><p>题意：</p>
<p>求数列 $a$ 的 $k$ 维前缀和或差分</p>
</li>
<li><p>解：</p>
<p>设 $\displaystyle{F(x)=\sum_{i=0}^\infty a_ix^i }$</p>
<ul>
<li><p>前缀和</p>
<p>比较前缀和与卷积</p>
<p>$\displaystyle{a_i=\sum_{j=1}^i a_j \qquad \And\And \qquad S_i=\sum_{j=1}^i A_j B_{i-j}}$</p>
<p>发现需要卷一个系数都为 $1$ 的多项式 $G(x)$</p>
<p>以样例为例：</p>
<script type="math/tex; mode=display">\begin{aligned}
&F(x)*G(x) \\
&=(1+9x+2x^2+6x^3+0x^4+8x^6+7x^7) \cdot (1+x+x^2+x^3+x^4+ \cdots +x^{\infty}) \\
&=1+\underbrace{9x^1 + \underbrace{2x^2 + \underbrace{6x^3 + \underbrace{0x^4 + \underbrace{8x^6 + \underbrace{7x^7}_{\rm 系数+8}}_{\rm 系数+0}}_{\rm 系数+6}}_{\rm 系数+2}}_{\rm 系数+9}}_{\rm 系数+1}
\end{aligned}</script></li>
</ul>
</li>
</ul>
<pre><code>发现 $F(x)\cdot G(x)$ 所得多项式就是 $F$ 的一阶前缀和

$\displaystyle&#123;\therefore 显然有 G(x)=\frac&#123;1&#125;&#123;1-x&#125;&#125;$

$\displaystyle&#123;\therefore k阶前缀和 \Rightarrow
 F(x) \cdot \frac&#123;1&#125;&#123;\left(1-x \right)^k&#125;&#125;$

$\displaystyle&#123;\frac&#123;1&#125;&#123;\left(1-x \right)^k&#125; 的第 n 项系数就是 \dbinom&#123;n+k-1&#125;&#123;k-1&#125; &#125;$

$\displaystyle&#123;\therefore a_i=\sum_&#123;j=1&#125;^&#123;i-1&#125;\dbinom&#123;j+k-1&#125;&#123;k-1&#125; \cdot a_&#123;i-j&#125; &#125;$

设组合数递推式 $g_i=\dbinom&#123;i+k-1&#125;&#123;k-1&#125;$

$$\begin&#123;aligned&#125;
\therefore
g_i
&amp;=\frac&#123;g_&#123;i-1&#125;\times (k+i-1)&#125;&#123;i&#125;\%p &amp;\text&#123;只会在计算中用到这个&#125;\\
&amp;=\left(\frac&#123;g_&#123;i-1&#125; &#125;&#123;i&#125;\%p \right)\times ((k+i-1)\%p) \\
&amp;=\left(\frac&#123;g_&#123;i-1&#125; &#125;&#123;i&#125;\%p \right)\times ((k\%p+i-1)\%p) \\ &amp;\text&#123;只是为了推 $k$ 可以取模&#125; \\
\end&#123;aligned&#125;$$
</code></pre><p>  $\therefore$ 可以对 $k$ 取模</p>
<ul>
<li><p>差分</p>
<p>易得 $F(x) \times (1-x)$ 所得的多项式就是差分后</p>
<p>  同理得 $\left(1-x\right)^k$</p>
<script type="math/tex; mode=display">\begin{aligned}
  B
  &=F(x) \cdot \left(1-x\right)^k \\
  &=F(x) \cdot \sum_{i=0}^{\infty} \dbinom{k}{i} \left(-x \right)^i \\
&=F(x) \cdot \sum_{i=0}^{\infty} \left(-1 \right)^i \cdot \dbinom{k}{i} x^i \\
  \end{aligned}</script><p>  看组合数递推式: $\dbinom{k}{i}$</p>
<script type="math/tex; mode=display">\dbinom{k}{0}=1</script><script type="math/tex; mode=display">\dbinom{k}{1}=\frac{k!}{(k-1)!}=k</script><script type="math/tex; mode=display">\dbinom{k}{2}=\frac{k!}{2!(k-2)!}=\frac{k(k-1)}{2}</script><script type="math/tex; mode=display">\dbinom{k}{3}=\frac{k!}{3!(k-3)!}=\frac{k(k-1)(k-2)}{2\times 3}</script><script type="math/tex; mode=display">\dbinom{k}{i}=\dbinom{k}{i-1} \cdot \frac{k-i+1}{i} \qquad\text{用这个递推}</script></li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代加深</title>
    <url>/2021/04/07/%E8%BF%AD%E4%BB%A3%E5%8A%A0%E6%B7%B1/</url>
    <content><![CDATA[<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><ul>
<li><p>答案求最小步数</p>
</li>
<li><p>在某步数内一定可以完成 或 超出某步数认为无解</p>
</li>
</ul>
<hr>
<h3 id="随便写点注意事项"><a href="#随便写点注意事项" class="headerlink" title="随便写点注意事项"></a>随便写点注意事项</h3><ul>
<li><p>注意估值函数的选取</p>
<p>一般为 <strong>当前状态到最终状态的最短步数+已走的步数</strong>  是否大于 <strong>枚举的深度</strong></p>
<ul>
<li>在[ $flood \ it$ ] 中：定义了专门的求估值函数（好像就变成IDA*了</li>
</ul>
</li>
<li><p>$\text{dfs}(now+1)$ 失败后及时回复现场</p>
<ul>
<li><p>$eg$ : [ $八数码难题$ ] 中：<strong>通过两数交换</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">swap</span>(sta[nx][ny],sta[x][y]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">test</span>(step)) <span class="built_in">A</span>(step+<span class="number">1</span>,nx,ny,i);</span><br><span class="line"></span><br><span class="line"><span class="built_in">swap</span>(sta[nx][ny],sta[x][y]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>$eg$ : [ $骑士精神$ ] 中：<strong>毫无可读性的两数交换</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a[x][y]^=a[xx][yy],a[xx][yy]^=a[x][y],a[x][y]^=a[xx][yy];<span class="comment">//什么是swap</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> flag=<span class="built_in">dfs</span>(step+<span class="number">1</span>,maxstep,tmp,xx,yy,i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">a[x][y]^=a[xx][yy],a[xx][yy]^=a[x][y],a[x][y]^=a[xx][yy];<span class="comment">//回复现场</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>$eg$ : [ $flood \ it$ ] 中：<strong>通过对数组的交换</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(tmp,vis,<span class="keyword">sizeof</span> vis);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">fill</span>(i) &amp;&amp; <span class="built_in">dfs</span>(now+<span class="number">1</span>)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(vis,tmp,<span class="keyword">sizeof</span> vis);<span class="comment">//还原</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>在枚举每次状态改变时，注意及时的剪枝，即使是看起来并不重要的</p>
<ul>
<li><p>栗子 $1$：出界</p>
<p>好容易忘qwq（写总结的时候也忘了</p>
</li>
<li><p>栗子 $2$：当前移动恰与上一步相反</p>
<ul>
<li><p>剪枝方法：</p>
<p>仔细选取 $dx[ \ ],dy[ \ ]$</p>
<p>判断两次移动的方向和 $i+pre$</p>
</li>
<li><p>$eg$ : [ $骑士精神$ ] 中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">8</span>]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dy[<span class="number">8</span>]=&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如此保证两个相反的方向加和为7</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>栗子 $3$：当前步恰好完成,或通过估价函数得到当前步可行</p>
<ul>
<li><p>$eg$ : [$Power \ Calculus$] 中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(now==n || now&lt;&lt;(MAX-step)==n<span class="comment">/*题目背景可推断*/</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>$eg$ : [$flood \ it$] 中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">rei g=<span class="built_in">get_val</span>();</span><br><span class="line">···</span><br><span class="line"><span class="keyword">if</span>(!g) <span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>栗子 $4$：针对当前块的扩展问题，要得到周围与之相邻的块的编号（我不知道我在写什么</p>
<ul>
<li><p>剪枝方法：</p>
<p>开 $vis[ \ ]$ 数组并及时维护</p>
</li>
<li><p>$eg$ : [ $flood \ it$ ] 中：</p>
<p><del>自行读代码</del></p>
</li>
</ul>
</li>
<li><p>栗子 $5$：考虑答案的单调性</p>
<ul>
<li><p>$eg$ : [$Addition \ Chains$] 中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(rei i=<span class="number">0</span>;i&lt;now;++i)</span><br><span class="line">    <span class="keyword">for</span>(rei j=i;j&lt;now;++j)&#123;<span class="comment">//从i开始啊qwq</span></span><br><span class="line">        rei tmp=ans[i]+ans[j];</span><br><span class="line">        <span class="keyword">if</span>(tmp&gt;n) <span class="keyword">break</span>;<span class="comment">//ans单增</span></span><br><span class="line">        <span class="keyword">if</span>(tmp&lt;=ans[now<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        ans[now]=tmp;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(now+<span class="number">1</span>,MAX)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>注意一下开始 $\text{dfs}$ 的深度为 $0/1$</p>
<p>关系到答案输出是 $MAX$ 还是 $MAX-1$</p>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>迭代加深</tag>
      </tags>
  </entry>
  <entry>
    <title>超几何分布中的期望</title>
    <url>/2021/07/18/%E8%B6%85%E5%87%A0%E4%BD%95%E5%88%86%E5%B8%83%E4%B8%AD%E7%9A%84%E6%9C%9F%E6%9C%9B/</url>
    <content><![CDATA[<h2 id="超几何分布"><a href="#超几何分布" class="headerlink" title="超几何分布"></a>超几何分布</h2><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>对于 $N=N_1+N_2$ 个外表相同的物品，从中抽取 $n$ 个物品，每个物品抽取等概率随机</p>
<hr>
<h3 id="n-个中有-x-个-N-1-类物品的概率"><a href="#n-个中有-x-个-N-1-类物品的概率" class="headerlink" title="$n$ 个中有 $x$ 个 $N_1$ 类物品的概率"></a>$n$ 个中有 $x$ 个 $N_1$ 类物品的概率</h3><p>首先，若 $x&gt;N_1$ 概率为 $0$ ，故不需考虑</p>
<p>对于所取的 $n$ 个数，若满足条件：</p>
<p>- 从 $N_1$ 个中抽 $x$ 个 ， 有 $\displaystyle{\binom{N_1}{x}}$ 种</p>
<p>- 从 $N_2$ 个中抽 $n-x$ 个 ， 有 $\displaystyle{\binom{N_2}{n-x}}$ 种</p>
<p>所以总合法取法有 $\displaystyle{\binom{N_1}{x} \binom{N_2}{n-x}}$ 种 ， 而总取法有 $\displaystyle{\binom{N}{n}}$</p>
<script type="math/tex; mode=display">\therefore P(X=x)= \frac{\binom{N_1}{x} \binom{N_2}{n-x}}{\binom{N}{n}}</script><hr>
<h3 id="抽出-x-个-N-1-的期望"><a href="#抽出-x-个-N-1-的期望" class="headerlink" title="抽出 $x$ 个 $N_1$ 的期望"></a>抽出 $x$ 个 $N_1$ 的期望</h3><script type="math/tex; mode=display">E(x)=\sum_{x=0}^{N_1} x\times P(X=x) =\sum_{x=1}^{N_1} x\times P(X=x)</script><p>由组合数公式 $\displaystyle{\binom{N}{n}=\frac{N}{n} \binom{N-1}{n-1}}$ 得</p>
<script type="math/tex; mode=display">\begin{aligned}原式

&=\sum_{x=1}^{N_1} x\times \frac{ \frac{N_1}{x} \binom{N_1-1}{x-1} \binom{N_2}{n-x} }{ \frac{N}{n} \binom{N-1}{n-1}} \\

&=\frac{n\times N_1}{N} \sum_{x=1}^{N_1} \frac{ \binom{N_1-1}{x-1} \binom{N_2}{n-x}}{ \binom{N-1}{n-1}} \\

&=\frac{n\times N_1}{N} \sum_{x=1}^{N_1} \frac{ \binom{N_1-1}{x-1} \binom{N_2}{(n-1)-(x-1)}}{ \binom{N-1}{n-1}} \\

&=\frac{n\times N_1}{N} \sum_{x=1}^{N_1} P(X=x-1)

\end{aligned}</script><script type="math/tex; mode=display">\because \sum_{x=1}^{N_1} P(X=x-1) 的含义为：n 中有 x-1 个 N_1 的概率和</script><script type="math/tex; mode=display">\therefore \sum_{x=1}^{N_1} P(X=x-1)=1</script><script type="math/tex; mode=display">\therefore 原式=\frac{n\times N_1}{N}</script>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title>莫比乌斯反演</title>
    <url>/2021/01/06/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/</url>
    <content><![CDATA[<p>暂停更新，遇见再更</p>
<p>闲下来取写题单</p>
<h2 id="某些前置知识"><a href="#某些前置知识" class="headerlink" title="某些前置知识"></a>某些前置知识</h2><hr>
<h3 id="整除分块"><a href="#整除分块" class="headerlink" title="整除分块"></a>整除分块</h3><ul>
<li><p><strong>qwq</strong></p>
<p><del>众所周知</del></p>
<p>$a\%b=a-b*\left\lfloor \frac{a}{b} \right\rfloor$</p>
</li>
<li><p>规定：</p>
<p>当前块的左端点 $l$，块值 $k$，右端点 $r$</p>
</li>
<li><p>用途：</p>
<p>快速处理形如</p>
<script type="math/tex; mode=display">\sum ^n_{i=1} \left\lfloor\frac{n}{i}\right\rfloor</script><p>的式子</p>
</li>
<li><p>用法：</p>
<p>代入一个 $n$ 可发现某些 $\left\lfloor \frac{n}{i} \right\rfloor$ 的值相同且呈块状分布</p>
<p>对于一个起始下标为 $l$ 的块，其终止下标为 $\left\lfloor \frac{n}{\left\lfloor \frac{n}{l} \right\rfloor} \right\rfloor$</p>
</li>
<li><p>证明：</p>
<p>对于该块中的每个数 $i$，有 $k=\left\lfloor \frac{n}{i} \right\rfloor=\left\lfloor \frac{n}{l} \right\rfloor$</p>
<p>即 $ik \leq n$</p>
<p>所以要找到使 $ik \leq n$ 成立的最大值</p>
<p>所以得到：</p>
<script type="math/tex; mode=display">
\begin{cases}
k=\left\lfloor \frac{n}{l} \right\rfloor \\
r=\max(i) , ik \leq n\\
\end{cases}</script><p>推导得 $r=\left\lfloor \frac{n}{k} \right\rfloor = \left\lfloor \frac{n}{\left\lfloor \frac{n}{l} \right\rfloor} \right\rfloor$</p>
</li>
<li><p>例题</p>
<p><a href="https://www.luogu.com.cn/problem/P2261">P2261 [CQOI2007]余数求和</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ans=n*k;</span><br><span class="line"><span class="keyword">for</span>(ll l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(k/l)</span><br><span class="line">        r=<span class="built_in">min</span>(n,k/(k/l));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        r=n;</span><br><span class="line">    ans-=( (r-l+<span class="number">1</span>)*(l+r)/<span class="number">2</span> <span class="comment">/*等差数列*/</span>) *(k/l)<span class="comment">/*块值*/</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://blog.csdn.net/weixin_43627118/article/details/104024380">拓展</a></p>
<ul>
<li><p>例1</p>
<script type="math/tex; mode=display">求 \sum^n_{i=1} \left\lfloor \frac{n}{ai+b} \right\rfloor</script><ul>
<li><p>[一]</p>
<script type="math/tex; mode=display">
\begin{cases}
k=\left\lfloor \frac{n}{al+b} \right\rfloor \\
r=\max(i) , (ai+b)k \leq n\\
\end{cases}</script><script type="math/tex; mode=display">\because (ai+b)k \leq n</script><script type="math/tex; mode=display">\therefore i \leq \frac{n-bk}{ak}</script><script type="math/tex; mode=display">\therefore r=\max(i)=\left\lfloor \frac{n-bk}{ak} \right\rfloor</script></li>
<li><p>[二]通法</p>
<script type="math/tex; mode=display">令 r^*=ai+b</script><script type="math/tex; mode=display">\therefore r^*=\left\lfloor \frac{n}{k} \right\rfloor \ , \ k=\left\lfloor \frac{n}{al+b} \right\rfloor</script><script type="math/tex; mode=display">\therefore r^*=\left\lfloor \frac{n}{\left\lfloor \frac{n}{al+b} \right\rfloor} \right\rfloor</script><script type="math/tex; mode=display">
\begin{cases}
r^*=ai+b \\
r=\max(i)\\
i=\frac{r^*-b}{a}\\
\end{cases}</script><script type="math/tex; mode=display">\therefore r=\left\lfloor \frac{r^*-b}{a} \right\rfloor</script><script type="math/tex; mode=display">\therefore r=\left\lfloor \frac { \left\lfloor \frac{n}{ \left\lfloor \frac{n}{al+b} \right\rfloor } \right\rfloor -b} {a} \right\rfloor</script></li>
</ul>
</li>
<li><p>例2</p>
<p>$求\sum^n_{i=1} \left\lfloor \frac{n}{i^2} \right\rfloor$</p>
<ul>
<li><p>按通法推导</p>
<p>令$r^*=r^2$</p>
<script type="math/tex; mode=display">
\begin{cases}
k=\left\lfloor \frac{n}{l^2} \right\rfloor \\
r^*=\left\lfloor \frac{n}{k} \right\rfloor \\
\end{cases}</script><script type="math/tex; mode=display">
\begin{cases}
r^*=\left\lfloor \frac{n}{ \left\lfloor \frac{n}{l^2} \right\rfloor } \right\rfloor \\
i=\sqrt{i^*} \\
r=\max(i) \\
\end{cases}</script><script type="math/tex; mode=display">\therefore r=\left\lfloor \sqrt{ \frac{n}{ \left\lfloor \frac{n}{l^2} \right\rfloor } } \right\rfloor</script></li>
</ul>
</li>
<li><p>例3</p>
<ul>
<li><p>求 $\sum^n_{i=1} \left\lceil \frac{n}{i} \right\rceil$</p>
<p><strong>转化</strong>：加上 $\frac{i-1}{i}$ 即可</p>
<p>问题转化为</p>
<script type="math/tex; mode=display">求\sum^n_{i=1} \left\lfloor \frac{n+i-1}{i} \right\rfloor</script><script type="math/tex; mode=display">\because
\begin{cases}
k=\left\lfloor \frac{n+l-1 }{l} \right\rfloor \\
r=\max(i) \ ,\ ik \leq n+i-1 \\
\end{cases}</script><script type="math/tex; mode=display">\therefore r=\left\lfloor \frac{n-1 }{k-1} \right\rfloor = \left\lfloor \frac{n-1}{ \left\lfloor \frac{ n+l-1 }{l} \right\rfloor -1} \right\rfloor</script></li>
</ul>
</li>
</ul>
</li>
<li><p>例题</p>
<ul>
<li><p><a href="https://www.luogu.com.cn/problem/CF830C">CF830C Bamboo Partition</a></p>
<p>求：$\sum^n_{i=1} d-((a_i-1)\%d+1) \leq k$</p>
<p>解：</p>
<script type="math/tex; mode=display">原式 =\sum^n_{i=1} d-\left(a_i-1 \ -\ d*\left\lfloor \frac{a_i-1}{d} \right\rfloor+1\right)</script><script type="math/tex; mode=display">\therefore nd+d*\sum^n_{i=1}\left\lfloor \frac{a_i-1}{d} \right\rfloor \leq k+\sum^n_{i=1} a_i</script><p>$\therefore$ 右边定值，枚举左边</p>
<script type="math/tex; mode=display">\therefore d\leq k+\sum^n_{i=1} a_i-\left(n+\sum^n_{i=1}\left\lfloor \frac{a_i-1}{d} \right\rfloor\right)</script></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(rei ll l=<span class="number">1</span>,r;l&lt;=MAX;l=r+<span class="number">1</span>)&#123;<span class="comment">//暴力试每一个块</span></span><br><span class="line"><span class="comment">//把l看成是d</span></span><br><span class="line">    r=<span class="number">1e18</span>;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span>(a[i]<span class="number">-1</span>&gt;=l)&#123;<span class="comment">//每一个 ⌊a[i]-1/d⌋ 有值</span></span><br><span class="line">            sum+=(a[i]<span class="number">-1</span>)/l;</span><br><span class="line">            r=<span class="built_in">min</span>(r,(a[i]<span class="number">-1</span>)/((a[i]<span class="number">-1</span>)/l));</span><br><span class="line">        &#125;</span><br><span class="line">    ll tmp=k/(sum+n);<span class="comment">//见blog的式子推导</span></span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tmp) ans=<span class="built_in">max</span>(ans,<span class="built_in">min</span>(tmp,r));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(MAX &lt; k/n) ans=<span class="built_in">max</span>(ans,(ll)k/n);</span><br></pre></td></tr></table></figure>
<ul>
<li><p><a href="https://www.luogu.com.cn/problem/P2260">P2260 [清华集训2012]模积和</a></p>
<script type="math/tex; mode=display">求：\sum_{i=1}^n\sum_{j=1}^m (n\mod i) \cdot (m\mod j) [\ i\not=j \ ]  \mod 19940417</script><p>考虑一个容斥：$原式=(忽略i\not=j 条件时的值)-(i=j时原式的值)$</p>
<ul>
<li><p>忽略 $i\not=j$时：</p>
<script type="math/tex; mode=display">原式=\left(n^2-\sum_{i=1}^n i*\left\lfloor \frac{n}{i} \right\rfloor\right) \cdot \left(m^2-\sum_{j=1}^m j*\left\lfloor \frac{m}{j} \right\rfloor \right) \text{(1)}</script><p>这与[余数求和]相似</p>
</li>
<li><p>$i=j$</p>
<script type="math/tex; mode=display">\begin{aligned}
原式&=\sum_{i=1}^n \left(n-i*\left\lfloor \frac{n}{i} \right\rfloor \right) \cdot \left(m-i*\left\lfloor \frac{m}{i} \right\rfloor \right) \\
&=n^2m \ -\ \left(\sum_{i=1}^n n*i*\left\lfloor \frac{m}{i} \right\rfloor \right) - \left(\sum_{j=1}^n m*i*\left\lfloor \frac{n}{i} \right\rfloor \right)\ + \ \left(\sum_{i=1}^n i^2*\left\lfloor \frac{m}{i} \right\rfloor * \left\lfloor \frac{n}{i} \right\rfloor \right) &\text{(2)}\\
\end{aligned}</script></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数"></a>积性函数</h3><ul>
<li><p>定义</p>
<p>积性函数 $f(x)$ 满足 $f(1)=1$ 且 $\forall x,y\in \mathbb{N}_{+},\gcd(x,y)=1$ 都有 $f(xy)=f(x)f(y)$</p>
</li>
<li><p>常见形式</p>
<ul>
<li><p>单位元 $\epsilon(n)=[n=1]$</p>
</li>
<li><p>恒等函数 $I(n)=1$</p>
</li>
<li><p>单位函数 $id(n)=n$</p>
</li>
</ul>
</li>
<li><p>性质</p>
<script type="math/tex; mode=display">
\begin{aligned}
h(x) &=f(x^p) \\
h(x) &=f^p(x) \\
h(x) &=f(x)g(x) \\
h(x) &=\sum_{d\mid x} f(d)g\left( \frac{x}{d} \right)
\end{aligned}</script></li>
</ul>
<h3 id="迪利克雷卷积"><a href="#迪利克雷卷积" class="headerlink" title="迪利克雷卷积"></a>迪利克雷卷积</h3><ul>
<li><p>注：</p>
<p>$\sum_{d \mid n}$ 表示对 $n$ 的所有正因子求和</p>
</li>
<li><p>定义</p>
<p>定义数论函数的迪利克雷卷积为 $h=f \circ g$ ,其中</p>
<p>注：定义卷积符号为 $\circ$</p>
<details>
    <summary>原因戳我</summary>
    好看
</details>


</li>
</ul>
<script type="math/tex; mode=display">h(n)=\sum_{d \mid n} f(d)g\left( \frac{n}{d} \right)</script><ul>
<li><p>性质</p>
<ul>
<li><p>迪利克雷卷积拥有交换律，分配律，结合律</p>
</li>
<li><p><strong>单位元</strong> (也记作 $\varepsilon$ )</p>
<p>函数 $I(n)=[n=1]$</p>
<p>易知:</p>
<script type="math/tex; mode=display">f \circ I=I \circ f=f</script></li>
<li><p><strong>逆元</strong> (当且仅当 $f(1) \neq 0$)</p>
<p>若 $f \circ g=I$，则称 $g(x)$ 是 $f(x)$ 的逆元</p>
<p>可以构造：</p>
<script type="math/tex; mode=display">\sum_{d\mid n}g(d)f\left( \frac{n}{d} \right)=[n=1]</script><script type="math/tex; mode=display">\therefore g(n)=\frac{1}{f(1)}\left( [n=1]-\sum_{d\mid n,d<n}g(d)f\left( \frac{n}{d} \right)  \right)</script></li>
</ul>
</li>
</ul>
<h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><ul>
<li><p>定义</p>
<p>$\varphi(n) \ =\ n*\prod^n_{i=1} \left( 1-\frac{1}{p_i}\right)$</p>
<p>其中 $p_i$ 是 $n$ 的质因数</p>
<p>即小于等于 $n$ 且与 $n$ 互素的数的个数</p>
</li>
<li><p>性质</p>
<ul>
<li><p>$1.$ 是积性函数</p>
</li>
<li><p>$2.$</p>
<p>对于质数 $p$</p>
<p>$\varphi(p)=p-1$</p>
</li>
<li><p>$3.$</p>
<p>若 $n=p^k$ ,其中 $p$ 是质数</p>
<p>$\varphi(n)\ =\ p^k-p^{k-1}\ =\ (p-1)p^{k-1}$</p>
<p>证：$1$ 到 $n$ 中除了 $p$ 的倍数，都与 $p^k$ 互质，且 $1$ 到 $n$ 中 $p$ 的倍数的个数为 $\displaystyle{\frac{p^k}{p}}=p^{k-1}$</p>
</li>
<li><p>$4.$</p>
<p>所有<strong>小于等于</strong> $n$ 且与 $n$ 互质的数的个数和 $sum=n*\displaystyle{\frac{\varphi(n)}{2}}$</p>
<p>证：用反证法可知：</p>
<p>若 $\gcd(n,i)=1$，则 $\gcd(n,n-i)=1$ $\Rightarrow$ 更相减损术</p>
<p>所以每个与 $n$ 互质的数都是成对的</p>
<p>$i$ 与 $n-i$ 成对</p>
</li>
<li><p>$5.$</p>
<p>若 $i\mid p$，其中 $p$ 是质数</p>
<p>则 $\varphi(i\cdot p)=p\cdot \varphi(i)$</p>
<p>否则 $\varphi(i*p)=(p-1)\varphi(i)$</p>
<p>即</p>
<script type="math/tex; mode=display">\varphi(np)=\begin{cases}
(p-1)*\varphi(n) & n\perp p \\
p*\varphi(n) & n\not\perp p \\
\end{cases}</script><p>证明咕咕咕</p>
</li>
<li><p>$6.欧拉反演$</p>
<p>$\displaystyle{\sum_{d\mid n}\varphi(d)=n}$</p>
<ul>
<li><p>证：</p>
<script type="math/tex; mode=display">\because n=\prod_{i=1}^{m}p_i^{a_i}</script><script type="math/tex; mode=display">又\because \varphi(n) 是积性函数</script><script type="math/tex; mode=display">\therefore \sum_{d|n}=\sum_{d|n}\prod_{i=1}^{m}\varphi(p_i^{j})\times[p_i^j\ |\ d]</script><script type="math/tex; mode=display">
\begin{aligned} 对上式因式分解可得 \\
右边&=\prod_{i=1}^{m}\left(\sum_{j=0}^{a_i}\varphi\left(p_i^j\right)\right)\\
&=\prod_{i=1}^{m}\left(\sum_{j=1}^{a_i}\left(p_i^j-p_i^{j-1}\right)+1\right)\\
&=\prod_{i=1}^{m}p_i^{a_i}\\
&=n \end{aligned}</script></li>
<li><p>扩展：</p>
<script type="math/tex; mode=display">\gcd(i,j)=\sum_{d\mid i,d\mid j} \varphi(d)</script></li>
</ul>
</li>
<li><p>$7. \varphi 与 \mu$</p>
<p>$\displaystyle{\frac{\varphi(n)}{n}=\sum_{d\mid n}\frac{\mu(d)}{d}}$</p>
<ul>
<li><p>证：</p>
<script type="math/tex; mode=display">\because \sum_{d\mid n}\varphi(d)=n</script><script type="math/tex; mode=display">\therefore \sum_{d\mid n}\varphi(d) \cdot 1=n</script><script type="math/tex; mode=display">\therefore \varphi \circ I=id \qquad \text{变成卷积形式}</script><script type="math/tex; mode=display">\therefore \varphi \circ I \circ \mu = id \circ \mu \qquad \text{迪利克雷卷积性质}</script><script type="math/tex; mode=display">\therefore \varphi \circ \epsilon =id\circ \mu</script><script type="math/tex; mode=display">
\begin{aligned}
\therefore \varphi
&=id \circ \mu \\
&=\sum_{d\mid n} \mu(d) \cdot \frac{n}{d} \\
\end{aligned}</script><p>同除 $n$得：</p>
<script type="math/tex; mode=display">\displaystyle{\frac{\varphi(n)}{n}=\sum_{d\mid n}\frac{\mu(d)}{d}}</script></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="写在前面的总结"><a href="#写在前面的总结" class="headerlink" title="写在前面的总结"></a>写在前面的总结</h2><p><strong>遇到艾弗森方程，转化为$\sum_{d\mid n} \mu(d)$</strong></p>
<p><strong>遇到具体的值，考虑欧拉函数 ————by CTime_Pup_314</strong></p>
<ul>
<li><p>当遇到迪利克雷卷积形式的式子($\sum_{d\mid n}···$)时</p>
<p>看标准分解式 $p_1^{a_1}p_2^{a_2}…p_n^{a_n}$</p>
<p>并分析其中一个 $p_i^{a_i}$</p>
</li>
<li><p>再尝试转化出 $F(n)=\sum_{d\mid n}\mu(\frac{n}{d}) f(d)$ 的形式</p>
<p>再考虑加入 $p$ 的影响:</p>
<p>分为 $n \perp p$ 和 $n\not\perp p$两种讨论</p>
<ul>
<li><p>$n \perp p$ 时，$\sum_{d\mid n}\mu\left(\frac{np}{d}\right) f(d) + \sum_{d\mid n}\mu\left(\frac{np}{dp}\right)f(dp)\ =\ -F(n)+\mu(n)$</p>
</li>
<li><p>$n \not\perp p$ 时，$\sum_{d\mid n}\mu\left(\frac{np}{d}\right) f(d) + \sum_{d\mid n}\mu\left(\frac{np}{dp}\right) f(dp)\ =\ \mu(n)$</p>
</li>
</ul>
</li>
<li><p>若问题类似与 $\displaystyle{\sum_{i=1}^n\sum_{j=1}^mf\left(gcd(i,\ j)\right )}$</p>
<p>则转化为 $\displaystyle{\sum_{T=1}^n\left\lfloor \frac{n}{T} \right\rfloor \left\lfloor \frac{m}{T} \right\rfloor \sum_{d\mid T}\mu\left(\frac{T}{d}\right)f(d)}$</p>
</li>
</ul>
<h2 id="莫比乌斯函数"><a href="#莫比乌斯函数" class="headerlink" title="莫比乌斯函数"></a>莫比乌斯函数</h2><ul>
<li><p>定义</p>
<p>设 $n=\prod_{i=1}^k p_i^{c_i}$，其中 $p_i$ 为质因子, $c_i$ 为个数</p>
<script type="math/tex; mode=display">
\mu(n)=
\begin{cases}
1 &n=1 \\
0 &\exist n\in [1,k],\ \text{使} \ c_i>1 \\
(-1)^k &\forall i \in [1,k] \ \ \   c_i=1 \\
\end{cases}</script></li>
<li><p>性质</p>
<script type="math/tex; mode=display">\sum_{d \mid n} \mu(d)=
\begin{cases}
1 &n=1 \\
0 &n\neq 1
\end{cases}
\ \ =[n==1]</script><ul>
<li><p>证明</p>
<p>显然不用考虑使 $\mu(d)=0$ 的那些 $d$</p>
<p>设 $n$ 有 $k$ 个互异质因数</p>
<p>$\therefore$ 由 $r$ 个质因数乘起来的因数 $d$ 有   $C_k^r$ 个</p>
<script type="math/tex; mode=display">\therefore \sum_{d \mid n} \mu(d)=\sum_{i=0}^k (-1)^i \cdot C^i_k</script><p>由二项式定理：</p>
<script type="math/tex; mode=display">(x+y)^k=\sum_{i=0}^k\cdot C_k^i \cdot x^i y^{k-i}</script><p>可知</p>
<p>取 $x=-1,y=1$</p>
<script type="math/tex; mode=display">\therefore 原式=(1+(-1))^k=0^k=0</script><p>同时，这也证明了$\sum_{d \mid n} \mu(d)=[n=1]= \varepsilon(n)$</p>
<p>以及 $\mu \circ 1=\varepsilon$</p>
</li>
<li><p>性质2</p>
<script type="math/tex; mode=display">[\gcd(i,j)=1]=\sum_{d\mid \gcd(i,j)} \mu(d)</script><p><del>和上面的一模一样。。。</del></p>
</li>
</ul>
</li>
<li><p>线性筛求法</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> p[N];<span class="comment">//第tot个质因数值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!flg[i])<span class="comment">/*之前没有用过该质因数*/</span> p[++tot]=i,mu[i]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=tot &amp;&amp; i*p[j]&lt;=n ;++j)&#123;</span><br><span class="line">            flg[ i*p[j] ]=<span class="number">1</span>;<span class="comment">//每个质因数的倍数打上标记</span></span><br><span class="line">            <span class="keyword">if</span>(!(i%p[j]))&#123;<span class="comment">//有平方因子</span></span><br><span class="line">                mu[ i*p[j] ]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mu[ i*p[j] ]=-mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h2><ul>
<li><p>公式</p>
<script type="math/tex; mode=display">若 \operatorname{F}(n)=\sum_{d\mid n} f(d)，那么 f(n)=\sum_{d\mid n} \mu(d)\operatorname{F}\left(\frac{n}{d}\right)</script><script type="math/tex; mode=display">若 \operatorname{F}(n)=\sum_{n\mid d} f(d)，那么 f(n)=\sum_{n\mid d} \mu\left(\frac{d}{n}\right)\operatorname{F}(d)</script></li>
<li><p>略证</p>
<script type="math/tex; mode=display">\sum_{d\mid n}\mu(d)=[n=1] \Rightarrow \mu \circ 1= \varepsilon</script><script type="math/tex; mode=display">\operatorname{F}(n)=\sum_{d\mid n}f(d) \Rightarrow \operatorname{F}=f \circ 1</script><script type="math/tex; mode=display">\therefore \operatorname{F} \circ \mu = f \circ 1 \circ \mu</script><script type="math/tex; mode=display">\therefore \operatorname{F} \circ \mu=f \circ \varepsilon</script><script type="math/tex; mode=display">\therefore f=\operatorname{F} \circ \mu</script><script type="math/tex; mode=display">\therefore f(n)=\sum_{d\mid n}\mu(d) \cdot \operatorname{F}\left(\frac{n}{d}\right)</script></li>
</ul>
<p><del>好吧我不怎么会证</del></p>
<p>用莫比乌斯函数就可以解决大部分莫反问题——by CTime_Pup_314</p>
<h3 id="需要带脑子推式子的例题"><a href="#需要带脑子推式子的例题" class="headerlink" title="需要带脑子推式子的例题"></a>需要带脑子推式子的例题</h3><ul>
<li><p><del>k倍经验</del></p>
<p><del>UVA11417 GCD垃圾红题</del>，UVA11424 GCD - Extreme (I)，P1390 公约数的和，P2398 GCD SUM，P2568 GCD，SP3871 GCDEX - GCD Extreme，UVA11426 拿行李（极限版），SP3871 GCDEX - GCD Extreme,[SP19985]GCDEX2 - GCD Extreme (hard)（要用杜教筛）， [SDOI2008] 仪仗队</p>
</li>
</ul>
<p><strong>请仔细留意如何筛出所需函数</strong></p>
<ul>
<li><p>附线性筛板子  <del>不压行显得多一点</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//f是你想要的函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    varphi[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei d=<span class="number">2</span>;d&lt;N;++d)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag[d])&#123;</span><br><span class="line">            prime[++tot]=d;</span><br><span class="line">            varphi[d]=d<span class="number">-1</span>;</span><br><span class="line">            mu[i]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f[d]=它该等于的式子</span><br><span class="line">        <span class="keyword">for</span>(rei j=<span class="number">1</span>;j&lt;=tot &amp;&amp; d*prime[j]&lt;N;++j)&#123;</span><br><span class="line">            rei tmp=d*prime[j];</span><br><span class="line">            flag[tmp]=<span class="number">1</span>;</span><br><span class="line">            varphi[tmp]=varphi[d] * (d%prime[j]<span class="comment">/*是否互素*/</span> ? prime[j]<span class="number">-1</span> : prime[j]);</span><br><span class="line">            <span class="keyword">if</span>(!(d%p[j]))</span><br><span class="line">                mu[d*p[j]]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> mu[d*p[j]]=-mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">        这里可能需要进一步处理<span class="built_in">f</span>(n)</span><br><span class="line">    &#125;</span><br><span class="line">    这里也有可能</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注：规定所有的 $n&lt;m$ , 所有出现的 $p$ 为质数</p>
<ul>
<li><p>$1$</p>
<p><a href="https://www.luogu.com.cn/problem/P4450">P4450 双亲数</a></p>
<script type="math/tex; mode=display">求 \sum^n_{i=1}\sum^m_{j=1} [\ \gcd(i,j)=1\ ]</script><p>解：</p>
<script type="math/tex; mode=display">\begin{aligned}
原式
&= \sum^n_{i=1}\sum^m_{j=1}\sum_{d\mid \gcd(i,j)} \mu(d) &\text{莫比乌斯函数的性质2}\\
&= \sum^n_{i=1}\sum^m_{j=1}\sum_{d\mid i \ , \ d\mid j} \mu(d) &\text{拆开}\\
&= \sum^n_{i=1}\sum^m_{j=1}\sum^n_{d=1} \mu(d) [ \ d \mid i \ ] [ \ d \mid j \ ] &\text{条件转移到右边} \\
&= \sum^n_{d=1} \mu(d) \sum^n_{i=1} [d\mid i] \sum^m_{j=1} [d\mid j] &\text{调整顺序} \\
&= \sum^n_{d=1} \mu(d) \left\lfloor \frac{n}{d} \right\rfloor \left\lfloor \frac{m}{d} \right\rfloor &\text{...} \\
\end{aligned}</script></li>
<li><p>$2$</p>
<p><a href="https://www.luogu.com.cn/problem/P2522">P2522 [HAOI2011]Problem b</a></p>
<script type="math/tex; mode=display">求 \sum^n_{i=1}\sum^m_{j=1} [\gcd(i,j)=k]</script><p>解：</p>
<p>将范围缩小 $k$ 就可以</p>
<p>即</p>
<script type="math/tex; mode=display">\begin{aligned}
原式
&=\sum^{ \left\lfloor \frac{n}{k} \right\rfloor }_{i=1} \sum^{ \left\lfloor \frac{m}{k} \right\rfloor  }_{j=1} [\gcd(i,j)=1] \\
&=\sum^{ \left\lfloor \frac{n}{k} \right\rfloor }_{d=1} \mu(d) \left\lfloor \frac{n}{kd} \right\rfloor \left\lfloor \frac{m}{kd} \right\rfloor
\end{aligned}</script></li>
<li><p>$3$</p>
<script type="math/tex; mode=display">求\sum^n_{i=1}\sum^m_{j=1} i*j*[\ \gcd(i,j)=k\ ]</script><script type="math/tex; mode=display">\begin{aligned}
原式
&=k^2*\sum^{\left\lfloor \frac{n}{k} \right\rfloor}_{i=1} \sum^{\left\lfloor \frac{m}{k} \right\rfloor}_{j=1} i*j*[ \ \gcd(i,j)=1 \ ] &\text{ $i$ 缩小成 $\frac{i}{k}$，$j$ 同理} \\
&=k^2* \sum^{\left\lfloor \frac{n}{k} \right\rfloor}_{d=1}\mu(d) \sum^{\left\lfloor \frac{n}{k} \right\rfloor}_{i=1} \sum^{\left\lfloor \frac{m}{k} \right\rfloor}_{j=1} i*j*[d\mid i][d\mid j] \\
&=k^2 \sum^{\left\lfloor \frac{n}{k} \right\rfloor}_{d=1}\mu(d) * d^2 \sum^{\left\lfloor \frac{n}{kd} \right\rfloor}_{i=1}i\sum^{\left\lfloor \frac{m}{kd} \right\rfloor}_{j=1}j &\text{ $i$ 缩小为 $\frac{i}{d}$ ，$j$ 同理} \\
&\text{变成等差数列了qwq}
\end{aligned}</script></li>
<li><p>$4$</p>
<script type="math/tex; mode=display">求\sum_{i=1}^n\sum_{j=1}^m \gcd(i,\ j)</script><p><a href="https://www.luogu.com.cn/problem/P1447">P1447 [NOI2010] 能量采集</a></p>
<p>由题，没有被遮挡的植物坐标 $(x,y)$ 满足 $n\perp m$，而一条线 $(0,0)-(x,y)$ 上被挡住的植物有 $\gcd(x,y)-1$ 个</p>
<script type="math/tex; mode=display">\therefore 求\sum^n_{i=1}\sum^m_{j=1}((2*\gcd(i,j)-1) \ +1 \ )</script><script type="math/tex; mode=display">\therefore 求2*\sum^n_{i=1}\sum^m_{j=1}(\gcd(i,j)) \ - \ nm</script><script type="math/tex; mode=display">\therefore 求\sum_{i=1}^n\sum_{j=1}^m \gcd(i,\ j)</script><p>先进行简单化简</p>
<script type="math/tex; mode=display">\sum_{d=1}^nd\sum_{i=1}^n\sum_{j=1}^m[ \ \gcd(i,j)=d \ ]</script><script type="math/tex; mode=display">\sum_{d=1}^nd\sum_{k=1}^{\lfloor \frac{n}{d} \rfloor}\mu(k) \left\lfloor \frac{n}{kd} \right\rfloor \left\lfloor \frac{m}{kd} \right\rfloor</script><p>设 $T=kd$</p>
<script type="math/tex; mode=display">
\begin{aligned}
\therefore
原式
&= \sum_{d=1}^nd\sum_{T=1}^n\mu\left(\frac{T}{d}\right) \left\lfloor \frac{n}{T} \right\rfloor \left\lfloor \frac{m}{T} \right\rfloor [d\mid T]\ \\
&= \sum_{T=1}^n \left\lfloor \frac{n}{T} \right\rfloor \left\lfloor \frac{m}{T} \right\rfloor \sum_{d\mid T}\mu \left( \frac{T}{d} \right)d \\
\end{aligned}</script><p>设 $\operatorname{F}(n)=\sum_{d\mid n}\mu \left( \frac{n}{d} \right)d$</p>
<p>根据上面的总结可知</p>
<script type="math/tex; mode=display">\operatorname{F}(np)=\sum_{d\mid n} \mu\left(\frac{np}{d} \right)d \ + \ \sum_{d\mid n}\mu\left(\frac{np}{dp} \right) dp</script><p>当 $n\perp p$ 时，</p>
<script type="math/tex; mode=display">\operatorname{F}(np)=-\operatorname{F}(n)+p\operatorname{}{F}(n)</script><p>当 $n\not\perp p$ 时，</p>
<script type="math/tex; mode=display">\operatorname{F}(np)=p\operatorname{}{F}(n)</script><p>$\therefore 显然F(n)符合欧拉函数的性质$</p>
<ul>
<li><p>变式</p>
<p><a href="https://www.luogu.com.cn/problem/P4449">P4449 于神之怒加强版</a></p>
<script type="math/tex; mode=display">求\sum_{i=1}^n\sum_{j=1}^m \gcd(i,\ j)^k \mod p</script><p>先把 $k$ 提出来得</p>
<script type="math/tex; mode=display">\begin{aligned}
原式
&=\sum_{d=1}^n d^k \sum_{i=1}^{\left\lfloor \frac{n}{d} \right\rfloor}\sum_{i=1}^{\left\lfloor \frac{m}{d} \right\rfloor} [ \ \gcd(i,j)=1 \ ] \\
&=\sum_{d=1}^n d^k \sum_{x=1}^{\left\lfloor \frac{n}{d} \right\rfloor} \left\lfloor \frac{n}{dx} \right\rfloor\left\lfloor \frac{m}{dx} \right\rfloor \mu(x) \\
&设\  T=dx \\
&=\sum_{T=1}^n \sum_{d\mid T}d^k \left\lfloor \frac{n}{T} \right\rfloor \left\lfloor \frac{m}{T} \right\rfloor \mu\left(\frac{T}{d} \right) &\text{总是忘记可以这么化} \\
&=\sum_{T=1}^n \left\lfloor \frac{n}{T} \right\rfloor \left\lfloor \frac{m}{T} \right\rfloor \sum_{d\mid T}\mu \left( \frac{T}{d} \right)d^k &\text{剩余做法参照上面} \\
\end{aligned}</script><p>处理 $\sum_{d\mid T}\mu \left( \frac{T}{d} \right)d^k$</p>
<p>设积性函数 $f(T)=id^k \circ \mu$</p>
<script type="math/tex; mode=display">\because 积性函数满足 f(nm)=f(n)f(m) , T=\prod_{i=1}^k p_i^{c_i}</script><script type="math/tex; mode=display">\therefore 研究 T\mid P^x , x\in \text{N+} , p\in \text{primes}</script><p>当 $x=1$</p>
<script type="math/tex; mode=display">d^k \mu\left(\frac{T}{d} \right)=\begin{cases}
    -1 &(d=1) \\
    T^k &(d==T) \\
\end{cases}</script><script type="math/tex; mode=display">\therefore f(T)=T^k-1</script><p>当 $x&gt;1$</p>
<script type="math/tex; mode=display">d^k\mu\left(\frac{T^x}{d} \right)=\begin{cases}
    -\left(T^{x-1} \right)^k &\left(d=T^{x-1}\right) \\
    \left(T^x \right)^k &\left(T^x\right) \\
\end{cases}</script><p>$\therefore$ 筛法为</p>
<script type="math/tex; mode=display">f_{i*p_j}=\begin{cases}
    f_i * f_{p_j} &\left( \ \gcd(p_j,i)=1 \ \right) \\
    f_i * p_j^k &( \ p_j\mid i \ ) \\
\end{cases}</script></li>
<li><p>变式</p>
<p><a href="https://www.luogu.com.cn/problem/UVA11424">UVA11424 GCD - Extreme (I)</a></p>
<script type="math/tex; mode=display">求\sum_{i=1}^n\sum_{j=i+1}^n \gcd(i,j)</script><p>有一个比莫反更好的方法</p>
<p>设 $f(n)=\gcd(1,n)+\gcd(2,n)+…+\gcd(n-1,n)$</p>
<p>$\therefore ans=f(2)+f(3)+…+f(n)$</p>
<p>设 $g(n,x)$ 表示 $\gcd(x,n)=i$ 的小于 $n$ 的正整数个数</p>
<script type="math/tex; mode=display">\therefore f(n)=\sum_{i\mid n}i*g(n,i)</script><p>考虑 $\varphi$ 即可</p>
<p><del>精神不稳就这吧</del></p>
<p>我的精神是正常的只是懒得写</p>
</li>
</ul>
</li>
<li><p>$5$</p>
<p><a href="https://www.luogu.com.cn/problem/P2257">P2257 YY的GCD</a></p>
<script type="math/tex; mode=display">求\sum_{i=1}^n\sum_{j=1}^m[\ \gcd(i,j)=p \ ]\ ，\ 其中 \ p\ 是质数</script><script type="math/tex; mode=display">设\operatorname{F}(n)=[\ n=p\ ]</script><script type="math/tex; mode=display">原式=\sum_{i=1}^n\sum_{j=1}^mf(\gcd(i,j))</script><script type="math/tex; mode=display">设T=kd</script><p>推导与上一题类似，略(<del>懒</del>)</p>
<script type="math/tex; mode=display">\therefore \sum_{T=1}^n \left\lfloor \frac{n}{T} \right\rfloor \left\lfloor \frac{m}{T} \right\rfloor \sum_{d\mid T}\mu \left( \frac{T}{d} \right) f(d)</script></li>
<li><p>$6$</p>
<p><a href="https://www.luogu.com.cn/problem/SP5971">SP5971 LCMSUM - LCM Sum</a></p>
<script type="math/tex; mode=display">求\sum^n_{i=1}\text{lcm}(i,n)</script><ul>
<li><p>[ 法一 ]</p>
<script type="math/tex; mode=display">\begin{aligned}
  原式
  &=\sum^n_{i=1} \frac{i \cdot n}{\gcd(i,n)} \\
  &=\frac{1}{2} \cdot \left(\sum^{n-1}_{i=1} \frac{i\cdot n}{\gcd(i,n)}\ + \ \sum^1_{i=n-1} \frac{i\cdot n}{\gcd(n-i,n)} \right)+n &\text{复制原式并颠倒，并提出第 $n$ 项}\\
  &=\frac{1}{2}\cdot \sum^{n-1}_{i=1} \frac{n^2}{\gcd(i,n)} \ + \ n &\text{ $\gcd(i,n)$ 转化为 $\gcd(n-i,n)$ ,并合并分母}\\
  &=\frac{1}{2}\cdot \sum^{n}_{i=1} \frac{n^2}{\gcd(i,n)} \ + \ \frac{n}{2} \\
  \end{aligned}</script><p>  $\gcd(i,n)$ 值相同的放在一起 $\Rightarrow$ 统计 $\gcd(i,n)=d$ 的个数</p>
<p>  当 $\gcd(i,n)=d$ , $\gcd(\frac{i}{d},\frac{i}{n})=1$</p>
<p>  所以 $\gcd(i,n)=d$ 的个数有 $\varphi\left(\frac{n}{d}\right)$</p>
<script type="math/tex; mode=display">\therefore 原式=\frac{1}{2} \sum_{d\mid n}\frac{ n^2\cdot\varphi(\frac{n}{d}) }{d} \ + \ \frac{n}{2}</script></li>
<li><p>[ 法二 ]</p>
<script type="math/tex; mode=display">\begin{aligned}
  原式
  &=\sum_{i=1}^n \frac{i\cdot n}{\gcd(i,n)} \\
  &=\sum_{d\mid n}\sum_{i=1}^n \ [\ \gcd(i,n)=d \ ] \ \frac{i\cdot n}{d} &\text{枚举 $\gcd(i,n)=d$ }\\
  &=n \cdot \sum_{d\mid n}\sum_{i=1}^{\left\lfloor \frac{n}{d} \right\rfloor} [ \ \gcd(i,\frac{n}{d})=1 \ ] \cdot i \\
  \end{aligned}</script><p>  提出式子 $\displaystyle{\sum_{i=1}^n [\ \gcd(i,n)=1\ ]\cdot i}$</p>
<p>  式子的含义是求小于等于 $n$ 的数中与 $n$ 互质的数的和</p>
<p>  这与上文推导的欧拉函数性质 $4$ 一样</p>
<p>  即 $sum=n*\displaystyle{\frac{\varphi(n)}{2}}$</p>
<script type="math/tex; mode=display">\therefore 原式=n\cdot \sum_{d\mid n} d*\frac{\varphi(d)}{2}</script></li>
</ul>
</li>
<li><p>$7.$</p>
<p><a href="https://www.luogu.com.cn/problem/P3327">P3327 [SDOI2015]约数个数和</a></p>
<p>设 $\operatorname{d}(i)$ 为 $i$ 的约数个数 ，注意仍有 $n&lt;m$</p>
<script type="math/tex; mode=display">求：\sum_{i=1}^n\sum_{j=1}^m \operatorname{d}(ij)</script><p><strong>有一个显然的结论</strong>:$\displaystyle{\operatorname{d}(n)=\sum_{x\mid n,y\mid n}[ \ \gcd(x,y)=1 \ ]}$</p>
<script type="math/tex; mode=display">\begin{aligned}
原式
&=\sum_{i=1}^n \sum_{j=1}^m \sum_{x\mid i} \sum_{y\mid j} \sum_{d\mid \gcd(x,y)} \mu(d) &\text{(1)}\\
&=\sum_{d=1}^n\mu(d) \sum_{i=1}^n \sum_{j=1}^m \left\lfloor \frac{i}{d}  \right\rfloor \cdot \left\lfloor \frac{j}{d}  \right\rfloor &\text{莫反套路，前置 $\mu$ 函数，在 $i$ 内能被 $d$ 整除的有 $\frac{i}{d}$ 个}\\
\end{aligned}</script><p>然而 $d$ 在分母上，不易打表，无法数论分块 $\Rightarrow$ 重新考虑 $(1)$ 式</p>
<p>$(1)$ 中对每组 $(d,i,j)$ ，先考虑 $\displaystyle{\sum_{i=1}^n \sum_{j=1}^m \sum_{x\mid i} \sum_{y\mid j}}$ $(2)$</p>
<p>其贡献为 $\left(i的因数(x)的个数 \left(即\sum_{x\mid i} \right) \right) \cdot \left(j的因数的个数 \left(即\sum_{y\mid j} \right) \right)$</p>
<p>再提前 $\displaystyle{\sum_{d\mid \gcd(x,y)}\mu(d)}$ ，转化为从 $1$ 到 $n$ 枚举 $d$ ，同时缩小 $(2)$ 式的数据范围</p>
<p>若使 $[\ d\mid \gcd(x,y) \ ]=1$ ，那么 $x,y$ 都为 $d$ 的倍数 ，所以数据范围应为枚举 $d,2d,3d,4d…$ 直至 $kd&gt;n$</p>
<script type="math/tex; mode=display">原式=\sum_{d=1}^n\mu(d) \cdot \sum_{s=1}^{\left\lfloor \frac{n}{d} \right\rfloor} \left\lfloor \frac{n}{sd} \right\rfloor \cdot \sum_{t=1}^{\left\lfloor \frac{m}{d} \right\rfloor} \left\lfloor \frac{m}{td} \right\rfloor</script><p>式子含义明显</p>
<p>设 $\displaystyle{\operatorname{f}(i)=\sum_{i=1}^n \left\lfloor \frac{n}{i} \right\rfloor}$ ，考虑对 $\operatorname{f}(i)$ 分块</p>
<p>显然有 $\displaystyle{\operatorname{f}(i)=\sum_{i=1}^n} \operatorname{d}(x)$</p>
<script type="math/tex; mode=display">原式=\sum_{d=1}^n\mu(d) \cdot \operatorname{f} \left(\left\lfloor \frac{n}{d} \right\rfloor \right) \cdot \operatorname{f} \left(\left\lfloor \frac{m}{d} \right\rfloor \right)</script></li>
<li><p>$8$</p>
<p><a href="https://www.luogu.com.cn/problem/P1829">P1829 【[国家集训队]Crash的数字表格 / JZPTAB】</a></p>
<script type="math/tex; mode=display">求 \sum_{i=1}^n\sum_{j=1}^m \text{lcm}(i,j)</script><script type="math/tex; mode=display">\begin{aligned}
原式
&=\sum_{d=1}^n \frac{1}{d} * \sum_{i=1}^n\sum_{j=1}^mi*j*[ \ \gcd(i,j)=d \ ] &\text{用前面的$\frac{1}{d}$抵消了原有的 $\frac{1}{\gcd}$}\\
&=\sum_{d=1}^n d\sum_{i=1}^{\left\lfloor \frac{n}{d}  \right\rfloor}\sum_{j=1}^{\left\lfloor \frac{m}{d}  \right\rfloor}i*j*[ \ \gcd(i,j)=1 \ ] &\text{缩小数据范围，恰好可以用前面的 $\sum d$ 抵消造成的影响} \\
&=\sum_{d=1}^n d \sum_{k=1}^{\left\lfloor \frac{n}{d}  \right\rfloor} \mu(k) * k^2 * \sum_{i=1}^{\left\lfloor \frac{n}{dk}  \right\rfloor} \sum_{j=1}^{\left\lfloor \frac{m}{dk}  \right\rfloor} i j &\text{后面的两个 $\sum$ 的数据范围均被缩小了 $k$ ，所以前面乘上 $k^2$ } \\
\end{aligned}</script><p>设 $S(n)=\sum_{i=1}^n=\frac{n(n+1)}{2}$</p>
<script type="math/tex; mode=display">\therefore 原式=\sum_{d=1}^n d \sum_{k=1}^{\left\lfloor \frac{n}{d}  \right\rfloor} \mu(k) * k^2 *S\left(\frac{n}{kd} \right) * S\left(\frac{m}{kd} \right)</script><p>再设 $T=kd$</p>
<script type="math/tex; mode=display">\begin{aligned}
\therefore 原式
&=\sum_{T=1}^n * S\left(\frac{n}{T} \right)S\left(\frac{m}{T} \right) * \sum_{d\mid T}\mu\left(\frac{T}{d} \right) * \left(\frac{T}{d}\right)^2 \\
&=\sum_{T=1}^n * S\left(\frac{n}{T} \right)S\left(\frac{m}{T} \right) * \sum_{d\mid T}Td\mu(d) &\text{如果看到提醒我去问人} \\
\end{aligned}</script><p>$\therefore$ 只需预处理 $\sum_{d\mid T}Td\mu(d)$ 即可</p>
<p><a href="https://www.luogu.com.cn/blog/qwaszx/solution-p1829">传送门</a></p>
</li>
<li><p>$9.$</p>
<p><a href="https://www.luogu.com.cn/problem/P3911">P3911 最小公倍数之和</a></p>
<script type="math/tex; mode=display">求\displaystyle{\sum_{i=1}^n \sum_{j=1}^n \text{lcm} \left(A_i,A_j \right)}</script><p>考虑转化该式：</p>
<p>设 $\displaystyle{M=\max_{1&lt;=i&lt;=n}A_i \quad,\quad C_i=\sum_{d=1}^n [A_d=i] }$</p>
<script type="math/tex; mode=display">\therefore 原式=\sum_{i=1}^M\sum_{j=1}^M \text{lcm}(i,j) * C_i * C_j \quad \text{枚举所有 $A_i$ 的值，$C_i$表达是否存在该值以及该值的数量 $\Rightarrow$ 避免重复运算 }</script><p>其余按套路来</p>
<script type="math/tex; mode=display">\begin{aligned}
原式
&=\sum_{d=1}^M\sum_{i=1}^{\left\lfloor \frac{M}{d} \right\rfloor}\sum_{j=1}^{\left\lfloor \frac{M}{d} \right\rfloor} [\gcd(i,j)=1]*d * ij *C_{id}C_{jd} \\
&=\sum_{d=1}^M d \sum_{k=1}^{\left\lfloor \frac{M}{d} \right\rfloor} k^2\mu(k) \sum_{i=1}^{\left\lfloor \frac{M}{kd} \right\rfloor}\sum_{j=1}^{\left\lfloor \frac{M}{kd} \right\rfloor} ij * C_{idk}C_{jdk} &\text{过程略}\\
\end{aligned}</script><p>考虑后面部分的 $C$ 如何快速处理</p>
<p>设 $T=dk$</p>
<script type="math/tex; mode=display">\begin{aligned}
原式
&=\sum_{T=1}^n T \cdot \sum_{k\mid T} k\mu(k) \cdot \sum_{i=1}^{\left\lfloor \frac{n}{T} \right\rfloor}\sum_{j=1}^{\left\lfloor \frac{n}{T} \right\rfloor} A_{i\cdot T}A_{j\cdot T} \cdot ij \\
&设s_i=i*\sum_{k\mid i}k\cdot \mu(k) \\
&=\sum_{T=1}^ns_T \cdot \sum_{i=1}^{\left\lfloor \frac{n}{T} \right\rfloor}\sum_{j=1}^{\left\lfloor \frac{n}{T} \right\rfloor}A_{iT}A_{jT}\cdot ij \\
&=\sum_{T=1}^n s_T \cdot \left(\sum_{i=1}^{\left\lfloor \frac{n}{T} \right\rfloor} i\cdot A_{iT}\right) \left(\sum_{j=1}^{\left\lfloor \frac{n}{T} \right\rfloor} A_{jT} \cdot j\right) \\
&=\sum_{T=1}^n s_T \cdot \left(\sum_{i=1}^{\left\lfloor \frac{n}{T} \right\rfloor} i\cdot A_{iT}\right)^2 &\text{后面两项一样}\\
\end{aligned}</script><p>简单的变式<a href="https://www.luogu.com.cn/problem/AT5200">AT5200 [AGC038C] LCMs</a></p>
<p>求 $\displaystyle{\sum_{i=0}^{n}\sum_{j=i+1}^{n}\text{lcm}(A_i,A_j)} \quad \mod p$</p>
<script type="math/tex; mode=display">原式=\frac{\sum_{i=1}^n \sum_{j=1}^n \text{lcm}(A_i,A_j)-\sum_{i=1}^n A_i}{2}</script><p>注意及时取模即可</p>
</li>
<li><p>$10.$</p>
<p><a href="https://www.luogu.com.cn/problem/P3768">P3768 简单的数学题</a></p>
<script type="math/tex; mode=display">求\displaystyle{\left(\sum_{i=1}^n\sum_{j=1}^n ij\gcd(i,j) \right) \pmod p}</script><script type="math/tex; mode=display">\begin{aligned}
原式
&=\sum_{i=1}^n\sum_{j=1}^n ij * id\left( \ \gcd(i,j) \ \right) \\
&=\sum_{i=1}^n\sum_{j=1}^n ij \sum_{d\mid i,d\mid j} \varphi(d) &\text{欧拉函数性质 $6$} \\
&=\sum_{d=1}^n \varphi(d) *d^2 \left(\sum_{i=1}^{\left\lfloor \frac{n}{d} \right\rfloor} i \right)^2 &\text{两个 $i$ 可以合并} \\
\end{aligned}</script><ul>
<li><p>前半部分</p>
<p>  杜教筛 $\Rightarrow$ 设 $S(n)=\sum_{d=1}^n \varphi(d) * d^2$</p>
<p>  若使 $f\circ g$ 结果只有 $n$ $\Rightarrow$ 取 $g=id$</p>
<script type="math/tex; mode=display">\therefore f\circ g=\sum_{d\mid n} \varphi(d)*d^2 * \left(\frac{n}{d} \right)^2 = n^3 \quad \text{同理}</script><script type="math/tex; mode=display">\therefore S(n)=\frac{\sum_{i=1}^n\left(f\circ g \right) - \sum_{i=2}^n g\left(i\right)S\left(\left\lfloor \frac{n}{i} \right\rfloor \right) }{g(1)}</script><script type="math/tex; mode=display">1.\sum_{i=1}^n\left(f\circ g \right)=\sum_{i=1}^n i^3=\frac{n^2\left(n+1\right)^2}{4}</script><script type="math/tex; mode=display">2.\sum_{i=1}^ng(i)=\sum_{i=1}^ni^2=\frac{n(n+1)(2n+1)}{6}</script></li>
<li><p>右半部分</p>
<p>  求 $\displaystyle{\left(\sum_{i=1}^ni\right)^2}$</p>
<p>  然而我只会<a href="https://math.stackexchange.com/questions/1423948/trying-to-prove-sum-i-1n-i3-sum-i-1n-i2">证明$\displaystyle{\left(\sum_{i=1}^ni\right)^2=\sum_{i=1}^n i^3 }$</a></p>
<p>  最快的方法是差分</p>
<p>  设 $\displaystyle{A_n=\sum_{i=1}^n i^3 \ , \ B_n=\sum_{i=1}^n i}$</p>
<p>  一).</p>
<script type="math/tex; mode=display">显然有 A_1=B_1^2</script><p>  二).</p>
<script type="math/tex; mode=display">转化为求 \quad \Delta A_n=A_{n+1}-A_n=\Delta B_n^2</script><script type="math/tex; mode=display">\begin{aligned}
  \Delta B_n^2
  &=B_{n+1}^2-B_n^2 \\
  &=(B_{n+1}-B_n) * (B_{n+1}+B_n) \\
  &=(n+1) * \left(\frac{(n+1)(n+2)}{2} + \frac{n(n+1)}{2} \right) \\
  &=\frac{(n+1)^2}{2} (2n+2) \\
  &=(n+1)^3 \\
  &=\Delta A_n \\
  \end{aligned}</script><script type="math/tex; mode=display">\therefore \left(\sum_{i=1}^ni\right)^2=\sum_{i=1}^n i^3=\frac{n^2(n+1)^2}{4}</script></li>
</ul>
</li>
<li><p>11.</p>
<p><a href="https://www.luogu.com.cn/problem/P1587">P1587 [NOI2016] 循环之美</a></p>
<script type="math/tex; mode=display">求k进制下 ， \sum_{i=1}^n\sum_{j=1}^m \left[\frac{i}{j}是纯循环小数\right]</script><p>一个神仙转化如下</p>
<p>设该纯循环小数的循环节长度为 $times$，$\left\{\frac{x}{y}\right\}$ 表示 $\frac{x}{y}$ 的小数部分</p>
<p>在 $k$ 进制下，总有 $\displaystyle{\left\{\frac{x}{y} \right\} = \left\{\frac{x \cdot k^{times}}{y} \right\} }$</p>
<p>即</p>
<script type="math/tex; mode=display">\frac{x}{y}-\left\lfloor \frac{x}{y} \right\rfloor = \frac{x\cdot k^{times}}{y}-\left\lfloor \frac{x\cdot k^{times}}{y} \right\rfloor</script><script type="math/tex; mode=display">x-\left\lfloor \frac{x}{y} \right\rfloor \cdot y =x\cdot k^{times} - \left\lfloor \frac{x\cdot k^{times}}{y} \right\rfloor \cdot y</script><p>考虑到最简分数，即 $\gcd(x,y)=1$</p>
<script type="math/tex; mode=display">x \equiv x\cdot k^{times}\pmod y</script><script type="math/tex; mode=display">k^{times}\equiv 1\pmod y</script><script type="math/tex; mode=display">k\equiv 1\pmod y</script><p>$\therefore$ 问题转化为</p>
<script type="math/tex; mode=display">求\sum_{i=1}^n\sum_{j=1}^m [\gcd(i,j)=1] [\gcd(j,k)=1]</script><script type="math/tex; mode=display">\begin{aligned}
原式&=f(n,m,k)\\
&=\sum_{i=1}^n\sum_{jd=1}^m[\gcd(i,jd)=1] \sum_{d\mid dj,d\mid k} \mu(d) \\
&=\sum_{d\mid k} \mu(d) \sum_{i=1}^n\sum_{j=1}^{\left\lfloor \frac{m}{d} \right\rfloor} [\gcd(i,jd)=1] \\
&=\sum_{d\mid k}\mu(d) \cdot f\left(\frac{m}{d},n,d \right) \\
\end{aligned}</script><p>最后对 $k=1$ 的情况直接算即可</p>
</li>
<li><p>12.</p>
<p><a href="https://www.luogu.com.cn/problem/P3704">P3704 [SDOI2017]数字表格</a></p>
<script type="math/tex; mode=display">求\prod_{i=1}^n\prod_{j=1}^mf[\gcd(i,j)]</script><p>设 $n&lt;m$</p>
<script type="math/tex; mode=display">\begin{aligned}
原式&=\prod_{d=1}^{n}\prod_{i=1}^n\prod_{j=1}^m \ [\ \gcd(i,j)=d\ ] \ \cdot \ f[d] \\
&= \prod_{d=1}^{n}f[d]^{\left( \sum\limits_{i=1}^{n} \sum\limits_{j=1}^{m} [\ \gcd(i,j)=d\ ]\right) } \quad \text{乘积形式化为幂次} \\
\end{aligned}</script><p>看指数项<del>发现是HAOI2011</del></p>
<script type="math/tex; mode=display">\begin{aligned}
\sum\limits_{i=1}^{n} \sum\limits_{j=1}^{m} [\ \gcd(i,j)=d\ ]&=\sum^{ \left\lfloor \frac{n}{d} \right\rfloor }_{k=1} \mu(k) \left\lfloor \frac{n}{kd} \right\rfloor \left\lfloor \frac{m}{kd} \right\rfloor
\end{aligned}</script><p>$\sout{好了可以O(nT)了}$</p>
<p>用能量采集的 $\text{trick}$ 提出 $T=kd$ ,即</p>
<script type="math/tex; mode=display">\sum\limits_{T=1}^n\mu\left(\frac{T}{d}\right) \left\lfloor \frac{n}{T} \right\rfloor \left\lfloor \frac{m}{T} \right\rfloor [\ d\mid T \ ]</script><p>$T$ 对 $d$ 取值做出了限制条件 $\Rightarrow$ 考虑把 $T$ 提到式子最前面,即</p>
<script type="math/tex; mode=display">\prod_{T=1}^n\prod_{d\mid T} f[d]^{\left(\mu\left(\frac{T}{d} \right) \left\lfloor \frac{n}{T} \right\rfloor \left\lfloor \frac{m}{T} \right\rfloor \right)}</script><p>即</p>
<script type="math/tex; mode=display">\prod_{T=1}^n \left(\prod_{d\mid T} f[d]^{\mu\left(\frac{T}{d} \right) } \right)^{\left\lfloor \frac{n}{T} \right\rfloor \left\lfloor \frac{m}{T} \right\rfloor}</script></li>
</ul>
<hr>
<h3 id="要带更多的脑子"><a href="#要带更多的脑子" class="headerlink" title="要带更多的脑子"></a>要带更多的脑子</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="+数据结构"></a>+数据结构</h4><ul>
<li><p>$1.$</p>
<p><a href="https://www.luogu.com.cn/problem/P3312">P3312 [SDOI2014]数表</a></p>
<p>给定 $A$ , 求 $\displaystyle{\sum_{i=1}^n \sum_{j=1}^m d( \ \gcd(i,j) \ ) [ \ d( \ (\gcd(i,j) \ ) \leq A \ ]}$</p>
<p><del>众所周知 $d(n)$ 代表约数的和</del></p>
<script type="math/tex; mode=display">原式=\sum_{T=1}^n \left\lfloor \frac{n}{kd} \right\rfloor \left\lfloor \frac{m}{kd} \right\rfloor \sum_{x\mid T}\mu(x) * d\left(\frac{T}{x} \right) \left[ d\left(\frac{T}{x} \right) \leq A \right]</script><p>$设 \displaystyle{f(i)=\sum_{x\mid T}\mu(x) * d\left( \frac{T}{x} \right) \left[ d\left(\frac{T}{x} \right) \leq A \right]}$</p>
<p>看起来是关于 $(T,A)$</p>
<p>将询问按 $A$ 升序排列并提前处理 $d(x)$</p>
<p>当 $A$ 增大时，该函数值也以一定规律增大 $\Rightarrow$ 看成插入</p>
<p>$\therefore$ 需要支持插入与查询的数据结构 $\Rightarrow$ 树状数组</p>
<p>每次暴力加入所有 $d(x) \leq A$ 的 $x$</p>
<p>即对所有 $kx\leq n$ 都有 $f(kx)+=d(xyt4)\mu(k)$</p>
</li>
</ul>
<h4 id="记忆化"><a href="#记忆化" class="headerlink" title="+记忆化"></a>+记忆化</h4><ul>
<li><p>$1.$</p>
<p><a href="https://www.luogu.com.cn/problem/P4619">P4619 [SDOI2018]旧试题</a></p>
<p>求</p>
<script type="math/tex; mode=display">\sum_{i=1}^A\sum_{j=1}^B\sum_{k=1}^C d(i\times j\times k) \mod 10^9+7</script><p>首先可以回忆起 <a href="https://www.luogu.com.cn/problem/P3327">P3327 [SDOI2015]约数个数和</a> 这道题中对 $d(xy)$ 的处理方法： $d(i\times j)=\sum_{x\mid i}\sum_{y\mid j} [\gcd(x,y)=1]$</p>
<p>所以在该题中，对于每两个数都有以上关系式</p>
</li>
</ul>
<script type="math/tex; mode=display">\begin{aligned} 原式 

   &=\sum_{i=1}^A\sum_{j=1}^B\sum_{k=1}^C \sum_{u\mid i} \sum_{v\mid j} \sum_{w\mid k} [u\bot u] [u\bot w] [v\bot w] \\\\

  &=\sum_u \sum_v \sum_w [u\bot v] [u\bot w] [v\bot w] \left\lfloor \frac{A}{u} \right\rfloor \left\lfloor \frac{B}{v} \right\rfloor \left\lfloor \frac{C}{w} \right\rfloor \\

\end{aligned}</script><p>  考虑记忆化搜索<del>(指暴力)</del></p>
<p>  设 $f_{i,A,B,C}$ 表示对于所有满足 $(u,v) ; (u,w) ; (v,w)$ 的所有公共素因子不小于第 $i$ 个素数 $p_i$ 时 $\left\lfloor \frac{a}{u} \right\rfloor \left\lfloor \frac{b}{v} \right\rfloor \left\lfloor \frac{c}{w} \right\rfloor$ 的求和</p>
<p>  考虑转移：分为三组，两两考虑，以 $(u,v)$ 为例：</p>
<p>  对于 $f_{i-1,A,B,C}$ 可以分成两组：</p>
<p>  - $(u,v)$ 的公共素因子均不小于 $p_i$ ，我们需要的是这部分</p>
<p>  - $(u,v)$ 的公共素因子有 $p_{i-1}$ ，这部分需要被减去，即减去</p>
<script type="math/tex; mode=display">\left\lfloor \frac{\left\lfloor \frac{A}{p_{i-1}} \right\rfloor}{u} \right\rfloor \left\lfloor \frac{\left\lfloor \frac{B}{p_{i-1}} \right\rfloor}{v} \right\rfloor \left\lfloor \frac{C}{w} \right\rfloor</script><p>  $(u,w) , (v,w)$ 同理</p>
<p>  注意 $p_{i-1}\mid(u,v,w)$ 的情况被计算 $3$ 次，所以最后应该加上</p>
<script type="math/tex; mode=display">\left\lfloor \frac{\left\lfloor \frac{A}{p_{i-1}} \right\rfloor}{u} \right\rfloor \left\lfloor \frac{\left\lfloor \frac{B}{p_{i-1}} \right\rfloor}{v} \right\rfloor \left\lfloor \frac{\left\lfloor \frac{C}{p_{i-1}} \right\rfloor}{w} \right\rfloor \times 2</script><hr>
<h2 id="杜教筛"><a href="#杜教筛" class="headerlink" title="杜教筛"></a>杜教筛</h2><ul>
<li><p>用途：求积性函数 $\operatorname{f}(n)$ 的前缀和，即 $\sum_{i=1}^n f(i)$，其时间复杂度低于线性</p>
</li>
<li><p>方法：</p>
<p>$f(i)$ 为已知的函数</p>
<p>设 $S(n)=\sum f(i)$</p>
<p>出于前缀和的考虑，自行选取函数 $g(n)$ ，最好使 $f\circ g$ 的式子中没有除 $n$ 以外的变量</p>
<p>带入公式</p>
</li>
<li><p>推导</p>
<p>设函数 $S(n)=\sum_{i=1}^n f(i)$</p>
<p>要计算出 $S(n)$ 关于 $S\left(\left\lfloor\frac{n}{i}\right\rfloor\right)$ 的递推式才能使复杂度低于线性</p>
<p>设 $S(n)=\sum_{i=1}^n f(i)$</p>
<p>任取一数论函数 $\operatorname{g}$ 均有:</p>
<script type="math/tex; mode=display">\begin{aligned}
\sum_{i=1}^n \sum_{d\mid i} f(d)\cdot g\left(\frac{i}{d}\right)
&=\sum_{i=1}^n f\circ g \\
&=\sum_{i=1}^n g\circ f &\text{迪利克雷卷积性质}\\
&=\sum_{d=1}^n \sum_{k=1}^{\left\lfloor \frac{n}{d} \right\rfloor} g(d)f(k) &\text{改为枚举d，d的倍数k} \\
&=\sum_{d=1}^n g(d) S\left(\left\lfloor \frac{n}{d} \right\rfloor \right) \\
&=\sum_{i=1}^n (f\circ g) &\text{直接由原式得}\\
\end{aligned}</script><p>提取出 $i=1$ 时的 $g(1)S(n)$</p>
<pre><code>注：如果g是积性函数，g(1)=1
</code></pre><script type="math/tex; mode=display">\therefore g(1)S(n)=\sum_{i=1}^n (f\circ g) \ - \ \sum_{d=2}^n g(d) S\left(\left\lfloor \frac{n}{d} \right\rfloor \right)</script></li>
<li><p>$\mu$ 的前缀和</p>
<p>$设\operatorname{g}=I$</p>
<pre><code>I是恒等函数, 见积性函数
</code></pre><script type="math/tex; mode=display">\because \sum_{d\mid n} \mu \circ I=\epsilon(n)</script><script type="math/tex; mode=display">又\because g(1)S(n)=\sum_{i=1}^n \sum_{d\mid i} f(d)\cdot g\left(\frac{i}{d}\right) \ - \ \sum_{d=2}^n g(d) S\left(\left\lfloor \frac{n}{d} \right\rfloor \right)</script><script type="math/tex; mode=display">\therefore S(n)=\sum_{i=1}^n\epsilon(i) \ - \ \sum_{d=2}^n S\left(\left\lfloor \frac{n}{d} \right\rfloor \right)</script><script type="math/tex; mode=display">\therefore S(n)=1 \ - \ \sum_{d=2}^n S\left(\left\lfloor \frac{n}{d} \right\rfloor \right)</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">get_mu</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;MAX) <span class="keyword">return</span> sum_mu[x];<span class="comment">//直接线性筛</span></span><br><span class="line">    <span class="keyword">if</span>(mp_mu[x]) <span class="keyword">return</span> mp_mu[x];</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll l=<span class="number">1</span>,r;l&lt;=x;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">        r=x/(x/l);</span><br><span class="line">        ans-=<span class="built_in">get_mu</span>(x/l)*(r-l+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mp_mu[x]=ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>$\varphi$ 的前缀和</p>
<script type="math/tex; mode=display">由\varphi 性质得 n=\sum_{d\mid n}\varphi(d)</script><script type="math/tex; mode=display">\therefore id=\varphi \circ I</script><p>直接套到杜教筛公式得：</p>
<script type="math/tex; mode=display">\begin{aligned}
S(n)
&=\sum_{i=1}^ni-\sum_{i=2}^nS\left(\left\lfloor \frac{n}{i} \right\rfloor\right) \\
&=\frac{n(n+1)}{2} -\sum_{i=2}^nS\left(\left\lfloor \frac{n}{i} \right\rfloor\right)
\end{aligned}</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vis[<span class="number">0</span>]=vis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    mu[<span class="number">1</span>]=phi[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">2</span>;i&lt;N;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            p[++tot]=i;</span><br><span class="line">            mu[i]=<span class="number">-1</span>;</span><br><span class="line">            phi[i]=i<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=tot &amp;&amp; i*p[j]&lt;N;++j)&#123;</span><br><span class="line">            rei tmp=i*p[j];</span><br><span class="line">            vis[tmp]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%p[j])&#123;</span><br><span class="line">                mu[tmp]=-mu[i];</span><br><span class="line">                phi[tmp]=phi[i]*phi[ p[j] ];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                mu[tmp]=<span class="number">0</span>;</span><br><span class="line">                phi[tmp]=phi[i]*p[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rei i=<span class="number">1</span>;i&lt;N;++i)&#123;</span><br><span class="line">        mu[i]+=mu[i<span class="number">-1</span>];</span><br><span class="line">        phi[i]+=phi[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getmu</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;N) <span class="keyword">return</span> mu[x];</span><br><span class="line">    <span class="keyword">if</span>(summu[x]) <span class="keyword">return</span> summu[x];</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll l=<span class="number">2</span>,r;l&lt;=(ll)x;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">        r=x/(x/l);</span><br><span class="line">        ans-=<span class="number">1ll</span>*(r-l+<span class="number">1</span>)*<span class="built_in">getmu</span>(x/l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> summu[x]=ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getphi</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;N) <span class="keyword">return</span> phi[x];</span><br><span class="line">    <span class="keyword">if</span>(sumphi[x]) <span class="keyword">return</span> sumphi[x];</span><br><span class="line">    ll ans=<span class="number">1ll</span>*x*(x+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll l=<span class="number">2</span>,r;l&lt;=(ll)x;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">        r=x/(x/l);</span><br><span class="line">        ans-=<span class="number">1ll</span>*(r-l+<span class="number">1</span>)*<span class="built_in">getphi</span>(x/l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sumphi[x]=ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
</search>
